<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Fright Night</title>
        <script src="adversaries.js"></script>
        <style>
            :root {
                /* --body-bg-color: rgb(13, 17, 23);
                --text-color: rgb(159, 177, 209);
                --adversary-bg-color: rgb(22, 26, 32);
                --adversary-border-color: rgb(50, 54, 59);
                --adversary-text-color: var(--text-color);
                --header-text-color: #c3d0e5; */

                /* --body-bg-color: rgb(38,36,43);
                --text-color: white; (95,114,176)
                --adversary-bg-color: rgb(45,44,64);
                --stats-bg-color: rgb(50,52,86);
                --adversary-border-color: rgb(63,73,126);
                --adversary-text-color: var(--text-color);
                --header-text-color: white; */

                /** Palette courtesy of https://colorffy.com/dark-theme-generator?colors=825aa2-121212 */
                /** Base colors */
                --clr-dark-a0: #000000;
                --clr-light-a0: #ffffff;

                /** Theme primary colors */
                --clr-primary-a0: #825aa2;
                --clr-primary-a10: #906bac;
                --clr-primary-a20: #9e7db6;
                --clr-primary-a30: #ac8fc1;
                --clr-primary-a40: #b9a1cb;
                --clr-primary-a50: #c7b3d5;

                /** Theme surface colors */
                --clr-surface-a0: #121212;
                --clr-surface-a10: #282828;
                --clr-surface-a20: #3f3f3f;
                --clr-surface-a30: #575757;
                --clr-surface-a40: #717171;
                --clr-surface-a50: #8b8b8b;

                /** Theme tonal surface colors */
                --clr-surface-tonal-a0: #1c191f;
                --clr-surface-tonal-a10: #312e34;
                --clr-surface-tonal-a20: #47444a;
                --clr-surface-tonal-a30: #5f5c61;
                --clr-surface-tonal-a40: #777579;
                --clr-surface-tonal-a50: #918f93;

                --body-bg-color: var(--clr-surface-a0);
                --text-color: var(--clr-light-a0);
                --adversary-bg-color: var(--clr-surface-a10);
                --stats-bg-color: var(--clr-surface-a20);
                --adversary-border-color: var(--adversary-bg-color);
                --adversary-text-color: var(--text-color);
                --header-text-color: var(--clr-primary-a50);

                --button-bg-color: var(--clr-primary-a20);
                --button-bg-hover-color: var(--clr-primary-a10);
                --button-bg-active-color: var(--clr-primary-a0);
                --button-text-color: var(--clr-dark-a0);
            }
            body {
                background-color: var(--body-bg-color);
                color: var(--text-color);
            }
            .hidden {
                display: none;
            }
            #copyright, #repo-info {
                font-size: smaller;
                margin-top: 10px;
            }
            input#load-encounters {
                /* Hide the file input element and style its label as a button */
                display: none;
            }
            #load-encounters-container {
                /* Need vertical margin to make room for label padding */
                margin: 10px 0px;
            }
            #load-encounters-container label {
                /* TODO: When styling real buttons, don't forget to update this to match */
                background-color: var(--button-bg-color);
                color: var(--button-text-color);
                padding: 5px;
                border-radius: 8px;
                height: auto;
            }
            #load-encounters-container label:hover {
                background-color: var(--button-bg-hover-color);
            }
            #load-encounters-container label:active {
                background-color: var(--button-bg-active-color);
            }

            .adversary {
                position: relative; /* For action button */
                display: inline-block;
                vertical-align: top;
                /*
                    22em is empirical width needed to fit full ATK line for Volcanic Dragon: Ashen Tyrant.
                    Longest ATK line in SRD is "Fallen Warlord: Undefeated Champion",
                    which requires 27em (at 22em, both ATK and Experience lines overflow).
                    27em feels way too wide. Trying 23em, which is enough to stop Fallen Warlord's
                    Experience line from overflowing.
                */
                width: 23em;
                border: 1px ridge var(--adversary-border-color);
                border-radius: 5px;
                margin-right: 5px;
                margin-top: 5px;
                padding: 5px 10px;
                background-color: var(--adversary-bg-color);
                color: var(--adversary-text-color);
            }
            .adversary h3 {
                margin: 8px 0px;
                color: var(--header-text-color);
            }
            .adversary p {
                margin: 2px 0px;
            }
            .adversary .source {
                font-style: italic;
                font-size: smaller;
            }
            .adversary .tier {
                font-style: italic;
                font-weight: bold;
            }
            .adversary .description {
                font-size: smaller;
                font-style: italic;
            }
            .adversary .motives {
                font-size: smaller;
            }
            .adversary .stats {
                background-color: var(--stats-bg-color);
                border-radius: 3px;
            }
            .adversary .statLabel, .adversary .motivesLabel {
                font-weight: bold;
            }
            .adversary .divider {
                font-size: larger;
                margin: 0px 3px;
            }
            .features {
                margin-left: 0.75em;
            }
            .featuresExpander summary {
                font-weight: bold;
            }
            .features .feature {
                text-indent: -0.75em
            }
            .featureLabel {
                font-style: italic;
                font-weight: bold;
            }

            .slots {
                display: inline-block
            }

            .conditions {
                margin: 5px 0px;
            }
            ul.conditions-list {
                list-style: none;
                display: inline;
                padding: 0px;
            }
            ul.conditions-list li {
                display: inline;
                margin-right: 5px;
            }

            ul.modifications-list {
                margin: 5px 0px;
            }

            button {
                /* font-size: 1.5em;
                line-height: 1em; */
                padding: 5px;
                border-radius: 8px;
                color: var(--button-text-color);
                border: 0px;
                background-color: var(--button-bg-color);
            }
            button:hover {
                background-color: var(--button-bg-hover-color);
            }
            button:active {
                background-color: var(--button-bg-active-color);
            }
            button:disabled {
                background-color: var(--clr-surface-a50);
                opacity: 0.7;;
            }

            button.inline-delete {
                background-color: transparent;
                color: var(--clr-primary-a50);
                border: 0px;
                border-radius: 3px;
                padding: 2px 4px;
                margin: 0px 1px;
                font-size: smaller;
            }

            button.inline-add {
                border: 0px;
                border-radius: 2px;
                padding: 3px 4px;
            }

            button.action {
                float: right;
            }
            button.action-top {
                position: absolute;
                right: 5px;
                top: 5px;

                padding: 2px 4px;
                border-radius: 4px;
                font-size: smaller;
            }

            .actions-menu {
                position: absolute;
                right: 5px;
                top: 30px;
                margin: 0px;
                padding: 0px;
                list-style-type: none;
                /* TODO: Make this look like a menu, round some corners, etc */
            }
            .actions-menu button {
                border-radius: 0px;
                width: 100%;
            }

            #adversary-editor-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                z-index: 1000; /* Ensure it is above other content */
            }
            #adversary-editor {
                position: fixed;
                width: 25em;
                top: 100px;
                left: 50%;
                transform: translateX(-50%);
                background-color: var(--clr-surface-tonal-a10);
                padding: 20px;
                border-radius: 10px;
                box-shadow: 10px 10px 10px black;
            }
            #adversary-editor h2 {
                text-align: center;
                padding: 0px;
                margin: 0px;
            }
            #adversary-features {
                overflow-y: scroll;
                max-height: 20em;
            }
        </style>
    </head>

    <body>
        <datalist id="srd-conditions">
            <option value="Hidden"></option>
            <option value="Restrained"></option>
            <option value="Vulnerable"></option>
            <option value="Asleep"></option>
            <option value="Stunned"></option>
            <option value="Silenced"></option>
            <option value="Corroded"></option>
            <option value="Ranger's Focus"></option>
            <option value="Cloaked"></option>
            <option value="Dizzied"></option>
            <option value="Enveloped"></option>
        </datalist>

        <datalist id="modifiable-properties">
            <option value="difficulty"></option>
            <option value="majorThreshold"></option>
            <option value="severeThreshold"></option>
        </datalist>

        <div id="load-encounters-container">
            <label for="load-encounters">Load Encounters (replaces existing encounters)</label>
            <input type="file" id="load-encounters" accept=".json" />
        </div>

        <div id="encounters"></div>

        <div id="adversary-editor-overlay" class="hidden">
            <div id="adversary-editor">
                <h2>Edit Adversary</h2>
                <!-- Only advantage of Form that I can see is that it gives validation and submit-on-enter for free-->
                <div id="adversary-form">
                    <fieldset>
                        <legend>Basics</legend>
                        <label for="adversary-name">Name:</label>
                        <input type="text" id="adversary-name" size="30" required />
                        <br>
                        <label for="adversary-tier">Tier:</label>
                        <input type="number" id="adversary-tier" min="1" max="4" value="1" required />
                        <label for="adversary-type">Type:</label>
                        <select id="adversary-type">
                            <option value="Bruiser">Bruiser</option>
                            <option value="Horde">Horde</option>
                            <option value="Leader">Leader</option>
                            <option value="Minion">Minion</option>
                            <option value="Ranged">Ranged</option>
                            <option value="Skulk">Skulk</option>
                            <option value="Social">Social</option>
                            <option value="Solo">Solo</option>
                            <option value="Standard">Standard</option>
                            <option value="Support">Support</option>
                        </select>
                        <br>
                        <label for="adversary-description">Description:</label>
                        <textarea id="adversary-description" cols="30" rows="3"></textarea>
                        <br>
                        <label for="adversary-motives">Motives & Tactics:</label>
                        <textarea id="adversary-motives" cols="30" rows="2"></textarea>
                    </fieldset>
                    <fieldset>
                        <legend>Stats</legend>
                        <label for="adversary-difficulty">Difficulty:</label>
                        <input type="number" id="adversary-difficulty" min="0" max="20" value="12" required />
                        <br>
                        <label for="adversary-major-threshold">Major Threshold:</label>
                        <input type="number" id="adversary-major-threshold" min="0" max="20" value="8" />
                        /
                        <label for="adversary-severe-threshold">Severe Threshold:</label>
                        <input type="number" id="adversary-severe-threshold" min="0" max="20" value="14" />
                        <br>
                        <label for="adversary-hp">HP:</label>
                        <input type="number" id="adversary-hp" min="1" max="20" value="5" required />
                        <label for="adversary-stress">Stress:</label>
                        <input type="number" id="adversary-stress" min="0" max="20" value="2" required />
                        <br>
                        <label for="adversary-experience">Experience:</label>
                        <input type="text" id="adversary-experience" />
                    </fieldset>
                    <fieldset>
                        <legend>Attack</legend>
                        <label for="adversary-attack-modifier">Modifier:</label>
                        <!-- <input type="number" id="adversary-attack-modifier" min="-10" max="20" value="0" /> -->
                        <input type="text" id="adversary-attack-modifier" size="3" />
                        <label for="adversary-attack-description">Description:</label>
                        <input type="text" id="adversary-attack-description" />
                        <br>
                        <label for="adversary-attack-range">Range:</label>
                        <select id="adversary-attack-range">
                            <option value="Melee">Melee</option>
                            <option value="Very Close">Very Close</option>
                            <option value="Close">Close</option>
                            <option value="Far">Far</option>
                        </select>
                        <label for="adversary-attack-damage">Damage:</label>
                        <input type="text" id="adversary-attack-damage" size="12" /> <!-- TODO: Hint at format and phy/mag -->
                    </fieldset>
                    <fieldset id="adversary-features">
                        <legend>Features</legend>
                        <button id="add-feature">+ Add Feature</button> <!-- TODO: Position this statically up top? -->
                    </fieldset>
                    <button id="cancel-adversary-edit">Cancel</button>
                    <button type="submit" id="save-adversary-edit">Save</button>
                </div>
            </div>
        </div>

        <div id="repo-info">
            <p>Fright Night is free and open source and works entirely offline. Please <a href="https://github.com/sandyarmstrong/frightnight/issues">report any bugs or feature requests</a>.</p>
        </div>

        <div id="copyright">
            <p>This project includes materials from the Daggerheart System Reference Document 1.0,
                © Critical Role, LLC. under the terms of the Darrington Press Community Gaming (DPCGL) License.
                More information can be found at <a href="https://www.daggerheart.com">https://www.daggerheart.com</a>.
                Minor formatting modifications were provided as part of the excellent
                <a href="https://github.com/seansbox/daggerheart-srd">https://github.com/seansbox/daggerheart-srd</a>.</p>
        </div>
    </body>

    <script>
        // TODO: Consider moving hp/stress/conditions/modifications state to something
        //       like adversaries[n].instances[] so that we can behave like the Quickstart
        //       and have one statblock for muliple identical enemies. But need to decide
        //       how to display conditions and especially modifications in that case.
        //
        //       Do this sooner rather than later, even if only one instance is supported,
        //       to avoid breaking state compatibility.
        //
        //       Also, some questions:
        //       - Presumably, there would be a + button to add a new instance right in
        //         the statblock. But what if a user adds the same adversary type from
        //         the search? Should this use the same statblock or start a new "group"?
        //         I think I prefer the latter, let users decide if they prefer shared
        //         or separate statblocks, and they might have use for grouping anyway.
        //       - How to handle naming? Wouldn't want to name the whole statblock
        //         "Jagged Knife Bandit #1" anymore.
        //       - Are there modifications that can change number of HP/Stress slots?
        var sampleState = {
            "encounters": [
                {
                    "name": "Forest Ambush",
                    "targetBattlePoints": 10, // Allows telling user they might need more or less adversaries
                    "currentFear": 5, // Convenient. Also allows remembering fear state for different groups
                    "playerTier": 1, // Needed to help calculate battle points, if adversary tiers differ
                    "playerCount": 3, // Need to calculate minion battle points
                    "description": "A group of bandits ambushes the party in a dense forest.",
                    "adversaries": [
                        {
                            "name": "Bandit #1",
                            "originalName": "Jagged Knife Bandit",
                            "source": "SRD",
                            "tier": 1,
                            "type": "Standard",
                            "difficulty": 12,
                            "majorThreshold": 8,
                            "severeThreshold": 14,
                            "hp": {
                                "slots": 5,
                                "marked": 3
                            },
                            "stress": {
                                "slots": 3,
                                "marked": 0
                            },
                            "modifications": [
                                {
                                    "modificationName": "Distracted",
                                    "propertyName": "difficulty",
                                    "modification": "-2" // - or + to modify, or just a number to hard-set, mods are applied in order
                                }
                            ],
                            "conditions": [
                                "Restrained",
                                "Vulnerable"
                            ]
                        }
                    ]
                }
            ],
            "customAdversaries": [], // Yay homebrew, allow searching this, adding, modifying
            "environments": [] // Big TODO
        };

        // TODO: Change all code that puts user data directly into innerHTML

        const adversaryRemovedEvent = new Event("adversaryRemoved");
        const adversaryCopiedEvent = new Event("adversaryCopied");
        const adversaryCopiedFromSourceEvent = new Event("adversaryCopiedFromSource");

        var adversaryEditor = document.querySelector("#adversary-editor");
        var adversaryEditorOverlay = document.querySelector("#adversary-editor-overlay");

        var expandAllDetails = false;

        function handleDetailsToggle(event) {
            var opened = event.target.open
            if (expandAllDetails != opened) {
                expandAllDetails = opened;
                for (const element of document.getElementsByTagName("details")) {
                    if (element.open != expandAllDetails) {
                        element.open = expandAllDetails;
                    }
                }
            }
        }

        document.querySelector("#add-feature").addEventListener("click", function() {
            var featuresFieldset = adversaryEditor.querySelector("#adversary-features");
            var featureCount = featuresFieldset.querySelectorAll(".feature").length;
            // TODO: Abstract this, use in createAdversaryElement as well
            var featureElement = document.createElement("div");
            featureElement.className = "feature";
            featureElement.innerHTML = `<label for="adversary-feature-name-${featureCount}">Name:</label><input type="text" class="adversary-feature-name" id="adversary-feature-name-${featureCount}"><label for="adversary-feature-text-${featureCount}">Description:</label><textarea class="adversary-feature-text" id="adversary-feature-text-${featureCount}" rows="4" cols="50"></textarea>`;
            featuresFieldset.appendChild(featureElement);
            // TODO: Allow deletion (but could also do this by deleting all text for a feature)
        });

        document.querySelector("#cancel-adversary-edit").addEventListener("click", function() {
            adversaryEditor.adversary = undefined;
            adversaryEditorOverlay.classList.add("hidden");
        });

        document.querySelector("#save-adversary-edit").addEventListener("click", function() {
            // 0. When showing/populating the editor, the adversary should be attached to the
            //    #adversary-editor element as a property that can be accessed here.
            // 1. Update the adversary object with the values from the editor.
            // 2. Trigger a redraw of the adversary (missing this).
            // 3. In the case where this is a new adversary, perhaps it would already have
            //    been added to the encounter, but is just blank? So refreshing would still
            //    work? If not, just create the element afterward. Also add to customAdversaries
            //    in the state, which can be searched/referenced/etc just like the SRD.
            // 4. Finally, clear the adversary property from #adversary-editor and hide the editor.

            // TODO: Validation? Use a form?

            var adversary = adversaryEditor.adversary;
            if (adversary) {
                // Basics
                adversary.name = adversaryEditor.querySelector("#adversary-name").value.trim();
                adversary.tier = parseInt(adversaryEditor.querySelector("#adversary-tier").value);
                adversary.type = adversaryEditor.querySelector("#adversary-type").value;
                // TODO: Don't set optional fields if empty
                adversary.description = adversaryEditor.querySelector("#adversary-description").value.trim();
                adversary.motivesAndTactics = adversaryEditor.querySelector("#adversary-motives").value.trim();

                // Stats
                adversary.difficulty = parseInt(adversaryEditor.querySelector("#adversary-difficulty").value);
                adversary.majorThreshold = parseInt(adversaryEditor.querySelector("#adversary-major-threshold").value);
                adversary.severeThreshold = parseInt(adversaryEditor.querySelector("#adversary-severe-threshold").value);
                adversary.hp.slots = parseInt(adversaryEditor.querySelector("#adversary-hp").value);
                adversary.stress.slots = parseInt(adversaryEditor.querySelector("#adversary-stress").value);
                adversary.experience = adversaryEditor.querySelector("#adversary-experience").value.trim();

                // Attack
                adversary.attackModifier = adversaryEditor.querySelector("#adversary-attack-modifier").value.trim();
                adversary.attackDescription = adversaryEditor.querySelector("#adversary-attack-description").value.trim();
                adversary.attackRange = adversaryEditor.querySelector("#adversary-attack-range").value;
                adversary.attackDamage = adversaryEditor.querySelector("#adversary-attack-damage").value.trim();

                // Features
                adversary.features = [];
                var featureElements = adversaryEditor.querySelectorAll("#adversary-features .feature");
                featureElements.forEach(function(featureElement) {
                    var feature = {
                        name: featureElement.querySelector(".adversary-feature-name").value.trim(),
                        text: featureElement.querySelector(".adversary-feature-text").value.trim()
                    };
                    adversary.features.push(feature);
                });
            }

            // TODO: Refresh display

            if (adversaryEditor.saveState) {
                adversaryEditor.saveState();
            }
            adversaryEditor.adversary = undefined;
            adversaryEditorOverlay.classList.add("hidden");
        });

        function createFearTracker(encounter, saveState) {
            // TODO: Nice simple rich tooltip guide: https://jsfiddle.net/8nnwytbL/
            // TODO: Roller for getting fear on rests?
            // TODO: Replace this with a stylized number input?
            var fearDiv = document.createElement("div");

            var fearValue = document.createElement("span");

            function updateFearDisplay() {
                fearValue.innerText = "💀".repeat(encounter.currentFear);
                fearValue.title = `${encounter.currentFear} Fear | Start: {number of PCs} | Short rest: 1d4 | Long rest: 1d4 + {number of PCs}`;
            }
            updateFearDisplay();

            var useFearButton = document.createElement("button");
            useFearButton.innerText = "-";
            useFearButton.title = "Use 1 Fear";
            useFearButton.onclick = function() {
                if (encounter.currentFear > 0) {
                    encounter.currentFear--;
                    updateFearDisplay();
                    saveState();
                }
            };

            var gainFearButton = document.createElement("button");
            gainFearButton.innerText = "+";
            gainFearButton.title = "Gain 1 Fear (max 12)";
            gainFearButton.onclick = function() {
                if (encounter.currentFear < 12) {
                    encounter.currentFear++;
                    updateFearDisplay();
                    saveState();
                }
            };

            fearDiv.appendChild(useFearButton);
            fearDiv.appendChild(gainFearButton);
            fearDiv.appendChild(fearValue);

            return fearDiv;
        }

        function updateResource(container, resource, saveState) {
            var elements = [];

            for (var i = 0; i < resource.slots; i++) {
                var slot = document.createElement("input");
                slot.type = "checkbox";
                if (i < resource.marked) {
                    slot.checked = true;
                }
                slot.onclick = function(event) {
                    if (event.target.checked) {
                        resource.marked++;
                    } else {
                        resource.marked--;
                    }
                    updateResource(container, resource, saveState);
                    saveState();
                };
                elements.push(slot);
            }

            container.replaceChildren(...elements);
        }

        function createAdversaryElement(encounter, adversary, saveState) {
            // TODO: Allow reordering?

            var warning = "";
            if (adversary.tier > encounter.playerTier) {
                warning += "⚠️ above player tier";
            }
            else if (adversary.tier < encounter.playerTier) {
                warning += "⚠️ below player tier"
            }

            var adversaryDiv = document.createElement("div");
            adversaryDiv.className = "adversary";
            adversaryDiv.innerHTML = `<h3>${adversary.name}</h3> <p class="source">(${adversary.originalName}, ${adversary.source})</p>`;

            var tierAndType = document.createElement("p");
            tierAndType.className = "tier";
            tierAndType.innerText = `Tier ${adversary.tier} ${adversary.type}`;
            if (warning) {
                tierAndType.innerHTML += ` <span class="warning">(${warning})</span>`;
            }
            adversaryDiv.appendChild(tierAndType);

            if (adversary.description) {
                var description = document.createElement("p");
                description.className =  "description";
                description.innerText = adversary.description;
                adversaryDiv.appendChild(description);
            }

            if (adversary.motivesAndTactics) {
                var motives = document.createElement("p");
                motives.className =  "motives";
                motives.innerHTML = `<span class="motivesLabel">Motives & Tactics:</span> ${adversary.motivesAndTactics}`;
                adversaryDiv.appendChild(motives);
            }

            var stats = document.createElement("p");
            stats.className = "stats";
            var thresholds = "None";
            if (Number.isInteger(adversary.majorThreshold) && Number.isInteger(adversary.severeThreshold)) {
                thresholds = `${adversary.majorThreshold}/${adversary.severeThreshold}`;
            }
            stats.innerHTML = `<span class="statLabel">Difficulty:</span> ${adversary.difficulty} <span class="divider">|</span> <span class="statLabel">Thresholds:</span> ${thresholds}`;
            if (adversary.attackDescription) {
                stats.innerHTML += `<br><span class="statLabel">ATK:</span> ${adversary.attackModifier} <span class="divider">|</span> <span class="statLabel">${adversary.attackDescription}:</span> ${adversary.attackRange} <span class="divider">|</span> ${adversary.attackDamage}`;
            }
            if (adversary.experience) {
                // TODO: <hr> is lame to style, but add some sort of divider above this (top border?)
                stats.innerHTML += `<br><span class="statLabel experiences">Experience:</span> ${adversary.experience}`;
            }
            adversaryDiv.appendChild(stats);

            if (adversary.features && adversary.features.length > 0) {
                var featuresContainer = document.createElement("details");
                featuresContainer.className = "featuresExpander";
                featuresContainer.innerHTML = `<summary>FEATURES</summary>`;
                var featuresDiv = document.createElement("div");
                featuresDiv.className = "features";
                featuresContainer.appendChild(featuresDiv);
                featuresContainer.addEventListener("toggle", handleDetailsToggle);

                for (var i = 0; i < adversary.features.length; i++) {
                    var featureElement = document.createElement("p");
                    featureElement.className = "feature"; // TODO: Make sure to style with that indent on following lines
                    featuresDiv.appendChild(featureElement);

                    var label = document.createElement("span");
                    label.className = "featureLabel";
                    label.innerText = `${adversary.features[i].name}:`;
                    featureElement.appendChild(label);

                    var description = document.createElement("span");
                    description.innerText = ` ${adversary.features[i].text}`;
                    featureElement.appendChild(description);
                }

                adversaryDiv.appendChild(featuresContainer);
            }

            var hpDiv = document.createElement("div");
            hpDiv.className = "slotInfo";
            hpDiv.innerHTML = "HP:";
            var hpSlotsDiv = document.createElement("div");
            hpSlotsDiv.className = "slots";
            updateResource(hpSlotsDiv, adversary.hp, saveState);
            hpDiv.appendChild(hpSlotsDiv);
            adversaryDiv.appendChild(hpDiv);

            var stressDiv = document.createElement("div");
            stressDiv.className = "slotInfo";
            stressDiv.innerHTML = "Stress:";
            var stressSlotsDiv = document.createElement("div");
            stressSlotsDiv.className = "slots";
            updateResource(stressSlotsDiv, adversary.stress, saveState);
            stressDiv.appendChild(stressSlotsDiv);
            adversaryDiv.appendChild(stressDiv);

            // TODO: Parse modifications and reflect them in the stats
            var conditionsDiv = document.createElement("div");
            conditionsDiv.className = "conditions";
            var conditionsDisplayDiv = document.createElement("div");
            conditionsDiv.appendChild(conditionsDisplayDiv)

            function updateConditionsDisplay() {
                conditionsDisplayDiv.innerHTML = "Conditions: ";
                if (adversary.conditions && adversary.conditions.length > 0) {
                    var conditionsList = document.createElement("ul");
                    conditionsList.className = "conditions-list";
                    for (var i = 0; i < adversary.conditions.length; i++) {
                        var condition = adversary.conditions[i];

                        var conditionItem = document.createElement("li");
                        conditionsList.appendChild(conditionItem);

                        var conditionText = document.createElement("span");
                        conditionText.innerText = condition;
                        conditionItem.appendChild(conditionText);

                        var removeButton = document.createElement("button");
                        removeButton.className = "inline-delete";
                        removeButton.innerText = "X";
                        removeButton.title = "Remove condition";
                        removeButton.condition = condition;
                        removeButton.onclick = function(event) {
                            adversary.conditions = adversary.conditions.filter(function(c) {
                                return c !== event.target.condition;
                            });
                            updateConditionsDisplay();
                            saveState();
                        };
                        conditionItem.appendChild(removeButton);
                    }
                    conditionsDisplayDiv.appendChild(conditionsList);
                } else {
                    conditionsDisplayDiv.innerText += " None";
                }
            }

            updateConditionsDisplay();

            var addConditionsDiv = document.createElement("div");
            var addConditionInput = document.createElement("input");
            addConditionInput.type = "text";
            addConditionInput.setAttribute("list", "srd-conditions");
            var addConditionButton = document.createElement("button");
            addConditionButton.className = "inline-add";
            addConditionButton.innerText = "+";
            addConditionButton.title = "Add condition";
            addConditionButton.onclick = function() {
                var condition = addConditionInput.value.trim();
                if (condition && (!adversary.conditions || !adversary.conditions.includes(condition))) {
                    if (!adversary.conditions) {
                        adversary.conditions = [];
                    }
                    adversary.conditions.push(condition);
                    addConditionInput.value = "";
                    updateConditionsDisplay();
                    saveState();
                }
            };
            addConditionInput.addEventListener("keyup", function(event) {
                if (event.keyCode === 13) { // Enter key
                    event.preventDefault();
                    addConditionButton.click();
                }
            });
            addConditionsDiv.appendChild(addConditionInput);
            addConditionsDiv.appendChild(addConditionButton);
            conditionsDiv.appendChild(addConditionsDiv);
            adversaryDiv.appendChild(conditionsDiv);

            var modificationsContainer = document.createElement("details");
            modificationsContainer.innerHTML = `<summary>Modifications</summary>`;
            var modificationsDiv = document.createElement("div");
            modificationsDiv.className = "modifications";
            modificationsContainer.appendChild(modificationsDiv);
            var modificationsDisplayDiv = document.createElement("div");
            modificationsDiv.appendChild(modificationsDisplayDiv);
            modificationsContainer.addEventListener("toggle", handleDetailsToggle);

            function updateModificationsDisplay() {
                modificationsDisplayDiv.innerHTML = "";
                if (adversary.modifications && adversary.modifications.length > 0) {
                    var modificationsList = document.createElement("ul");
                    modificationsList.className = "modifications-list";
                    for (var i = 0; i < adversary.modifications.length; i++) {
                        var modification = adversary.modifications[i];

                        var modificationItem = document.createElement("li");
                        modificationsList.appendChild(modificationItem);

                        var modificationText = document.createElement("span");
                        modificationText.innerText = `${modification.modificationName} (${modification.propertyName} ${modification.modification})`;
                        modificationItem.appendChild(modificationText);

                        var removeButton = document.createElement("button");
                        removeButton.className = "inline-delete";
                        removeButton.innerText = "X";
                        removeButton.title = "Remove modification";
                        removeButton.modification = modification;
                        removeButton.onclick = function(event) {
                            adversary.modifications = adversary.modifications.filter(function(m) {
                                return m !== event.target.modification;
                            });
                            updateModificationsDisplay();
                            saveState();
                        };
                        modificationItem.appendChild(removeButton);
                    }
                    modificationsDisplayDiv.appendChild(modificationsList);
                }
            }

            updateModificationsDisplay();

            // TODO: This UI is pretty big, taking up a lot of space if
            //       there are a lot of adversaries, even if there are no modifications.
            //       Could make the input into a modal instead. Could also consider
            //       displaying modifications directly in the stats, with details
            //       on hover (but then how to delete?).
            var addModificationsDiv = document.createElement("div");
            var addModificationNameInput = document.createElement("input");
            addModificationNameInput.type = "text";
            addModificationNameInput.placeholder = "Name";
            var addModificationPropertyInput = document.createElement("input");
            addModificationPropertyInput.type = "text";
            addModificationPropertyInput.placeholder = "Target Property";
            addModificationPropertyInput.setAttribute("list", "modifiable-properties");
            var addModificationValueInput = document.createElement("input");
            addModificationValueInput.type = "text";
            addModificationValueInput.placeholder = "Modifier (e.g. -2, +3, 10)";
            var addModificationButton = document.createElement("button");
            addModificationButton.className = "inline-add";
            addModificationButton.innerText = "+";
            addModificationButton.title = "Add modification";
            addModificationButton.onclick = function() {
                var modificationName = addModificationNameInput.value.trim();
                var propertyName = addModificationPropertyInput.value.trim();
                var modificationValue = addModificationValueInput.value.trim();
                if (modificationName && propertyName && modificationValue) {
                    if (!adversary.modifications) {
                        adversary.modifications = [];
                    }
                    adversary.modifications.push({
                        modificationName: modificationName,
                        propertyName: propertyName,
                        modification: modificationValue
                    });
                    addModificationNameInput.value = "";
                    addModificationPropertyInput.value = "";
                    addModificationValueInput.value = "";
                    updateModificationsDisplay();
                    saveState();
                }
            };
            addModificationsDiv.appendChild(addModificationNameInput);
            addModificationsDiv.appendChild(addModificationPropertyInput);
            addModificationsDiv.appendChild(addModificationValueInput);
            addModificationsDiv.appendChild(addModificationButton);
            modificationsDiv.appendChild(addModificationsDiv);
            adversaryDiv.appendChild(modificationsContainer);

            // var addInstanceButton = document.createElement("button");
            // addInstanceButton.className = "action";
            // addInstanceButton.innerText = "+ Add";
            // addInstanceButton.title = "Add another instance of this adversary";
            // adversaryDiv.appendChild(addInstanceButton);

            var actionsMenu = document.createElement("menu");
            actionsMenu.className = "actions-menu";

            var editAction = document.createElement("li");
            editAction.innerHTML = `<button class="menu-action">Edit</button>`;
            editAction.title = "Edit this adversary";
            editAction.onclick = function() {
                // Basics
                var editor = document.getElementById("adversary-editor");
                editor.querySelector("#adversary-name").value = adversary.name;
                editor.querySelector("#adversary-tier").value = adversary.tier;
                editor.querySelector("#adversary-type").value = adversary.type; // TODO: Case mangling as needed
                editor.querySelector("#adversary-description").value = adversary.description || "";
                editor.querySelector("#adversary-motives").value = adversary.motivesAndTactics || "";

                // Stats
                editor.querySelector("#adversary-difficulty").value = adversary.difficulty;
                editor.querySelector("#adversary-major-threshold").value = adversary.majorThreshold;
                editor.querySelector("#adversary-severe-threshold").value = adversary.severeThreshold;
                editor.querySelector("#adversary-hp").value = adversary.hp.slots;
                editor.querySelector("#adversary-stress").value = adversary.stress.slots;
                editor.querySelector("#adversary-experience").value = adversary.experience || "";

                // Attack
                editor.querySelector("#adversary-attack-modifier").value = adversary.attackModifier || ""; // TODO: Should input be number, then conversion?
                editor.querySelector("#adversary-attack-description").value = adversary.attackDescription || "";
                editor.querySelector("#adversary-attack-range").value = adversary.attackRange || ""; // TODO: Case mangling as needed
                editor.querySelector("#adversary-attack-damage").value = adversary.attackDamage || "";

                // Features
                editor.querySelectorAll(".feature").forEach(function(featureElement) {
                    featureElement.remove();
                });
                if (adversary.features && adversary.features.length > 0) {
                    var featuresFieldset = editor.querySelector("#adversary-features");

                    for (var i = 0; i < adversary.features.length; i++) {
                        var feature = adversary.features[i];
                        var featureElement = document.createElement("div");
                        featureElement.className = "feature";
                        featureElement.innerHTML = `<label for="adversary-feature-name-${i}">Name:</label><input type="text" class="adversary-feature-name" id="adversary-feature-name-${i}" value="${feature.name}"><label for="adversary-feature-text-${i}">Description:</label><textarea id="adversary-feature-text-${i}" class="adversary-feature-text" rows="4" cols="50">${feature.text}</textarea>`;
                        featuresFieldset.appendChild(featureElement);
                    }
                }
                // TODO: Hook up to Add Feature, Save, and Cancel button

                actionsMenu.remove();
                adversaryEditorOverlay.classList.remove("hidden");
                adversaryEditor.adversary = adversary; // TODO: Save encounter too?
                adversaryEditor.querySelector("#adversary-name").select();
            };
            actionsMenu.appendChild(editAction);

            var copyAction = document.createElement("li");
            copyAction.innerHTML = `<button class="menu-action">Copy</button>`;
            copyAction.title = "Copy this adversary, including all changed state";
            copyAction.onclick = function() {
                adversaryDiv.dispatchEvent(adversaryCopiedEvent);
                actionsMenu.remove();
            };
            actionsMenu.appendChild(copyAction);

            var copyFromSourceAction = document.createElement("li");
            copyFromSourceAction.innerHTML = `<button class="menu-action">Copy From Source</button>`;
            copyFromSourceAction.title = "Copy this adversary from the source, ignoring all changes";
            copyFromSourceAction.onclick = function() {
                adversaryDiv.dispatchEvent(adversaryCopiedFromSourceEvent);
                actionsMenu.remove();
            };
            actionsMenu.appendChild(copyFromSourceAction);

            var deleteAction = document.createElement("li");
            deleteAction.innerHTML = `<button class="menu-action">Remove</button>`;
            deleteAction.title = "Remove this adversary from the encounter";
            deleteAction.onclick = function() {
                adversaryDiv.dispatchEvent(adversaryRemovedEvent);
                actionsMenu.remove();
            };
            actionsMenu.appendChild(deleteAction);

            var actionsButton = document.createElement("button");
            actionsButton.className = "action-top";
            actionsButton.innerText = "…";
            actionsButton.title = "Adversary management actions";
            actionsButton.onclick = function() {
                if (actionsMenu.parentElement) {
                    actionsMenu.remove();
                } else {
                    adversaryDiv.appendChild(actionsMenu);
                }
            };
            adversaryDiv.appendChild(actionsButton);

            return adversaryDiv;
        }

        function addAdversary(container, encounter, adversary, refreshBattlePoints, saveState) {
            var adversaryElement = createAdversaryElement(encounter, adversary, saveState);

            adversaryElement.addEventListener("adversaryRemoved", function(event) {
                encounter.adversaries = encounter.adversaries.filter(function(a) {
                    return a !== adversary;
                });
                container.removeChild(adversaryElement);
                refreshBattlePoints();
                saveState();
            });
            adversaryElement.addEventListener("adversaryCopied", function(event) {
                var newAdversary = JSON.parse(JSON.stringify(adversary)); // Deep copy
                newAdversary.name += " (copy)"; // TODO: Decide naming
                if (!encounter.adversaries) {
                    encounter.adversaries = [];
                }
                encounter.adversaries.push(newAdversary);
                addAdversary(container, encounter, newAdversary, refreshBattlePoints, saveState);
                saveState();
            });
            adversaryElement.addEventListener("adversaryCopiedFromSource", function(event) {
                // TODO: Support non-SRD sources
                if (adversary.source !== "SRD") {
                    console.warn("Copying from non-SRD sources is not supported yet.");
                    return;
                }
                var sourceAdversary = srdAdversaries.find(function(a) {
                    return a.name === adversary.originalName;
                });
                var newAdversary = convertFromSRD(sourceAdversary);
                newAdversary.name += " (copy)"; // TODO: Decide naming
                if (!encounter.adversaries) {
                    encounter.adversaries = [];
                }
                encounter.adversaries.push(newAdversary);
                addAdversary(container, encounter, newAdversary, refreshBattlePoints, saveState);
                saveState();
            });

            container.appendChild(adversaryElement);
            refreshBattlePoints();
        }

        function convertFromSRD(srdAdversary) {
            var thresholds = srdAdversary.thresholds.split("/");
            return {
                name: srdAdversary.name,
                originalName: srdAdversary.name,
                source: "SRD",
                tier: parseInt(srdAdversary.tier),
                type: srdAdversary.type,
                description: srdAdversary.description,
                motivesAndTactics: srdAdversary.motives_and_tactics,
                difficulty: parseInt(srdAdversary.difficulty),
                hp: {
                    slots: parseInt(srdAdversary.hp),
                    marked: 0
                },
                stress: {
                    slots: parseInt(srdAdversary.stress),
                    marked: 0
                },
                majorThreshold: parseInt(thresholds[0]),
                severeThreshold: parseInt(thresholds[1]),
                attackModifier: srdAdversary.atk,
                attackDescription: srdAdversary.attack,
                attackRange: srdAdversary.range,
                attackDamage: srdAdversary.damage,
                experience: srdAdversary.experience,
                features: srdAdversary.feats // array of name/text
            };
        }

        function calculateBattlePoints(encounter)
        {
            var currentBattlePoints = 0;
            for (var j = 0; j < encounter.adversaries.length; j++) {
                var adversary = encounter.adversaries[j];
                // TODO: Deal with tier differences
                switch(adversary.type.toLowerCase()) {
                    case "minion":
                        currentBattlePoints += 1 / encounter.playerCount;
                        break;
                    case "social":
                    case "support":
                        currentBattlePoints += 1;
                        break;
                    case "horde":
                    case "ranged":
                    case "skulk":
                    case "standard":
                        currentBattlePoints += 2;
                        break;
                    case "leader":
                        currentBattlePoints += 3;
                        break;
                    case "bruiser":
                        currentBattlePoints += 4;
                        break;
                    case "solo":
                        currentBattlePoints += 5;
                        break;
                }
            }
            return currentBattlePoints;
        }

        function displayEncounters(state) {
            function saveState() {
                localStorage.setItem("encounters-state", JSON.stringify(state));
            }

            adversaryEditor.saveState = saveState; // TODO: Reset ever?

            var encountersDiv = document.getElementById("encounters");
            encountersDiv.innerHTML = ""; // Clear any existing content

            var saveEncountersButton = document.createElement("button");
            saveEncountersButton.innerText = "Save Encounters";
            encountersDiv.appendChild(saveEncountersButton);

            saveEncountersButton.addEventListener("click", function() {
                var json = JSON.stringify(state, null, "    ");
                var blob = new Blob([json], { type: "application/json" });
                var url = URL.createObjectURL(blob);
                var a = document.createElement("a");
                a.href = url;
                a.download = "encounters.json";
                a.click();
                URL.revokeObjectURL(url);
            });

            // TODO: Actually, show one encounter at a time, and allow switching between them,
            //       as well as adding or deleting encounters.
            for (var i = 0; i < state.encounters.length; i++) {
                var encounter = state.encounters[i];
                var encounterDiv = document.createElement("div");
                encounterDiv.className = "encounter";
                encounterDiv.innerHTML = `<h2>${encounter.name} (Tier ${encounter.playerTier} | ${encounter.playerCount} Players)</h2><p>${encounter.description}</p>`;
                // TODO: Add action menu button like with adversaries to allow editing, deleting, etc.

                var fearDiv = createFearTracker(encounter, saveState);
                encounterDiv.appendChild(fearDiv);

                var battlePointsDiv = document.createElement("div");
                battlePointsDiv.innerHTML = `<p>Target Battle Points: ${encounter.targetBattlePoints} (<span name="current-battle-points"></span> <span name="remaining-suffix"></span>) <span title="TODO: Click for summary from BUILDING BALANCED ENCOUNTERS">ℹ️</span></p>`;
                encounterDiv.appendChild(battlePointsDiv);

                function refreshBattlePoints() {
                    var currentBattlePoints = calculateBattlePoints(encounter);

                    // Round to nearest 0.1 for display
                    var remainingBattlePoints = Math.round((encounter.targetBattlePoints - currentBattlePoints) * 10) / 10;

                    if (remainingBattlePoints < 0) {
                        battlePointsDiv.querySelector("[name='current-battle-points']").innerText = `⚠️ ${Math.abs(remainingBattlePoints)}`;
                        battlePointsDiv.querySelector("[name='remaining-suffix']").innerText = "over";
                    } else {
                        battlePointsDiv.querySelector("[name='current-battle-points']").innerText = Math.abs(remainingBattlePoints);
                        battlePointsDiv.querySelector("[name='remaining-suffix']").innerText = "left";
                    }
                }
                refreshBattlePoints();

                // TODO: Better would be a list of adversaries to choose from,
                //       with filtering based on tier/type + text search.
                //       Rows should include name, source, battle points.
                var addAdversaryDiv = document.createElement("div");
                var srdSearch = document.createElement("input");
                srdSearch.type = "search";
                srdSearch.placeholder = "Search SRD Adversaries";
                srdSearch.setAttribute("list", "srd-adversaries");
                addAdversaryDiv.appendChild(srdSearch);
                encounterDiv.appendChild(addAdversaryDiv);

                var adversariesDiv = document.createElement("div");
                for (var j = 0; j < encounter.adversaries.length; j++) {
                    addAdversary(adversariesDiv, encounter, encounter.adversaries[j], refreshBattlePoints, saveState);
                }
                encounterDiv.appendChild(adversariesDiv);

                var addAdversaryButton = document.createElement("button");
                addAdversaryButton.innerText = "Add Adversary";
                addAdversaryButton.onclick = function() {
                    var selectedOption = srdSearch.value.trim();
                    if (!selectedOption) {
                        // TODO: Or some "custom" type?
                        selectedOption = "Jagged Knife Bandit";
                    }
                    var srdAdversary = srdAdversaries.find(function(a) {
                        return a.name.localeCompare(selectedOption, undefined, { sensitivity: 'base' }) === 0;
                    });
                    if (srdAdversary) {
                        var adversary = convertFromSRD(srdAdversary);
                        var maxDuplicateNumber = 0;
                        for (var k = 0; k < encounter.adversaries.length; k++) {
                            var existingAdversaryNameParts = encounter.adversaries[k].name.split(" #");
                            if (existingAdversaryNameParts[0] === adversary.name) {
                                if (existingAdversaryNameParts.length > 1) {
                                    maxDuplicateNumber = Math.max(parseInt(existingAdversaryNameParts[1]), maxDuplicateNumber);
                                }
                            }
                        }
                        adversary.name += " #" + (maxDuplicateNumber + 1);

                        if (!encounter.adversaries) {
                            encounter.adversaries = [];
                        }
                        encounter.adversaries.push(adversary);
                        addAdversary(adversariesDiv, encounter, adversary, refreshBattlePoints, saveState);
                        saveState();
                    }
                };
                addAdversaryDiv.appendChild(addAdversaryButton);

                srdSearch.addEventListener("keyup", function(event) {
                    if (event.keyCode === 13) { // Enter key
                        event.preventDefault();
                        addAdversaryButton.click();
                    }
                });

                encountersDiv.appendChild(encounterDiv);
            }
        }

        // TODO: This is probably a silly way to do this, we
        //       don't actually want all these DOM elements.
        //       But it's an easy way to get that autocomplete for now.
        // TODO: Also, we want a broader search option, should be able
        //       to search by source, tier, and other arbitrary property text,
        //       and allow easier browsing.
        var srdDatalist = document.createElement("datalist");
        srdDatalist.id = "srd-adversaries";
        for (var i = 0; i < srdAdversaries.length; i++) {
            var option = document.createElement("option");
            option.value = srdAdversaries[i].name;
            srdDatalist.appendChild(option);
        }
        document.body.appendChild(srdDatalist);

        var persistedStateJson = localStorage.getItem("encounters-state");
        if (persistedStateJson) {
            try {
                var state = JSON.parse(persistedStateJson);
                displayEncounters(state);
            } catch (error) {
                console.error("Error loading saved encounters:", error);
                displayEncounters(sampleState);
            }
        } else {
            console.warn("No saved encounters found, displaying sample encounters.");
            displayEncounters(sampleState);
        }

        var fileInput = document.getElementById("load-encounters");
        fileInput.addEventListener("change", function(event) {
            var file = event.target.files[0];
            if (file) {
                var reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        var state = JSON.parse(e.target.result);
                        displayEncounters(state);
                    } catch (error) {
                        console.error("Error loading encounters:", error);
                    }
                };
                reader.onerror = function(e) {
                    console.error("Error reading file:", e);
                };
                reader.readAsText(file);
            }
        });
    </script>
</html>