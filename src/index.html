<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Now Fear This</title>
        <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
        <link rel="manifest" href="site.webmanifest">
        <script src="adversaries.js"></script>
        <script src="sample-encounters.js"></script>
        <style>
            :root {
                /** Palette courtesy of https://colorffy.com/dark-theme-generator?colors=825aa2-121212 */
                /** Base colors */
                --clr-dark-a0: #000000;
                --clr-light-a0: #ffffff;

                /** Theme primary colors */
                --clr-primary-a0: #825aa2;
                --clr-primary-a10: #906bac;
                --clr-primary-a20: #9e7db6;
                --clr-primary-a30: #ac8fc1;
                --clr-primary-a40: #b9a1cb;
                --clr-primary-a50: #c7b3d5;

                /** Theme surface colors */
                --clr-surface-a0: #121212;
                --clr-surface-a10: #282828;
                --clr-surface-a20: #3f3f3f;
                --clr-surface-a30: #575757;
                --clr-surface-a40: #717171;
                --clr-surface-a50: #8b8b8b;

                /** Theme tonal surface colors */
                --clr-surface-tonal-a0: #1c191f;
                --clr-surface-tonal-a10: #312e34;
                --clr-surface-tonal-a20: #47444a;
                --clr-surface-tonal-a30: #5f5c61;
                --clr-surface-tonal-a40: #777579;
                --clr-surface-tonal-a50: #918f93;

                --body-bg-color: var(--clr-surface-a0);
                --text-color: var(--clr-light-a0);
                --adversary-bg-color: var(--clr-surface-a10);
                --stats-bg-color: var(--clr-surface-a20);
                --adversary-border-color: var(--adversary-bg-color);
                --adversary-text-color: var(--text-color);
                --header-text-color: var(--clr-primary-a50);

                --button-bg-color: var(--clr-primary-a20);
                --button-bg-hover-color: var(--clr-primary-a10);
                --button-bg-active-color: var(--clr-primary-a0);
                --button-text-color: var(--clr-dark-a0);
            }
            body {
                background-color: var(--body-bg-color);
                color: var(--text-color);
                margin: 0px;
            }
            .hidden {
                display: none;
            }
            #copyright, #repo-info {
                font-size: smaller;
                margin-top: 10px;
            }

            #top-bar {
                display: flex;
                align-items: center;
                justify-content: space-between;
                top: 0px;
                left: 0px;
                right: 0px;
                padding-left: 10px;
                padding-right: 14px;
                background-color: var(--clr-surface-a10);
                border-bottom: 1px solid var(--clr-surface-a20);
            }
            .top-bar-group > * {
                display: inline-block;
            }
            input#load-encounters {
                /* Hide the file input element and style its label as a button */
                display: none;
            }
            #load-encounters-container {
                /* Need vertical margin to make room for label padding */
                margin: 10px 0px;
            }
            #load-encounters-container label {
                /* NOTE: When styling real buttons, don't forget to update this to match */
                background-color: var(--button-bg-color);
                color: var(--button-text-color);
                padding: 5px;
                border-radius: 8px;
                height: auto;
            }
            #load-encounters-container label:hover {
                background-color: var(--button-bg-hover-color);
            }
            #load-encounters-container label:active {
                background-color: var(--button-bg-active-color);
            }

            button {
                padding: 5px;
                border-radius: 8px;
                color: var(--button-text-color);
                border: 0px;
                background-color: var(--button-bg-color);
            }
            button:hover {
                background-color: var(--button-bg-hover-color);
            }
            button:active {
                background-color: var(--button-bg-active-color);
            }
            button:disabled {
                background-color: var(--clr-surface-a50);
                /* opacity: 0.7; */
            }

            button.instance-action {
                background-color: var(--clr-surface-tonal-a0);
            }
            button.instance-action:hover {
                background-color: var(--clr-surface-tonal-a10);
            }
            button.instance-action:active {
                background-color: var(--clr-surface-tonal-a20);
            }
            button.instance-action:disabled {
                background-color: var(--clr-surface-tonal-a30);
                opacity: 0.7;
            }

            #encounter {
                margin: 10px;
            }

            .encounter-bar p {
                margin: 0px;
            }
            .encounter-bar > * {
                display: inline-block;
                margin-right: 10px;
            }

            .inactive {
                opacity: 0.3;
            }

            .adversary {
                position: relative; /* For action button */
                display: inline-block;
                vertical-align: top;
                /*
                    22em is empirical width needed to fit full ATK line for "Volcanic Dragon: Ashen Tyrant".
                    Longest ATK line in SRD is "Fallen Warlord: Undefeated Champion",
                    which requires 27em (at 22em, both ATK and Experience lines overflow).
                    27em feels way too wide. Trying 23em, which is enough to stop Fallen Warlord's
                    Experience line from overflowing.
                */
                width: 23em;
                border: 1px ridge var(--adversary-border-color);
                border-radius: 5px;
                margin-right: 5px;
                margin-top: 5px;
                padding: 5px 10px;
                background-color: var(--adversary-bg-color);
                color: var(--adversary-text-color);
            }
            .adversary h3 {
                margin: 8px 0px;
                color: var(--header-text-color);
            }
            #conditions-editor h3 {
                margin: 0px;
                margin-bottom: 10px;
                color: var(--header-text-color);
            }
            .adversary p {
                margin: 2px 0px;
            }
            .adversary .source {
                font-style: italic;
                font-size: smaller;
            }
            .adversary .tier {
                font-style: italic;
                font-weight: bold;
            }
            .adversary .description {
                font-size: smaller;
                font-style: italic;
            }
            .adversary .motives {
                font-size: smaller;
            }
            .adversary .stats {
                background-color: var(--stats-bg-color);
                border-top: 1px solid var(--clr-surface-a0);
                border-bottom: 1px solid var(--clr-surface-a0);
                padding: 5px;
            }
            .adversary .statLabel, .adversary .motivesLabel {
                font-weight: bold;
            }
            .adversary .experiences {
                border-top: 1px dotted var(--clr-surface-a50);
                margin-top: 2px;
                padding-top: 2px;
            }
            .adversary .divider {
                margin: 0px 3px;
                font-weight: bold;
            }
            .features {
                margin-left: 0.75em;
            }
            .featuresExpander summary {
                font-weight: bold;
            }
            .features .feature {
                text-indent: -0.75em
            }
            .featureLabel {
                font-style: italic;
                font-weight: bold;
            }

            .instance {
                position: relative; /* For action button */
                margin-top: 10px;
                background-color: var(--stats-bg-color);
                border-radius: 3px;
                padding: 5px;
            }
            .instance h4 {
                margin: 0px;
            }
            .add-conditions, .add-modifications {
                margin: 5px 0px;
            }

            .slots {
                display: inline-block
            }

            .conditions {
                margin-top: 5px
            }
            ul.conditions-list {
                list-style: none;
                display: inline;
                padding: 0px;
                font-size: smaller;
            }
            ul.conditions-list li {
                display: inline-block;
                background-color: var(--clr-surface-a40);
                border-radius: 3px;
                margin-right: 5px;
                margin-bottom: 5px;
                padding: 2px;
            }
            button.inline-delete {
                background-color: transparent;
                color: var(--clr-primary-a50);
                border: 0px;
                border-radius: 3px;
                padding: 0px;
                margin-left: 5px;
                font-size: smaller;
            }
            button.inline-delete:hover {
                background-color: var(--clr-primary-a30);
            }
            button.inline-delete:active {
                background-color: var(--clr-primary-a10);
            }

            button.inline-add {
                border: 0px;
                border-radius: 2px;
                padding: 3px 4px;
            }

            button.add-conditions-button {
                font-size: smaller;
            }

            button.action {
                float: right;
            }
            .top-actions {
                position: absolute;
                right: 5px;
                top: 5px;
            }
            .top-actions button {
                padding: 2px;
                margin-left: 3px;
                border-radius: 4px;
                font-size: smaller;
            }

            .actions-menu {
                position: absolute;
                right: 5px;
                top: 30px;
                margin: 0px;
                padding: 0px;
                list-style-type: none;
            }
            .actions-menu button {
                border-radius: 0px;
                width: 100%;
            }

            #editor-overlay {
                position: fixed;
                z-index: 1000; /* Ensure it is above other content */
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
            }
            .editor {
                position: absolute;
                z-index: 1001; /* Ensure it is above the overlay */
                width: 27em;
                top: 50px;
                left: 50%;
                transform: translateX(-50%);
                background-color: var(--clr-surface-tonal-a10);
                padding: 20px;
                border-radius: 10px;
                box-shadow: 10px 10px 10px black;
            }

            #browsing {
                background-color: var(--clr-surface-a10);
                position: relative;
                width: fit-content; /* TODO: Better to pick a width, table can resize like this */
                padding: 10px;
                border-radius: 10px;
                left: 50%;
                transform: translateX(-50%);
            }
            .results th, .results td {
                border: 1px solid var(--clr-surface-a0);
            }
            .results table {
                overflow-y: auto;
                width: 700px;
                /* max-width: 700px; */
                height: 15em;
                display: block;
                /* margin: 0 auto; */
            }
            .results td.nowrap {
                white-space: nowrap;
            }
            .results th, .results td {
                padding: 5px 10px;
                border-top-width: 0;
                border-left-width: 0;
            }
            .results th {
                position: sticky;
                top: 0;
                vertical-align: bottom;
                background: var(--clr-surface-a20); /* Need a background to avoid scrolled rows from showing through */
            }
        </style>
    </head>

    <body>
        <datalist id="srd-conditions">
            <option>Hidden</option>
            <option>Restrained</option>
            <option>Vulnerable</option>
            <option>Asleep</option>
            <option>Stunned</option>
            <option>Silenced</option>
            <option>Corroded</option>
            <option>Ranger's Focus</option>
            <option>Cloaked</option>
            <option>Dizzied</option>
            <option>Enveloped</option>
        </datalist>

        <datalist id="modifiable-properties">
            <option>difficulty</option>
            <option>majorThreshold</option>
            <option>severeThreshold</option>
        </datalist>

        <datalist id="srd-environment-types">
            <option>Event</option>
            <option>Exploration</option>
            <option>Social</option>
            <option>Traversal</option>
        </datalist>

        <div id="top-bar">
            <div class="top-bar-group">
                <select id="current-encounter">
                </select>
                <button id="edit-encounter" title="Edit Encounter">‚úèÔ∏è</button>
                <button id="delete-encounter" title="Delete Encounter">üóëÔ∏è</button>
                <!-- TODO: Separator-->
                <button id="add-encounter" title="Create New Encounter">‚ûï Create New Encounter</button>
            </div>
            <!-- TODO: Move these items to ... menu, and add import/export customs -->
            <div class="top-bar-group">
                <button id="save-encounters" title="Save Encounters">üíæ</button>
                <div id="load-encounters-container">
                    <label for="load-encounters" title="Load Encounters (replaces existing encounters)">üìÇ</label>
                    <input type="file" id="load-encounters" accept=".json" />
                </div>
            </div>
        </div>

        <div id="encounter"></div>

        <div id="editor-overlay" class="hidden"></div>
        <div id="encounter-editor" class="editor hidden">
            <form id="encounter-form">
                <label for="encounter-name">Name:</label>
                <input type="text" id="encounter-name" required />
                <br>
                <label for="encounter-tier">Tier:</label>
                <input type="number" id="encounter-tier" min="1" max="4" value="1" required />
                <label for="encounter-player-count">Player Count:</label>
                <input type="number" id="encounter-player-count" min="1" max="20" value="4" required />
                <br>
                <label for="encounter-target-battle-points">Target Battle Points:</label>
                <input type="number" id="encounter-target-battle-points" min="1" max="99" value="14" required />
                <span id="encounter-recommended-battle-points"></span>
                <p>When planning a battle, start with <strong>[(3 x the number of PCs in combat) + 2]</strong> Battle Points and make the following adjustments:</p>
                <ul>
                    <li><strong>-1</strong> for an easier or shorter fight</li>
                    <li><strong>-2</strong> if you're using 2 or more Solo adversaries</li>
                    <li><strong>-2</strong> if you add +1d4 (or a static +2) to all adversaries' damage rolls</li>
                    <li><strong>+1</strong> if you choose an adversary from a lower tier</li>
                    <li><strong>+1</strong> if you don't include any Bruisers, Hordes, Leaders, or Solos</li>
                    <li><strong>+2</strong> for a harder or longer fight</li>
                </ul>
                <button type="button" id="cancel-encounter-edit">Cancel</button>
                <button type="submit" id="save-encounter-edit">Save Encounter</button>
            </form>
        </div>
        <div id="adversary-editor" class="editor hidden">
            <form id="adversary-form">
                <fieldset>
                    <legend>Basics</legend>
                    <label for="adversary-name">Name:</label>
                    <input type="text" id="adversary-name" size="30" required />
                    <br>
                    <label for="adversary-tier">Tier:</label>
                    <input type="number" id="adversary-tier" min="1" max="4" value="1" required />
                    <span class="adversary-editor-adversary">
                        <label for="adversary-type">Type:</label>
                        <select id="adversary-type" list="srd-adversary-types">
                            <option>Bruiser</option>
                            <option>Horde</option>
                            <option>Leader</option>
                            <option>Minion</option>
                            <option>Ranged</option>
                            <option>Skulk</option>
                            <option>Social</option>
                            <option>Solo</option>
                            <option>Standard</option>
                            <option>Support</option>
                        </select>
                        <input type="number" id="adversary-count-per-hp" min="1" max="20" value="1" />
                        <label for="adversary-count-per-hp" id="adversary-count-per-hp-label">/HP</label>
                    </span>
                    <span class="adversary-editor-environment">
                        <label for="adversary-environment-type">Type:</label>
                        <input type="text" id="adversary-environment-type" list="srd-environment-types" />
                    </span>
                    <br>
                    <label for="adversary-description">Description:</label>
                    <textarea id="adversary-description" cols="30" rows="3"></textarea>
                    <div class="adversary-editor-adversary">
                        <label for="adversary-motives">Motives & Tactics:</label>
                        <textarea id="adversary-motives" cols="30" rows="2"></textarea>
                    </div>
                    <div class="adversary-editor-environment">
                        <label for="adversary-impulses">Impulses:</label>
                        <textarea id="adversary-impulses" cols="30" rows="2"></textarea>
                    </div>
                </fieldset>
                <fieldset>
                    <legend>Stats</legend>
                    <label for="adversary-difficulty">Difficulty:</label>
                    <input type="number" id="adversary-difficulty" min="0" max="40" value="12" required />
                    <div class="adversary-editor-adversary">
                        <label for="adversary-major-threshold">Major Threshold:</label>
                        <input type="number" id="adversary-major-threshold" min="0" max="20" value="8" />
                        /
                        <label for="adversary-severe-threshold">Severe Threshold:</label>
                        <input type="number" id="adversary-severe-threshold" min="0" max="20" value="14" />
                        <br>
                        <label for="adversary-hp">HP:</label>
                        <input type="number" id="adversary-hp" min="1" max="40" value="5" />
                        <label for="adversary-stress">Stress:</label>
                        <input type="number" id="adversary-stress" min="0" max="40" value="2" />
                        <br>
                        <label for="adversary-experience">Experience:</label>
                        <input type="text" id="adversary-experience" />
                    </div>
                    <div class="adversary-editor-environment">
                        <label for="adversary-potential-adversaries">Potential Adversaries:</label>
                        <textarea id="adversary-potential-adversaries" cols="30" rows="3"></textarea>
                    </div>
                </fieldset>
                <fieldset class="adversary-editor-adversary">
                    <legend>Attack</legend>
                    <label for="adversary-attack-modifier">Modifier:</label>
                    <input type="text" id="adversary-attack-modifier" size="4" placeholder="e.g. +3" />
                    <label for="adversary-attack-description">Description:</label>
                    <input type="text" id="adversary-attack-description" placeholder="e.g. Mace" />
                    <br>
                    <label for="adversary-attack-range">Range:</label>
                    <select id="adversary-attack-range">
                        <option>Melee</option>
                        <option>Very Close</option>
                        <option>Close</option>
                        <option>Far</option>
                    </select>
                    <label for="adversary-attack-damage">Damage:</label>
                    <input type="text" id="adversary-attack-damage" size="12" placeholder="e.g. 1d10+3 phy" />
                </fieldset>
                <fieldset>
                    <legend>Features</legend>
                    <button id="add-feature">+ Add Feature</button>
                    <div id="adversary-features"></div>
                </fieldset>
                <button type="button" id="cancel-adversary-edit">Cancel</button>
                <button type="submit" id="save-adversary-edit">Save</button>
            </form>
        </div>
        <div id="conditions-editor" class="editor hidden"> <!-- TODO: Position over adversary instead? -->
            <h3 class="instance-name"></h3>
            <div class="conditions"></div>
            <div class="add-conditions">
                <input type="text" placeholder="Condition Name" list="srd-conditions" id="condition-name">
                <button class="inline-add" title="Add condition" id="add-condition">+</button>
            </div>
            <div class="add-modifications">
                <input type="text" placeholder="Modification Name" id="modification-name">
                <input type="text" placeholder="Target Property" list="modifiable-properties" id="modification-property">
                <input type="text" placeholder="Modifier (e.g. -2, +3, 10)" id="modification-value">
                <button class="inline-add" title="Add modification" id="add-modification">+</button>
            </div>
            <button id="done-adding-conditions">Done</button>
        </div>

        <div id="browsing">
            <!-- TODO: Allow keyboard navigation of table and adding of adversaries directly from search input?-->
            <input id="browsing-search" type="text" placeholder="Search" />
            <select id="browsing-source">
                <option>Any source</option>
                <option>SRD</option>
                <option>Custom</option>
            </select>
            <select id="browsing-tier">
                <option value="">Any tier</option>
                <option value="1">Tier 1</option>
                <option value="2">Tier 2</option>
                <option value="3">Tier 3</option>
                <option value="4">Tier 4</option>
            </select>
            <select id="browsing-category">
                <option>Any category</option>
                <option value="Adversary">Adversaries</option>
                <option value="Environment">Environments</option>
            </select>
            <select id="browsing-type">
                <option>Any type</option>
                <option>Bruiser</option>
                <option>Horde</option>
                <option>Leader</option>
                <option>Minion</option>
                <option>Ranged</option>
                <option>Skulk</option>
                <option>Social</option>
                <option>Solo</option>
                <option>Standard</option>
                <option>Support</option>
            </select>
            <button id="browsing-reset-filters">Reset</button>
            <div class="results">
                <table>
                    <thead>
                        <tr>
                            <th scope="col"></th>
                            <th scope="col">Name</th>
                            <th scope="col">Type</th>
                            <th scope="col">Description</th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div>
        </div>

        <div id="repo-info">
            <p><em>Now Fear This</em> is free and open source and works entirely offline. Please <a href="https://github.com/sandyarmstrong/nowfearthis/issues">report any bugs or feature requests</a>.</p>
        </div>

        <div id="copyright">
            <p>This project includes materials from the Daggerheart System Reference Document 1.0,
                ¬© Critical Role, LLC. under the terms of the Darrington Press Community Gaming (DPCGL) License.
                More information can be found at <a href="https://www.daggerheart.com">https://www.daggerheart.com</a>.
                Minor formatting modifications were provided as part of the excellent
                <a href="https://github.com/seansbox/daggerheart-srd">https://github.com/seansbox/daggerheart-srd</a>.</p>
            <p>Site favicon courtesy of <a href="https://github.com/twitter/twemoji/blob/master/LICENSE-GRAPHICS">twemoji</a>.</p>
        </div>
    </body>

    <script>
        // TODO: Change all code that puts user data directly into innerHTML

        const adversaryRemovedEvent = new Event("adversaryRemoved");
        const adversaryCopiedEvent = new Event("adversaryCopied");
        const adversaryCopiedFromSourceEvent = new Event("adversaryCopiedFromSource");
        const adversarySavedToCustomEvent = new Event("adversarySavedToCustom");
        const adversaryDeletedFromCustomEvent = new Event("adversaryDeletedFromCustom");

        const editorOverlay = document.getElementById("editor-overlay");
        const encounterEditor = document.getElementById("encounter-editor");
        const adversaryEditor = document.getElementById("adversary-editor");
        const conditionsEditor = document.getElementById("conditions-editor");

        let expandAllFeatures = false;

        document.getElementById("editor-overlay").addEventListener("click", function() {
            if (!adversaryEditor.classList.contains("hidden")) {
                hideAdversaryEditor();
            } else if (!encounterEditor.classList.contains("hidden")) {
                hideEncounterEditor();
            } else if (!conditionsEditor.classList.contains("hidden")) {
                hideConditionsEditor();
            }
        });

        function hideAdversaryEditor() {
            const adversary = adversaryEditor.adversary;
            adversaryEditor.adversary = undefined;
            adversaryEditor.classList.add("hidden");
            editorOverlay.classList.add("hidden");
            if (adversary) {
                const adversaryElements = Array.from(document.querySelectorAll(".adversary"));
                for (let i = 0; i < adversaryElements.length; i++) {
                    if (adversaryElements[i].adversary == adversary) {
                        adversaryElements[i].scrollIntoView({ behavior: "instant", block: "center" });
                    }
                }
            }
        }

        adversaryEditor.addEventListener("keyup", function(event) {
            if (event.keyCode === 27) { // Escape key
                hideAdversaryEditor();
            }
        });

        function createFeatureEditorElement(feature, idSuffix)  {
            const featureElement = document.createElement("div");
            featureElement.className = "feature";
            featureElement.innerHTML = `<label for="adversary-feature-name-${idSuffix}">Name:</label><input type="text" class="adversary-feature-name" id="adversary-feature-name-${idSuffix}" value="${feature?.name ?? ""}" size="30"><label for="adversary-feature-text-${idSuffix}"><br>Description:</label><textarea id="adversary-feature-text-${idSuffix}" class="adversary-feature-text" rows="4" cols="50">${feature?.text ?? ""}</textarea>`;
            return featureElement;
        }

        function refreshCounterPerHpDisplay() {
            const countPerHpInput = adversaryEditor.querySelector("#adversary-count-per-hp");
            if (adversaryEditor.querySelector("#adversary-type").value === "Horde") {
                countPerHpInput.classList.remove("hidden");
                adversaryEditor.querySelector("#adversary-count-per-hp-label").classList.remove("hidden");
            } else {
                countPerHpInput.classList.add("hidden");
                adversaryEditor.querySelector("#adversary-count-per-hp-label").classList.add("hidden");
                adversaryEditor.querySelector("#adversary-count-per-hp").value = 1;
            }
        }

        adversaryEditor.querySelector("#adversary-type").addEventListener("change", function() {
            refreshCounterPerHpDisplay();
        });

        function showAdversaryEditor(adversary) {
            // Basics
            adversaryEditor.querySelector("#adversary-name").value = adversary.name;
            adversaryEditor.querySelector("#adversary-tier").value = adversary.tier;
            adversaryEditor.querySelector("#adversary-description").value = adversary.description || "";
            adversaryEditor.querySelector("#adversary-motives").value = adversary.motivesAndTactics || "";
            adversaryEditor.querySelector("#adversary-impulses").value = adversary.impulses || "";

            if (adversary.category == "Adversary") {
                adversaryEditor.querySelector("#adversary-type").value = adversary.type;
                adversaryEditor.querySelectorAll(".adversary-editor-adversary").forEach(function(element) {
                    element.classList.remove("hidden");
                });
                adversaryEditor.querySelectorAll(".adversary-editor-environment").forEach(function(element) {
                    element.classList.add("hidden");
                });
            } else if (adversary.category == "Environment") {
                adversaryEditor.querySelector("#adversary-environment-type").value = adversary.type;
                adversaryEditor.querySelectorAll(".adversary-editor-adversary").forEach(function(element) {
                    element.classList.add("hidden");
                });
                adversaryEditor.querySelectorAll(".adversary-editor-environment").forEach(function(element) {
                    element.classList.remove("hidden");
                });
            }

            adversaryEditor.querySelector("#adversary-count-per-hp").value = adversary.countPerHp || 1;
            refreshCounterPerHpDisplay();

            // Stats
            adversaryEditor.querySelector("#adversary-difficulty").value = adversary.difficulty;
            adversaryEditor.querySelector("#adversary-major-threshold").value = adversary.majorThreshold;
            adversaryEditor.querySelector("#adversary-severe-threshold").value = adversary.severeThreshold;
            adversaryEditor.querySelector("#adversary-hp").value = adversary.hp;
            adversaryEditor.querySelector("#adversary-stress").value = adversary.stress;
            adversaryEditor.querySelector("#adversary-experience").value = adversary.experience || "";
            adversaryEditor.querySelector("#adversary-potential-adversaries").value = adversary.potentialAdversaries || "";

            // Attack
            adversaryEditor.querySelector("#adversary-attack-modifier").value = adversary.attackModifier || "";
            adversaryEditor.querySelector("#adversary-attack-description").value = adversary.attackDescription || "";
            adversaryEditor.querySelector("#adversary-attack-range").value = adversary.attackRange || ""; // TODO: Case mangling as needed
            adversaryEditor.querySelector("#adversary-attack-damage").value = adversary.attackDamage || "";

            // Features
            const featuresContainer = adversaryEditor.querySelector("#adversary-features");
            featuresContainer.innerHTML = ""; // Clear any existing children
            if (adversary.features && adversary.features.length > 0) {
                for (let i = 0; i < adversary.features.length; i++) {
                    const feature = adversary.features[i];
                    const featureElement = createFeatureEditorElement(feature, i);
                    featuresContainer.appendChild(featureElement);
                }
            }

            editorOverlay.classList.remove("hidden");
            adversaryEditor.classList.remove("hidden");
            adversaryEditor.adversary = adversary;
            adversaryEditor.querySelector("#adversary-name").select();
            window.scrollTo(0, 0);
        }

        document.querySelector("#add-feature").addEventListener("click", function() {
            const featureContainer = adversaryEditor.querySelector("#adversary-features");
            const featureElement = createFeatureEditorElement(null, featureContainer.children.length);
            featureContainer.appendChild(featureElement);
            // TODO: Allow deletion (but could also do this by deleting all text for a feature)
        });

        document.querySelector("#cancel-adversary-edit").addEventListener("click", function() {
            hideAdversaryEditor();
        });

        document.querySelector("#adversary-form").addEventListener("submit", function(event) {
            event.preventDefault(); // Prevent page refresh

            const adversary = adversaryEditor.adversary;
            if (adversary) {
                // TODO: Don't set optional fields if empty?

                // Basics
                adversary.name = adversaryEditor.querySelector("#adversary-name").value.trim();
                adversary.tier = parseInt(adversaryEditor.querySelector("#adversary-tier").value);
                adversary.description = adversaryEditor.querySelector("#adversary-description").value.trim();
                adversary.difficulty = parseInt(adversaryEditor.querySelector("#adversary-difficulty").value);

                if (adversary.category == "Adversary") {
                    adversary.countPerHp = parseInt(adversaryEditor.querySelector("#adversary-count-per-hp").value);
                    adversary.type = adversaryEditor.querySelector("#adversary-type").value;
                    adversary.motivesAndTactics = adversaryEditor.querySelector("#adversary-motives").value.trim();

                    // Stats
                    adversary.majorThreshold = parseInt(adversaryEditor.querySelector("#adversary-major-threshold").value);
                    adversary.severeThreshold = parseInt(adversaryEditor.querySelector("#adversary-severe-threshold").value);
                    adversary.hp = parseInt(adversaryEditor.querySelector("#adversary-hp").value);
                    if (adversary.instances) {
                        adversary.instances.forEach(function(instance) {
                            instance.hpMarked = Math.min(instance.hpMarked, adversary.hp);
                        });
                    }
                    adversary.stress = parseInt(adversaryEditor.querySelector("#adversary-stress").value);
                    if (adversary.instances) {
                        adversary.instances.forEach(function(instance) {
                            instance.stressMarked = Math.min(instance.stressMarked, adversary.stress);
                        });
                    }
                    adversary.experience = adversaryEditor.querySelector("#adversary-experience").value.trim();

                    // Attack
                    adversary.attackModifier = adversaryEditor.querySelector("#adversary-attack-modifier").value.trim();
                    adversary.attackDescription = adversaryEditor.querySelector("#adversary-attack-description").value.trim();
                    adversary.attackRange = adversaryEditor.querySelector("#adversary-attack-range").value;
                    adversary.attackDamage = adversaryEditor.querySelector("#adversary-attack-damage").value.trim();
                } else if (adversary.category == "Environment") {
                    adversary.type = adversaryEditor.querySelector("#adversary-environment-type").value;
                    adversary.impulses = adversaryEditor.querySelector("#adversary-impulses").value;
                    adversary.potentialAdversaries = adversaryEditor.querySelector("#adversary-potential-adversaries").value;
                }

                // Features
                adversary.features = [];
                const featureElements = adversaryEditor.querySelectorAll("#adversary-features .feature");
                featureElements.forEach(function(featureElement) {
                    const feature = {
                        name: featureElement.querySelector(".adversary-feature-name").value.trim(),
                        text: featureElement.querySelector(".adversary-feature-text").value.trim()
                    };
                    if (feature.name || feature.text) { // TODO: Require both?
                        adversary.features.push(feature);
                    }
                });
            }

            saveState();
            refreshDisplay();
            hideAdversaryEditor();
        });

        function showConditionsEditor(instance) {
            conditionsEditor.instance = instance;
            conditionsEditor.classList.remove("hidden");
            editorOverlay.classList.remove("hidden");

            conditionsEditor.querySelector(".instance-name").innerText = instance.name;
            updateConditionsDisplay(conditionsEditor.querySelector(".conditions"), instance, false);

            conditionsEditor.querySelector("#condition-name").select();
            window.scrollTo(0, 0);
        }

        function hideConditionsEditor() {
            const instance = conditionsEditor.instance;
            conditionsEditor.instance = undefined;
            conditionsEditor.classList.add("hidden");
            editorOverlay.classList.add("hidden");

            refreshDisplay(); // TODO: A more efficient way to update just the conditions div, maybe a callback?

            if (instance) {
                const instanceElements = Array.from(document.querySelectorAll(".instance"));
                for (let i = 0; i < instanceElements.length; i++) {
                    if (instanceElements[i].instance == instance) {
                        instanceElements[i].scrollIntoView({ behavior: "instant", block: "center" });
                    }
                }
            }
        }

        conditionsEditor.addEventListener("keyup", function(event) {
            if (event.keyCode === 27) { // Escape key
                hideConditionsEditor();
            }
        });

        document.querySelector("#done-adding-conditions").addEventListener("click", function(event) {
            hideConditionsEditor();
        });

        document.querySelector("#add-condition").addEventListener("click", function(event) {
            const instance = conditionsEditor.instance;
            if (!instance) {
                return;
            }

            const addConditionInput = conditionsEditor.querySelector("#condition-name");
            const conditionsDiv = conditionsEditor.querySelector(".conditions");

            const condition = addConditionInput.value.trim();
            if (condition && (!instance.conditions || !instance.conditions.includes(condition))) {
                if (!instance.conditions) {
                    instance.conditions = [];
                }
                instance.conditions.push(condition);
                addConditionInput.value = "";
                saveState();
                updateConditionsDisplay(conditionsDiv, instance, false);
            }
        });

        document.querySelector("#condition-name").addEventListener("keyup", function(event) {
            if (event.keyCode === 13) { // Enter key
                event.preventDefault();
                document.querySelector("#add-condition").click();
            }
        });

        document.querySelector("#add-modification").addEventListener("click", function(evenet) {
            const instance = conditionsEditor.instance;
            if (!instance) {
                return;
            }

            const addModificationNameInput = conditionsEditor.querySelector("#modification-name");
            const addModificationPropertyInput = conditionsEditor.querySelector("#modification-property");
            const addModificationValueInput = conditionsEditor.querySelector("#modification-value");
            const conditionsDiv = conditionsEditor.querySelector(".conditions");

            const modificationName = addModificationNameInput.value.trim();
            const propertyName = addModificationPropertyInput.value.trim();
            const modificationValue = addModificationValueInput.value.trim();
            if (modificationName && propertyName && modificationValue) {
                if (!instance.modifications) {
                    instance.modifications = [];
                }
                instance.modifications.push({
                    modificationName: modificationName,
                    propertyName: propertyName,
                    modification: modificationValue
                });
                addModificationNameInput.value = "";
                addModificationPropertyInput.value = "";
                addModificationValueInput.value = "";
                saveState();
                updateConditionsDisplay(conditionsDiv, instance, false);
            }
        });

        function hideEncounterEditor() {
            encounterEditor.classList.add("hidden");
            editorOverlay.classList.add("hidden");
        }

        encounterEditor.addEventListener("keyup", function(event) {
            if (event.keyCode === 27) { // Escape key
                hideEncounterEditor();
            }
        });

        function updateEditorBattlePointsRecommendation() {
            const playerCount = parseInt(document.querySelector("#encounter-player-count").value);
            const recommendedBattlePoints = (3 * playerCount) + 2;
            document.querySelector("#encounter-recommended-battle-points").innerText = `(Base recommendation: ${recommendedBattlePoints})`;
        }

        function showEncounterEditor(encounter) {
            if (!encounter) {
                encounter = {
                    name: "New Encounter",
                    playerTier: 1,
                    playerCount: 4,
                    targetBattlePoints: 14, // TODO: Automatically adjust when playerCount changes?
                };
                encounterEditor.encounter = null;
            } else {
                encounterEditor.encounter = encounter;
            }

            encounterEditor.querySelector("#encounter-name").value = encounter.name;
            encounterEditor.querySelector("#encounter-tier").value = encounter.playerTier ?? 1;
            encounterEditor.querySelector("#encounter-player-count").value = encounter.playerCount ?? 4;
            encounterEditor.querySelector("#encounter-target-battle-points").value = encounter.targetBattlePoints ?? 14;

            updateEditorBattlePointsRecommendation();

            editorOverlay.classList.remove("hidden");
            encounterEditor.classList.remove("hidden");
            encounterEditor.querySelector("#encounter-name").select();
            window.scrollTo(0, 0);
        }

        document.querySelector("#encounter-form").addEventListener("submit", function(event) {
            event.preventDefault(); // Prevent page refresh

            let encounter = encounterEditor.encounter;
            if (!encounter) {
                if (!state.encounters) {
                    state.encounters = [];
                }
                encounter = {}
                state.encounters.push(encounter);
                selectedEncounterIndex = state.encounters.length - 1;
            }

            encounter.name = encounterEditor.querySelector("#encounter-name").value.trim();
            encounter.playerTier = parseInt(encounterEditor.querySelector("#encounter-tier").value);
            encounter.playerCount = parseInt(encounterEditor.querySelector("#encounter-player-count").value);
            encounter.targetBattlePoints = parseInt(encounterEditor.querySelector("#encounter-target-battle-points").value);

            saveState();
            refreshDisplay();
            hideEncounterEditor();

            updateBrowsingTier();
        });

        document.querySelector("#cancel-encounter-edit").addEventListener("click", function() {
            hideEncounterEditor();
        });

        document.querySelector("#add-encounter").addEventListener("click", function() {
            showEncounterEditor();
        });

        document.querySelector("#edit-encounter").addEventListener("click", function() {
            const encounter = state.encounters[selectedEncounterIndex];
            showEncounterEditor(encounter);
        });

        document.querySelector("#delete-encounter").addEventListener("click", function() {
            if (state.encounters && state.encounters.length > 0) {
                state.encounters.splice(selectedEncounterIndex, 1);
                selectedEncounterIndex = Math.min(selectedEncounterIndex, state.encounters.length - 1);
                saveState();
                if (state.encounters.length === 0) {
                    showEncounterEditor();
                }
                refreshDisplay();
            }
        });

        document.querySelector("#encounter-player-count").addEventListener("change", function() {
            updateEditorBattlePointsRecommendation();
        });

        // TODO: This is annoying if you are scrolled down, and every adversary above changes expansion,
        //       messing with your scroll position. Fix scroll position or just don't do this.
        function handleFeaturesToggle(event) {
            const opened = event.target.open;
            if (expandAllFeatures != opened) {
                expandAllFeatures = opened;
                for (const element of document.getElementsByClassName("featuresExpander")) {
                    if (element.open != expandAllFeatures) {
                        element.open = expandAllFeatures;
                    }
                }
            }
        }

        function adversaryMatchesSearch(adversary, searchText) {
            if (!searchText) {
                return true;
            }

            const adversaryName = adversary.name.toLowerCase();
            const adversaryDescription = adversary.description.toLowerCase();
            const adversaryType = adversary.type.toLowerCase();

            // All terms must match somewhere
            const terms = searchText.toLowerCase().split(/\s+/);
            for (const term of terms) {
                if (!term) {
                    continue; // Skip empty terms
                }
                if (!(adversaryName.includes(term) ||
                    adversaryDescription.includes(term) ||
                    adversaryType.includes(term))) {
                    return false;
                }
            }

            return true;
        }

        function updateBrowsingTier() {
            if (state.encounters && selectedEncounterIndex < state.encounters.length) {
                // Update the tier dropdown based on the current encounter
                document.querySelector("#browsing-tier").value = state.encounters[selectedEncounterIndex].playerTier || "";
            }
        }

        function updateBrowsingTableFiltering() {
            const selectedSource = document.querySelector("#browsing-source").value;
            const selectedTier = parseInt(document.querySelector("#browsing-tier").value) || "Any tier";
            const selectedCategory = document.querySelector("#browsing-category").value;
            const selectedType = document.querySelector("#browsing-type").value;
            const searchText = document.querySelector("#browsing-search").value;

            const rows = browsingTableBody.querySelectorAll("tr");
            rows.forEach(function(row) {
                if ((selectedSource == "Any source" || row.adversary.source == selectedSource) &&
                    (selectedTier == "Any tier" || row.adversary.tier == selectedTier) &&
                    (selectedCategory == "Any category" || row.adversary.category == selectedCategory) &&
                    (selectedType == "Any type" || row.adversary.type == selectedType) &&
                    (!searchText || adversaryMatchesSearch(row.adversary, searchText))) {
                    row.style.display = "";
                } else {
                    row.style.display = "none";
                }
            });
        }

        document.querySelector("#browsing-search").addEventListener("input", function(event) {
            updateBrowsingTableFiltering();
        });
        document.querySelector("#browsing-source").addEventListener("change", function(event) {
            updateBrowsingTableFiltering();
        });
        document.querySelector("#browsing-tier").addEventListener("change", function(event) {
            updateBrowsingTableFiltering();
        });
        document.querySelector("#browsing-type").addEventListener("change", function(event) {
            updateBrowsingTableFiltering();
        });
        document.querySelector("#browsing-category").addEventListener("change", function(event) {
            updateBrowsingTableFiltering();
        });
        document.querySelector("#browsing-reset-filters").addEventListener("click", function(event) {
            document.querySelector("#browsing-search").value = "";
            document.querySelector("#browsing-source").value = "Any source";
            document.querySelector("#browsing-tier").value = "";
            document.querySelector("#browsing-category").value = "Any category";
            document.querySelector("#browsing-type").value = "Any type";
            updateBrowsingTableFiltering();
        });

        function createFearTracker(encounter) {
            const maxFear = 12;
            // TODO: Nice simple rich tooltip guide: https://jsfiddle.net/8nnwytbL/
            // TODO: Roller for getting fear on rests?
            // TODO: Replace this with a stylized number input?
            const fearDiv = document.createElement("div");
            const fearValue = document.createElement("span");
            const useFearButton = document.createElement("button");
            const gainFearButton = document.createElement("button");

            if (encounter.currentFear === undefined) {
                encounter.currentFear = 0;
            }

            function updateFearDisplay() {
                fearValue.innerHTML = "";
                fearValue.title = `${encounter.currentFear} Fear | Start: {number of PCs} | Short rest: 1d4 | Long rest: 1d4 + {number of PCs}`;

                for (let i = 0; i < maxFear; i++) {
                    const fearIcon = document.createElement("span");
                    fearIcon.className = "fear-icon";
                    if (i >= encounter.currentFear) {
                        fearIcon.classList.add("inactive");
                    }
                    fearIcon.innerText = "üíÄ";
                    fearValue.appendChild(fearIcon);
                }

                useFearButton.disabled = encounter.currentFear <= 0;
                gainFearButton.disabled = encounter.currentFear >= maxFear;
            }
            updateFearDisplay();

            useFearButton.innerText = "-";
            useFearButton.title = "Use 1 Fear";
            useFearButton.onclick = function() {
                if (encounter.currentFear > 0) {
                    encounter.currentFear--;
                    updateFearDisplay();
                    saveState();
                }
            };

            gainFearButton.innerText = "+";
            gainFearButton.title = "Gain 1 Fear (max 12)";
            gainFearButton.onclick = function() {
                if (encounter.currentFear < maxFear) {
                    encounter.currentFear++;
                    updateFearDisplay();
                    saveState();
                }
            };

            fearDiv.appendChild(useFearButton);
            fearDiv.appendChild(fearValue);
            fearDiv.appendChild(gainFearButton);

            return fearDiv;
        }

        function refreshBattlePoints() {
            const encounter = state.encounters[selectedEncounterIndex];
            const battlePointsDiv = document.querySelector("#battle-points");
            const currentBattlePoints = calculateBattlePoints(encounter);

            // Round to nearest 0.1 for display
            const remainingBattlePoints = Math.round((encounter.targetBattlePoints - currentBattlePoints) * 10) / 10;

            if (remainingBattlePoints < 0) {
                battlePointsDiv.querySelector("[name='current-battle-points']").innerText = `‚ö†Ô∏è ${Math.abs(remainingBattlePoints)}`;
                battlePointsDiv.querySelector("[name='remaining-suffix']").innerText = "over";
            } else {
                battlePointsDiv.querySelector("[name='current-battle-points']").innerText = Math.abs(remainingBattlePoints);
                battlePointsDiv.querySelector("[name='remaining-suffix']").innerText = "left";
            }
        }

        function addAdversaryToSearch(adversary) {
            // Datalist for basic search
            const option = document.createElement("option");
            option.adversary = adversary;
            option.value = adversary.name;
            adversaryDatalist.appendChild(option);

            // Table for browsing
            const tr = document.createElement("tr");
            tr.adversary = adversary;
            browsingTableBody.appendChild(tr);

            const addButtonTD = document.createElement("td");
            addButtonTD.className = "nowrap";
            const addButton = document.createElement("button");
            addButton.innerText = "‚ûï Add";
            addButton.addEventListener("click", function(event) {
                const adversaryCopy = JSON.parse(JSON.stringify(tr.adversary));
                if (adversaryCopy.category == "Adversary" && (!adversaryCopy.instances || adversaryCopy.instances.length == 0)) {
                    adversaryCopy.instances = [
                        {
                            name: adversaryCopy.name + " #1",
                            hpMarked: 0,
                            stressMarked: 0
                        }
                    ];
                }
                const encounter = state.encounters[selectedEncounterIndex];
                // TODO: What if there is no encounter?
                if (!encounter.adversaries) {
                    encounter.adversaries = [];
                }
                encounter.adversaries.push(adversaryCopy);
                addAdversary(
                    document.querySelector("#encounter .adversaries"),
                    encounter,
                    adversaryCopy,
                    refreshBattlePoints);
                saveState();
            });
            addButtonTD.appendChild(addButton);
            tr.appendChild(addButtonTD);

            const nameTD = document.createElement("td");
            nameTD.innerText = adversary.name;
            tr.appendChild(nameTD);

            // TODO: Could add pts, but we'd have to recalc when player count changes
            // const encounter = state.encounters[selectedEncounterIndex];
            // const battlePoints = getStatBlockBattlePoints(adversary.type, encounter?.playerCount ?? 1);
            const typeTD = document.createElement("td");
            typeTD.className = "nowrap";
            // typeTD.innerText = `${adversary.type} (${battlePoints} pts)`;
            typeTD.innerText = adversary.type;
            tr.appendChild(typeTD);

            const descriptionTD = document.createElement("td");
            descriptionTD.innerText = adversary.description;
            tr.appendChild(descriptionTD);
        }

        function updateResource(container, adversary, adversarySlotsPropertyName, instance, instanceMarkedPropertyName) {
            const elements = [];
            const slots = adversary[adversarySlotsPropertyName];
            const marked = instance[instanceMarkedPropertyName];

            // TODO: Reduce opacity or something when HP is fully marked?
            //       - Would also need to do it on initial/refresh layout
            //       - Would also need to differentiate between HP and Stress
            // TODO: Add "Vulnerable (stress full)" condition when stress is fully marked?
            //       Would have to make sure it couldn't be deleted otherwise though.

            for (let i = 0; i < slots; i++) {
                const slot = document.createElement("input");
                slot.type = "checkbox";
                if (i < marked) {
                    slot.checked = true;
                }
                slot.onclick = function(event) {
                    if (event.target.checked) {
                        instance[instanceMarkedPropertyName]++;
                    } else {
                        instance[instanceMarkedPropertyName]--;
                    }
                    saveState();
                    updateResource(container, adversary, adversarySlotsPropertyName, instance, instanceMarkedPropertyName);
                };
                elements.push(slot);
            }

            container.replaceChildren(...elements);
        }

        function setupAdversaryActionButton(adversaryElement, adversary) {
            const actionsMenu = document.createElement("menu");
            actionsMenu.className = "actions-menu";

            const copyAction = document.createElement("li");
            copyAction.innerHTML = `<button class="menu-action">Duplicate</button>`;
            copyAction.title = "Copy this adversary, including all changed state";
            copyAction.onclick = function() {
                adversaryElement.dispatchEvent(adversaryCopiedEvent);
                actionsMenu.remove();
            };
            actionsMenu.appendChild(copyAction);

            const copyFromSourceAction = document.createElement("li");
            copyFromSourceAction.innerHTML = `<button class="menu-action">Copy From Source</button>`;
            copyFromSourceAction.title = "Copy this adversary from the source, ignoring all changes";
            copyFromSourceAction.onclick = function() {
                adversaryElement.dispatchEvent(adversaryCopiedFromSourceEvent);
                actionsMenu.remove();
            };
            actionsMenu.appendChild(copyFromSourceAction);

            const saveCustomAction = document.createElement("li");
            // TODO: Disable when no changes have been made?
            saveCustomAction.innerHTML = `<button class="menu-action">Save to Custom Adversaries</button>`;
            saveCustomAction.title = "Save this adversary to your custom adversaries for later use";
            saveCustomAction.onclick = function() {
                adversaryElement.dispatchEvent(adversarySavedToCustomEvent);
                actionsMenu.remove();
            };
            actionsMenu.appendChild(saveCustomAction);

            const deleteCustomAction = document.createElement("li");
            deleteCustomAction.innerHTML = `<button class="menu-action" ${adversary.source == 'Custom' ? '' : 'disabled'}>Delete from Custom Adversaries</button>`;
            deleteCustomAction.title = "Delete from your custom adversaries";
            deleteCustomAction.onclick = function() {
                adversaryElement.dispatchEvent(adversaryDeletedFromCustomEvent);
                actionsMenu.remove();
            };
            actionsMenu.appendChild(deleteCustomAction);

            const topActions = document.createElement("div");
            topActions.className = "top-actions";
            adversaryElement.appendChild(topActions);

            if (adversary.category == "Adversary") {
                const addInstanceButton = document.createElement("button");
                addInstanceButton.innerText = "‚ûï";
                addInstanceButton.title = "Add another instance of this adversary";
                addInstanceButton.onclick = function() {
                    const newInstance = {
                        // TODO: Review naming, this doesn't work well if you add several, delete several, add again.
                        //       May need to parse the names to find the largest, like we do for adversary display names.
                        name: adversary.name + " #" + (adversary.instances.length + 1),
                        hpMarked: 0,
                        stressMarked: 0
                    };
                    if (!adversary.instances) {
                        adversary.instances = [];
                    }
                    adversary.instances.push(newInstance);
                    saveState();
                    refreshDisplay();
                };
                topActions.appendChild(addInstanceButton);
            }

            const editButton = document.createElement("button");
            editButton.innerText = "‚úèÔ∏è";
            editButton.title = "Edit this adversary";
            editButton.onclick = function() {
                showAdversaryEditor(adversary);
            };
            topActions.appendChild(editButton);

            const deleteButton = document.createElement("button");
            deleteButton.innerText = "üóëÔ∏è";
            deleteButton.title = "Remove this adversary from the encounter";
            deleteButton.onclick = function() {
                adversaryElement.dispatchEvent(adversaryRemovedEvent);
            };
            topActions.appendChild(deleteButton);

            const actionsButton = document.createElement("button");
            actionsButton.innerText = "üé≠";
            actionsButton.title = "Adversary management actions";
            actionsButton.onclick = function() {
                if (actionsMenu.parentElement) {
                    actionsMenu.remove();
                } else {
                    adversaryElement.appendChild(actionsMenu);
                }
            };
            topActions.appendChild(actionsButton);
        }

        function updateConditionsDisplay(container, instance, showAddButton) {
            container.innerHTML = "";

            const conditionsList = document.createElement("ul");
            conditionsList.className = "conditions-list";
            container.appendChild(conditionsList);

            if (instance.conditions && instance.conditions.length > 0) {
                for (let i = 0; i < instance.conditions.length; i++) {
                    const condition = instance.conditions[i];

                    const conditionItem = document.createElement("li");
                    conditionsList.appendChild(conditionItem);

                    const conditionText = document.createElement("span");
                    conditionText.innerText = condition;
                    conditionItem.appendChild(conditionText);

                    const removeButton = document.createElement("button");
                    removeButton.className = "inline-delete";
                    removeButton.innerText = "‚ùå";
                    removeButton.title = "Remove condition";
                    removeButton.onclick = function(event) {
                        instance.conditions = instance.conditions.filter(function(c) {
                            return c !== condition;
                        });
                        updateConditionsDisplay(container, instance, showAddButton);
                        saveState();
                    };
                    conditionItem.appendChild(removeButton);
                }
            }

            if (instance.modifications && instance.modifications.length > 0) {
                for (let i = 0; i < instance.modifications.length; i++) {
                    const modification = instance.modifications[i];

                    const modificationItem = document.createElement("li");
                    conditionsList.appendChild(modificationItem);

                    const modificationText = document.createElement("span");
                    modificationText.innerText = `${modification.modificationName} (${modification.propertyName} ${modification.modification})`;
                    modificationItem.appendChild(modificationText);

                    const removeButton = document.createElement("button");
                    removeButton.className = "inline-delete";
                    removeButton.innerText = "‚ùå";
                    removeButton.title = "Remove modification";
                    removeButton.onclick = function(event) {
                        instance.modifications = instance.modifications.filter(function(m) {
                            return m !== modification;
                        });
                        updateConditionsDisplay(container, instance, showAddButton);
                        saveState();
                    };
                    modificationItem.appendChild(removeButton);
                }
            }

            if (showAddButton) {
                const editConditions = document.createElement("button");
                editConditions.className = "add-conditions-button"
                editConditions.innerText = "Add Conditions";
                editConditions.title = "Add conditions or modifications to this adversary instance";
                editConditions.onclick = function(event) {
                    showConditionsEditor(instance);
                }
                conditionsList.appendChild(editConditions);
            }
        }

        // TODO: Keep saying "adversary" everywhere, or pick a generic term like "statBlock"
        //       that more accurately includes Environments as well?
        function createAdversaryElement(encounter, adversary) {
            // TODO: Allow reordering?

            let warning = "";
            if (adversary.tier > encounter.playerTier) {
                warning += ", ‚ö†Ô∏è above player tier";
            } else if (adversary.tier < encounter.playerTier) {
                warning += ", ‚ö†Ô∏è below player tier"
            }

            let typeSuffix = "";
            if (adversary.countPerHp > 1 || adversary.type === "Horde") {
                typeSuffix = ` (${adversary.countPerHp}/HP)`;
            }

            const adversaryDiv = document.createElement("div");
            adversaryDiv.className = "adversary";
            adversaryDiv.adversary = adversary;
            adversaryDiv.innerHTML = `<h3 title="Source: ${adversary.originalName}, ${adversary.source} ">${adversary.name}</h3>`;

            // TODO: Don't show parenthetical if Environment and no warning
            const battlePoints = getStatBlockBattlePoints(adversary.type, encounter.playerCount) * (adversary.instances?.length || 0);
            const tierAndType = document.createElement("p");
            tierAndType.className = "tier";
            tierAndType.innerText = `Tier ${adversary.tier} ${adversary.type}${typeSuffix} (${battlePoints} pts${warning})`;
            adversaryDiv.appendChild(tierAndType);

            if (adversary.description) {
                const description = document.createElement("p");
                description.className =  "description";
                description.innerText = adversary.description;
                adversaryDiv.appendChild(description);
            }

            if (adversary.motivesAndTactics) {
                const motives = document.createElement("p");
                motives.className =  "motives";
                motives.innerHTML = `<span class="motivesLabel">Motives & Tactics:</span> ${adversary.motivesAndTactics}`;
                adversaryDiv.appendChild(motives);
            }
            if (adversary.impulses) {
                const impulses = document.createElement("p");
                impulses.className =  "motives";
                impulses.innerHTML = `<span class="motivesLabel">Impulses:</span> ${adversary.impulses}`;
                adversaryDiv.appendChild(impulses);
            }

            const stats = document.createElement("p");
            stats.className = "stats";
            let majorThreshold = adversary.majorThreshold || "None";
            let severeThreshold = adversary.severeThreshold || "None";
            thresholds = `${majorThreshold}/${severeThreshold}`;
            // TODO: Break this up for when no thresholds
            stats.innerHTML = `<div><span class="statLabel">Difficulty:</span> ${adversary.difficulty} <span class="divider">|</span> <span class="statLabel">Thresholds:</span> ${thresholds}</div>`;
            if (adversary.attackDescription) {
                stats.innerHTML += `<div><span class="statLabel">ATK:</span> ${adversary.attackModifier} <span class="divider">|</span> <span class="statLabel">${adversary.attackDescription}:</span> ${adversary.attackRange} <span class="divider">|</span> ${adversary.attackDamage}</div>`;
            }
            if (adversary.experience) {
                stats.innerHTML += `<div class="experiences"><span class="statLabel">Experience:</span> ${adversary.experience}</div>`;
            }
            if (adversary.potentialAdversaries) {
                stats.innerHTML += `<div class="experiences"><span class="statLabel">Potential Adversaries:</span> ${adversary.potentialAdversaries}</div>`;
            }
            adversaryDiv.appendChild(stats);

            if (adversary.features && adversary.features.length > 0) {
                const featuresContainer = document.createElement("details");
                featuresContainer.open = expandAllFeatures;
                featuresContainer.className = "featuresExpander";
                featuresContainer.innerHTML = `<summary>FEATURES</summary>`;
                const featuresDiv = document.createElement("div");
                featuresDiv.className = "features";
                featuresContainer.appendChild(featuresDiv);
                featuresContainer.addEventListener("toggle", handleFeaturesToggle);

                for (let i = 0; i < adversary.features.length; i++) {
                    const featureElement = document.createElement("p");
                    featureElement.className = "feature";
                    featuresDiv.appendChild(featureElement);

                    const label = document.createElement("span");
                    label.className = "featureLabel";
                    label.innerText = `${adversary.features[i].name}:`;
                    featureElement.appendChild(label);

                    const description = document.createElement("span");
                    description.innerText = ` ${adversary.features[i].text}`;
                    featureElement.appendChild(description);
                }

                adversaryDiv.appendChild(featuresContainer);
            }

            for (let i = 0; i < adversary.instances?.length || 0; i++) {
                const instance = adversary.instances[i];

                const instanceDiv = document.createElement("div");
                instanceDiv.className = "instance";
                instanceDiv.instance = instance;
                adversaryDiv.appendChild(instanceDiv);

                const instanceName = document.createElement("input")
                instanceName.type = "text";
                instanceName.size = 30;
                instanceName.value = instance.name;
                instanceName.addEventListener("input", function(event) {
                    instance.name = event.target.value;
                    saveState();
                });
                instanceDiv.appendChild(instanceName);

                const hpDiv = document.createElement("div");
                hpDiv.className = "slotInfo";
                hpDiv.innerHTML = "HP:";
                const hpSlotsDiv = document.createElement("div");
                hpSlotsDiv.className = "slots";
                updateResource(hpSlotsDiv, adversary, "hp", instance, "hpMarked");
                hpDiv.appendChild(hpSlotsDiv);
                instanceDiv.appendChild(hpDiv);

                const stressDiv = document.createElement("div");
                stressDiv.className = "slotInfo";
                stressDiv.innerHTML = "Stress:";
                const stressSlotsDiv = document.createElement("div");
                stressSlotsDiv.className = "slots";
                updateResource(stressSlotsDiv, adversary, "stress", instance, "stressMarked");
                stressDiv.appendChild(stressSlotsDiv);
                instanceDiv.appendChild(stressDiv);

                const conditionsDiv = document.createElement("div");
                conditionsDiv.className = "conditions";
                instanceDiv.appendChild(conditionsDiv);
                updateConditionsDisplay(conditionsDiv, instance, true);

                const instanceTopActions = document.createElement("div");
                instanceTopActions.className = "top-actions";
                instanceDiv.appendChild(instanceTopActions);

                const removeInstanceButton = document.createElement("button");
                removeInstanceButton.className = "instance-action";
                removeInstanceButton.innerText = "üóëÔ∏è";
                removeInstanceButton.title = "Remove this instance of the adversary";
                removeInstanceButton.onclick = function(event) {
                    event.target.closest(".instance").remove();
                    adversary.instances = adversary.instances.filter(function(i) {
                        return i !== instance;
                    });
                    saveState();
                    refreshDisplay();
                };
                instanceTopActions.appendChild(removeInstanceButton);
            }

            setupAdversaryActionButton(adversaryDiv, adversary);

            return adversaryDiv;
        }

        function addAdversary(container, encounter, adversary) {
            const adversaryElement = createAdversaryElement(encounter, adversary);

            adversaryElement.addEventListener("adversaryRemoved", function(event) {
                encounter.adversaries = encounter.adversaries.filter(function(a) {
                    return a !== adversary;
                });
                container.removeChild(adversaryElement);
                refreshBattlePoints();
                saveState();
            });
            adversaryElement.addEventListener("adversaryCopied", function(event) {
                const newAdversary = JSON.parse(JSON.stringify(adversary));
                newAdversary.name += " (copy)"; // TODO: Decide naming
                if (!encounter.adversaries) {
                    encounter.adversaries = [];
                }
                encounter.adversaries.push(newAdversary);
                addAdversary(container, encounter, newAdversary);
                saveState();
            });
            adversaryElement.addEventListener("adversaryCopiedFromSource", function(event) {
                // TODO: This is mostly a dupe of addAdversaryButton.onclick
                let newAdversary = null;
                if (adversary.source == "SRD") {
                    const sourceAdversary = srdAdversaries.find(function(a) {
                        return a.name === adversary.originalName;
                    });
                    newAdversary = JSON.parse(JSON.stringify(sourceAdversary));
                } else if (adversary.source == "Custom" && state.custom && state.custom.adversaries) { // TODO: Case-insensive?
                    const sourceAdversary = state.custom.adversaries.find(function(a) {
                        return a.name === adversary.originalName;
                    });
                    newAdversary = JSON.parse(JSON.stringify(sourceAdversary));
                } else {
                    console.warn("Only 'SRD' and 'Custom' sources are supported");
                    return;
                }

                if (newAdversary.category == "Adversary" && !newAdversary.instances || newAdversary.instances.length == 0) {
                    newAdversary.instances = [
                        {
                            name: newAdversary.name + " #1",
                            hpMarked: 0,
                            stressMarked: 0
                        }
                    ];
                }

                if (!encounter.adversaries) {
                    encounter.adversaries = [];
                }
                encounter.adversaries.push(newAdversary);
                addAdversary(container, encounter, newAdversary);
                saveState();
            });
            adversaryElement.addEventListener("adversarySavedToCustom", function(event) {
                adversary.source = "Custom";
                adversary.originalName = adversary.name; // TODO: Enforce unique names (easy here, hard if we offer import)
                const newCustomAdversary = JSON.parse(JSON.stringify(adversary));
                delete newCustomAdversary.instances;
                if (!state.custom) {
                    state.custom = {};
                }
                if (!state.custom.adversaries) {
                    state.custom.adversaries = [];
                }
                state.custom.adversaries.push(newCustomAdversary);
                saveState();
                refreshDisplay(); // To add to search
            });
            adversaryElement.addEventListener("adversaryDeletedFromCustom", function(event) {
                if (adversary.source !== "Custom") {
                    console.warn("Trying to delete a non-custom adversary from custom list");
                    return;
                }
                if (!state.custom) {
                    state.custom = {};
                }
                if (!state.custom.adversaries) {
                    state.custom.adversaries = [];
                }
                state.custom.adversaries = state.custom.adversaries.filter(function(a) {
                    return a.name !== adversary.originalName;
                });
                adversary.source = "Orphaned";
                saveState();
                refreshDisplay();
            });

            container.appendChild(adversaryElement);
            refreshBattlePoints();
        }

        function getStatBlockBattlePoints(adversaryType, playerCount) {
            switch(adversaryType.toLowerCase()) {
                case "minion":
                    return 1 / playerCount;
                case "social":
                case "support":
                    return 1;
                case "horde":
                case "ranged":
                case "skulk":
                case "standard":
                    return 2;
                case "leader":
                    return 3;
                case "bruiser":
                    return 4;
                case "solo":
                    return 5;
                default:
                    console.warn("Unknown adversary type:", adversaryType);
                    return 0;
            }
        }

        function calculateBattlePoints(encounter)
        {
            let currentBattlePoints = 0;
            for (let j = 0; j < encounter.adversaries.length; j++) {
                const adversary = encounter.adversaries[j];
                const adversaryPoints = adversary.category == "Adversary" ? getStatBlockBattlePoints(adversary.type, encounter.playerCount) : 0;
                // TODO: Deal with tier differences
                currentBattlePoints += adversaryPoints * (adversary.instances?.length || 0);
            }
            return currentBattlePoints;
        }

        function refreshDisplay() {
            encounterSelector.innerHTML = ""; // Clear any existing options
            for (let i = 0; i < state.encounters.length; i++) {
                const encounter = state.encounters[i];
                const option = document.createElement("option");
                option.value = i;
                // TODO: Validate various fields
                option.innerText = `${encounter.name} (Tier ${encounter.playerTier} | ${encounter.playerCount} Players)`;
                encounterSelector.appendChild(option);
            }

            const validatedEncounterIndex = Math.max(0, Math.min(selectedEncounterIndex, state.encounters.length - 1));
            console.log("validatedEncounterIndex: " + validatedEncounterIndex);
            if (encounterSelector.value !== validatedEncounterIndex) {
                encounterSelector.value = validatedEncounterIndex;
            }

            const encounterDiv = document.getElementById("encounter");
            encounterDiv.className = "encounter";
            encounterDiv.innerHTML = ""; // Clear any existing content

            const encounter = state.encounters[selectedEncounterIndex];
            if (!encounter) {
                encounterDiv.innerHTML = "<p>No encounters found. Please create a new encounter.</p>";
                return;
            }

            // Clear custom entries from search
            for (let i = adversaryDatalist.children.length - 1; i >= 0; i--) {
                const option = adversaryDatalist.children[i];
                if (option.adversary.source !== "SRD") {
                    option.remove();
                }
            }
            for (let i = browsingTableBody.children.length - 1; i >= 0; i--) {
                const row = browsingTableBody.children[i];
                if (row.adversary.source !== "SRD") {
                    row.remove();
                }
            }

            // Add custom entries
            // TODO: Sort alpha by name, mixing sources (environments should also be mixed/sorted)
            // TODO: This is not encounter-specific data, should it not be refreshed here?
            if (state.custom && state.custom.adversaries && state.custom.adversaries.length > 0) {
                state.custom.adversaries.forEach(function(adversary) {
                    addAdversaryToSearch(adversary);
                });
            }

            // TODO: Validate various fields
            if (!encounter.adversaries) {
                encounter.adversaries = [];
            }

            const encounterBar = document.createElement("div");
            encounterBar.className = "encounter-bar";
            encounterDiv.appendChild(encounterBar);

            const addAdversaryDiv = document.createElement("div");
            const srdSearch = document.createElement("input");
            srdSearch.type = "search";
            srdSearch.placeholder = "Search Adversaries";
            srdSearch.setAttribute("list", "searchable-adversaries");
            addAdversaryDiv.appendChild(srdSearch);
            encounterBar.appendChild(addAdversaryDiv);

            // TODO: Should be able to initiate edit from here? Should this move to top bar?
            const battlePointsDiv = document.createElement("div");
            battlePointsDiv.id = "battle-points";
            battlePointsDiv.innerHTML = `<p>Target Battle Points: ${encounter.targetBattlePoints} (<span name="current-battle-points"></span> <span name="remaining-suffix"></span>) <span title="TODO: Click for summary from BUILDING BALANCED ENCOUNTERS">‚ÑπÔ∏è</span></p>`;
            encounterBar.appendChild(battlePointsDiv);
            refreshBattlePoints();

            const fearDiv = createFearTracker(encounter);
            encounterBar.appendChild(fearDiv);

            const adversariesDiv = document.createElement("div");
            adversariesDiv.className = "adversaries";
            for (let j = 0; j < encounter.adversaries.length; j++) {
                addAdversary(adversariesDiv, encounter, encounter.adversaries[j]);
            }
            encounterDiv.appendChild(adversariesDiv);

            const addAdversaryButton = document.createElement("button");
            addAdversaryButton.innerText = "Add Adversary";
            addAdversaryButton.onclick = function() {
                let selectedOption = srdSearch.value.trim();
                if (!selectedOption) {
                    // TODO: Or some "custom" type?
                    selectedOption = "Jagged Knife Bandit";
                }
                let adversary = srdAdversaries.find(function(a) {
                    return a.name.localeCompare(selectedOption, undefined, { sensitivity: 'base' }) === 0;
                });
                if (!adversary && state.custom && state.custom.adversaries) {
                    adversary = state.custom.adversaries.find(function(a) {
                        return a.name.localeCompare(selectedOption, undefined, { sensitivity: 'base'}) === 0;
                    });
                }
                if (adversary) {
                    adversary = JSON.parse(JSON.stringify(adversary));
                }
                // TODO: Else, custom with given name?

                if (adversary) {
                    if (adversary.category == "Adversary" && !adversary.instances || adversary.instances.length == 0) {
                        adversary.instances = [
                            {
                                name: adversary.name + " #1",
                                hpMarked: 0,
                                stressMarked: 0
                            }
                        ];
                    }

                    if (!encounter.adversaries) {
                        encounter.adversaries = [];
                    }
                    encounter.adversaries.push(adversary);
                    addAdversary(adversariesDiv, encounter, adversary);
                    saveState();
                }
            };
            addAdversaryDiv.appendChild(addAdversaryButton);

            srdSearch.addEventListener("keyup", function(event) {
                if (event.keyCode === 13) { // Enter key
                    event.preventDefault();
                    addAdversaryButton.click();
                }
            });
        }

        console.log("fetching state...");
        let selectedEncounterIndex = parseInt(localStorage.getItem("selected-encounter-index"));
        if (!selectedEncounterIndex) {
            selectedEncounterIndex = 0;
        }

        let state = sampleEncounters;
        const persistedStateJson = localStorage.getItem("encounters-state");
        if (persistedStateJson) {
            try {
                state = JSON.parse(persistedStateJson);
            } catch (error) {
                console.error("Error loading saved encounters:", error);
            }
        } else {
            console.warn("No saved encounters found, displaying sample encounters.");
        }

        const fileInput = document.getElementById("load-encounters");
        fileInput.addEventListener("change", function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        state = JSON.parse(e.target.result);
                        refreshDisplay();
                    } catch (error) {
                        console.error("Error loading encounters:", error);
                    }
                };
                reader.onerror = function(e) {
                    console.error("Error reading file:", e);
                };
                reader.readAsText(file);
            }
        });

        const saveEncountersButton = document.getElementById("save-encounters");
        saveEncountersButton.addEventListener("click", function() {
            const json = JSON.stringify(state, null, "    ");
            const blob = new Blob([json], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "encounters.json";
            a.click();
            URL.revokeObjectURL(url);
        });

        const encounterSelector = document.getElementById("current-encounter");
        encounterSelector.addEventListener("change", function() {
            selectedEncounterIndex = parseInt(encounterSelector.value);
            saveState();
            refreshDisplay();
            updateBrowsingTier()
        });

        function saveState() {
            localStorage.setItem("encounters-state", JSON.stringify(state));
            localStorage.setItem("selected-encounter-index", selectedEncounterIndex)
        }

        // TODO: This is probably a silly way to do this, we
        //       don't actually want all these DOM elements.
        //       But it's an easy way to get that autocomplete for now.
        const adversaryDatalist = document.createElement("datalist");
        adversaryDatalist.id = "searchable-adversaries";
        const browsingTableBody = document.querySelector("#browsing tbody");
        for (let i = 0; i < srdAdversaries.length; i++) {
            addAdversaryToSearch(srdAdversaries[i]);
        }
        document.body.appendChild(adversaryDatalist);

        refreshDisplay();
        updateBrowsingTableFiltering(); // TODO: Move into refreshDisplay?
    </script>
</html>