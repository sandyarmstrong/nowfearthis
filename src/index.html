<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Encounter Tracker</title>
        <script src="adversaries.js"></script>
        <style>
            input#load-encounters {
                /* Hide the file input element and style its label as a button */
                display: none;
            }
            #load-encounters-container {
                /* Need vertical margin to make room for label padding */
                margin: 10px 0px;
            }
            #load-encounters-container label {
                /* TODO: When styling real buttons, don't forget to update this to match */
                background-color: rgb(233, 233, 237);
                border: 1px ridge rgb(143, 143, 157);
                padding: 5px 10px;
                border-radius: 5px;
                height: auto;
            }
            #load-encounters-container label:hover {
                background-color: rgb(208, 208, 215);
                border-color: rgb(103, 103, 116);
            }

            .slots {
                display: inline-block
            }

            .adversary {
                display: inline-block;
            }

            .adversary h3 {
                margin: 10px 0px;
            }
            .adversary p {
                margin: 7px 0px;
            }

            ul.conditions-list {
                list-style: none;
                display: inline;
            }
            ul.conditions-list li {
                display: inline;
                margin-right: 5px;
            }

            ul.modifications-list {
                margin: 5px 0px;
            }

            .modifications {
                margin-top: 5px;
            }
        </style>
    </head>

    <body>
        <h1>Encounter Tracker</h1>

        <datalist id="srd-conditions">
            <option value="Hidden"></option>
            <option value="Restrained"></option>
            <option value="Vulnerable"></option>
            <option value="Asleep"></option>
            <option value="Stunned"></option>
            <option value="Silenced"></option>
            <option value="Corroded"></option>
            <option value="Ranger's Focus"></option>
            <option value="Cloaked"></option>
            <option value="Dizzied"></option>
            <option value="Enveloped"></option>
        </datalist>

        <datalist id="modifiable-properties">
            <option value="difficulty"></option>
            <option value="majorThreshold"></option>
            <option value="severeThreshold"></option>
        </datalist>

        <div id="load-encounters-container">
            <label for="load-encounters">Load Encounters (replaces existing encounters)</label>
            <input type="file" id="load-encounters" accept=".json" />
        </div>

        <div id="encounters"></div>
    </body>

    <script>
        var sampleEncounters = [
            {
                "name": "Forest Ambush",
                "targetBattlePoints": 10, // Allows telling user they might need more or less adversaries
                "currentFear": 5, // Convenient. Also allows remembering fear state for different groups
                "playerTier": 1, // Needed to help calculate battle points, if adversary tiers differ
                "playerCount": 3, // Need to calculate minion battle points
                "description": "A group of bandits ambushes the party in a dense forest.",
                "adversaries": [
                    {
                        "name": "Bandit #1",
                        "originalName": "Jagged Knife Bandit",
                        "source": "SRD",
                        "tier": 1,
                        "type": "Standard",
                        // TODO: Description, motives/tactics, features, experiences, attacks
                        "difficulty": 12,
                        "majorThreshold": 8,
                        "severeThreshold": 14,
                        "hp": {
                            "slots": 5,
                            "marked": 3
                        },
                        "stress": {
                            "slots": 3,
                            "marked": 0
                        },
                        "modifications": [
                            {
                                "modificationName": "Distracted",
                                "propertyName": "difficulty",
                                "modification": "-2" // - or + to modify, or just a number to hard-set, mods are applied in order
                            }
                        ],
                        "conditions": [
                            "Restrained",
                            "Vulnerable"
                        ]
                    }
                ]
            }
        ];

        const adversaryRemovedEvent = new Event("adversaryRemoved");

        function createFearTracker(encounter, saveState) {
            var fearDiv = document.createElement("div");

            var fearValue = document.createElement("span");

            function updateFearDisplay() {
                fearValue.innerText = "Fear: " + encounter.currentFear;
            }
            updateFearDisplay();

            var useFearButton = document.createElement("button");
            useFearButton.innerText = "-";
            useFearButton.onclick = function() {
                if (encounter.currentFear > 0) {
                    encounter.currentFear--;
                    updateFearDisplay();
                    saveState();
                }
            };

            var gainFearButton = document.createElement("button");
            gainFearButton.innerText = "+";
            gainFearButton.onclick = function() {
                if (encounter.currentFear < 12) {
                    encounter.currentFear++;
                    updateFearDisplay();
                    saveState();
                }
            };

            fearDiv.appendChild(useFearButton);
            fearDiv.appendChild(fearValue);
            fearDiv.appendChild(gainFearButton);

            return fearDiv;
        }

        function updateResource(container, resource, saveState) {
            var elements = [];

            for (var i = 0; i < resource.slots; i++) {
                var slot = document.createElement("input");
                slot.type = "checkbox";
                if (i < resource.marked) {
                    slot.checked = true;
                }
                slot.onclick = function(event) {
                    if (event.target.checked) {
                        resource.marked++;
                    } else {
                        resource.marked--;
                    }
                    updateResource(container, resource, saveState);
                    saveState();
                };
                elements.push(slot);
            }

            container.replaceChildren(...elements);
        }

        function createAdversaryElement(encounter, adversary, saveState) {
            var warning = "";
            if (adversary.tier > encounter.playerTier) {
                warning += "This adversary is above the player tier.";
            }

            var adversaryDiv = document.createElement("div");
            adversaryDiv.className = "adversary";
            adversaryDiv.innerHTML = `<h3>${adversary.name} (${adversary.originalName}, ${adversary.source})</h3>`;

            var tierAndType = document.createElement("p");
            tierAndType.innerText = `Tier ${adversary.tier} ${adversary.type}`;
            if (warning) {
                tierAndType.innerHTML += ` <span class="warning">(${warning})</span>`;
            }
            adversaryDiv.appendChild(tierAndType);

            var stats = document.createElement("p");
            var thresholds = "None";
            if (Number.isInteger(adversary.majorThreshold) && Number.isInteger(adversary.severeThreshold)) {
                thresholds = `${adversary.majorThreshold}/${adversary.severeThreshold}`;
            }
            stats.innerText = `Difficulty: ${adversary.difficulty} | Thresholds: ${thresholds}`;
            adversaryDiv.appendChild(stats);

            // TODO: See TODO in convertFromSRD for more stuff we can show

            var hpDiv = document.createElement("div");
            hpDiv.className = "slotInfo";
            hpDiv.innerHTML = "HP:";
            var hpSlotsDiv = document.createElement("div");
            hpSlotsDiv.className = "slots";
            updateResource(hpSlotsDiv, adversary.hp, saveState);
            hpDiv.appendChild(hpSlotsDiv);
            adversaryDiv.appendChild(hpDiv);

            var stressDiv = document.createElement("div");
            stressDiv.className = "slotInfo";
            stressDiv.innerHTML = "Stress:";
            var stressSlotsDiv = document.createElement("div");
            stressSlotsDiv.className = "slots";
            updateResource(stressSlotsDiv, adversary.stress, saveState);
            stressDiv.appendChild(stressSlotsDiv);
            adversaryDiv.appendChild(stressDiv);

            // TODO: Parse modifications and reflect them in the stats
            var conditionsDiv = document.createElement("div");
            var conditionsDisplayDiv = document.createElement("div");
            conditionsDiv.appendChild(conditionsDisplayDiv)

            function updateConditionsDisplay() {
                conditionsDisplayDiv.innerHTML = "Conditions: ";
                if (adversary.conditions && adversary.conditions.length > 0) {
                    var conditionsList = document.createElement("ul");
                    conditionsList.className = "conditions-list";
                    for (var i = 0; i < adversary.conditions.length; i++) {
                        var condition = adversary.conditions[i];

                        var conditionItem = document.createElement("li");
                        conditionsList.appendChild(conditionItem);

                        var conditionText = document.createElement("span");
                        conditionText.innerText = condition;
                        conditionItem.appendChild(conditionText);

                        var removeButton = document.createElement("button");
                        removeButton.innerText = "X";
                        removeButton.condition = condition;
                        removeButton.onclick = function(event) {
                            adversary.conditions = adversary.conditions.filter(function(c) {
                                return c !== event.target.condition;
                            });
                            updateConditionsDisplay();
                            saveState();
                        };
                        conditionItem.appendChild(removeButton);
                    }
                    conditionsDisplayDiv.appendChild(conditionsList);
                } else {
                    conditionsDisplayDiv.innerText += " None";
                }
            }

            updateConditionsDisplay();

            var addConditionsDiv = document.createElement("div");
            var addConditionInput = document.createElement("input");
            addConditionInput.type = "text";
            addConditionInput.setAttribute("list", "srd-conditions");
            var addConditionButton = document.createElement("button");
            addConditionButton.innerText = "Add Condition";
            addConditionButton.onclick = function() {
                var condition = addConditionInput.value.trim();
                if (condition && (!adversary.conditions || !adversary.conditions.includes(condition))) {
                    if (!adversary.conditions) {
                        adversary.conditions = [];
                    }
                    adversary.conditions.push(condition);
                    addConditionInput.value = "";
                    updateConditionsDisplay();
                    saveState();
                }
            };
            addConditionInput.addEventListener("keyup", function(event) {
                if (event.keyCode === 13) { // Enter key
                    event.preventDefault();
                    addConditionButton.click();
                }
            });
            addConditionsDiv.appendChild(addConditionInput);
            addConditionsDiv.appendChild(addConditionButton);
            conditionsDiv.appendChild(addConditionsDiv);
            adversaryDiv.appendChild(conditionsDiv);

            var modificationsDiv = document.createElement("div");
            modificationsDiv.className = "modifications";
            var modificationsDisplayDiv = document.createElement("div");
            modificationsDiv.appendChild(modificationsDisplayDiv);

            function updateModificationsDisplay() {
                modificationsDisplayDiv.innerHTML = "Modifications: ";
                if (adversary.modifications && adversary.modifications.length > 0) {
                    var modificationsList = document.createElement("ul");
                    modificationsList.className = "modifications-list";
                    for (var i = 0; i < adversary.modifications.length; i++) {
                        var modification = adversary.modifications[i];

                        var modificationItem = document.createElement("li");
                        modificationsList.appendChild(modificationItem);

                        var modificationText = document.createElement("span");
                        modificationText.innerText = `${modification.modificationName} (${modification.propertyName} ${modification.modification})`;
                        modificationItem.appendChild(modificationText);

                        var removeButton = document.createElement("button");
                        removeButton.innerText = "X";
                        removeButton.modification = modification;
                        removeButton.onclick = function(event) {
                            adversary.modifications = adversary.modifications.filter(function(m) {
                                return m !== event.target.modification;
                            });
                            updateModificationsDisplay();
                            saveState();
                        };
                        modificationItem.appendChild(removeButton);
                    }
                    modificationsDisplayDiv.appendChild(modificationsList);
                } else {
                    modificationsDisplayDiv.innerText += " None";
                }
            }

            updateModificationsDisplay();

            // TODO: This UI is pretty big, taking up a lot of space if
            //       there are a lot of adversaries, even if there are no modifications.
            //       Could make the input into a modal instead. Could also consider
            //       displaying modifications directly in the stats, with details
            //       on hover (but then how to delete?).
            var addModificationsDiv = document.createElement("div");
            var addModificationNameInput = document.createElement("input");
            addModificationNameInput.type = "text";
            addModificationNameInput.placeholder = "Name";
            var addModificationPropertyInput = document.createElement("input");
            addModificationPropertyInput.type = "text";
            addModificationPropertyInput.placeholder = "Target Property";
            addModificationPropertyInput.setAttribute("list", "modifiable-properties");
            var addModificationValueInput = document.createElement("input");
            addModificationValueInput.type = "text";
            addModificationValueInput.placeholder = "Modifier (e.g. -2, +3, 10)";
            var addModificationButton = document.createElement("button");
            addModificationButton.innerText = "Add Modification";
            addModificationButton.onclick = function() {
                var modificationName = addModificationNameInput.value.trim();
                var propertyName = addModificationPropertyInput.value.trim();
                var modificationValue = addModificationValueInput.value.trim();
                if (modificationName && propertyName && modificationValue) {
                    if (!adversary.modifications) {
                        adversary.modifications = [];
                    }
                    adversary.modifications.push({
                        modificationName: modificationName,
                        propertyName: propertyName,
                        modification: modificationValue
                    });
                    addModificationNameInput.value = "";
                    addModificationPropertyInput.value = "";
                    addModificationValueInput.value = "";
                    updateModificationsDisplay();
                    saveState();
                }
            };
            addModificationsDiv.appendChild(addModificationNameInput);
            addModificationsDiv.appendChild(addModificationPropertyInput);
            addModificationsDiv.appendChild(addModificationValueInput);
            addModificationsDiv.appendChild(addModificationButton);
            modificationsDiv.appendChild(addModificationsDiv);
            adversaryDiv.appendChild(modificationsDiv);

            var deleteButton = document.createElement("button");
            deleteButton.innerText = "Remove Adversary";
            deleteButton.onclick = function() {
                adversaryDiv.dispatchEvent(adversaryRemovedEvent);
            };
            adversaryDiv.appendChild(deleteButton);

            return adversaryDiv;
        }

        function addAdversary(container, encounter, adversary, refreshBattlePoints, saveState) {
            var adversaryElement = createAdversaryElement(encounter, adversary, saveState);
            adversaryElement.addEventListener("adversaryRemoved", function(event) {
                encounter.adversaries = encounter.adversaries.filter(function(a) {
                    return a !== adversary;
                });
                container.removeChild(adversaryElement);
                refreshBattlePoints();
                saveState();
            });
            container.appendChild(adversaryElement);
            refreshBattlePoints();
        }

        function convertFromSRD(srdAdversary) {
            var thresholds = srdAdversary.thresholds.split("/");
            return {
                name: srdAdversary.name,
                originalName: srdAdversary.name,
                source: "SRD",
                tier: parseInt(srdAdversary.tier),
                type: srdAdversary.type,
                difficulty: parseInt(srdAdversary.difficulty),
                hp: {
                    slots: parseInt(srdAdversary.hp),
                    marked: 0
                },
                stress: {
                    slots: parseInt(srdAdversary.stress),
                    marked: 0
                },
                majorThreshold: parseInt(thresholds[0]),
                severeThreshold: parseInt(thresholds[1]),
            };
            // TODO: description, motives_and_tactics, attack, range, damage, experience, feats (name/text)
        }

        function calculateBattlePoints(encounter)
        {
            var currentBattlePoints = 0;
            for (var j = 0; j < encounter.adversaries.length; j++) {
                var adversary = encounter.adversaries[j];
                // TODO: Deal with tier differences
                switch(adversary.type) {
                    case "Minion":
                        currentBattlePoints += 1 / encounter.playerCount;
                        break;
                    case "Social":
                    case "Support":
                        currentBattlePoints += 1;
                        break;
                    case "Horde":
                    case "Ranged":
                    case "Skulk":
                    case "Standard":
                        currentBattlePoints += 2;
                        break;
                    case "Leader":
                    case "Elite":
                        currentBattlePoints += 3;
                        break;
                    case "Bruiser":
                        currentBattlePoints += 4;
                        break;
                    case "Solo":
                        currentBattlePoints += 5;
                        break;
                }
            }
            return currentBattlePoints;
        }

        function displayEncounters(encounters) {
            function saveState() {
                localStorage.setItem("encounters", JSON.stringify(encounters));
            }

            var encountersDiv = document.getElementById("encounters");
            encountersDiv.innerHTML = ""; // Clear any existing content

            var saveEncountersButton = document.createElement("button");
            saveEncountersButton.innerText = "Save Encounters";
            encountersDiv.appendChild(saveEncountersButton);

            saveEncountersButton.addEventListener("click", function() {
                var json = JSON.stringify(encounters);
                var blob = new Blob([json], { type: "application/json" });
                var url = URL.createObjectURL(blob);
                var a = document.createElement("a");
                a.href = url;
                a.download = "encounters.json";
                a.click();
                URL.revokeObjectURL(url);
            });

            // TODO: Save current state to localStorage (when, every modification?), and load it on startup

            // TODO: Actually, show one encounter at a time, and allow switching between them,
            //       as well as adding or deleting encounters.
            for (var i = 0; i < encounters.length; i++) {
                var encounter = encounters[i];
                var encounterDiv = document.createElement("div");
                encounterDiv.className = "encounter";
                encounterDiv.innerHTML = `<h2>${encounter.name} (Tier ${encounter.playerTier} | ${encounter.playerCount} Players)</h2><p>${encounter.description}</p>`;

                var fearDiv = createFearTracker(encounter, saveState);
                encounterDiv.appendChild(fearDiv);

                var battlePointsDiv = document.createElement("div");
                battlePointsDiv.innerHTML = `<p>Target Battle Points: ${encounter.targetBattlePoints} (<span name="current-battle-points"></span> left)</p>`;
                encounterDiv.appendChild(battlePointsDiv);

                function refreshBattlePoints() {
                    var currentBattlePoints = calculateBattlePoints(encounter);

                    // Round to nearest 0.1 for display
                    var remainingBattlePoints = Math.round((encounter.targetBattlePoints - currentBattlePoints) * 10) / 10;

                    battlePointsDiv.querySelector("[name='current-battle-points']").innerText = remainingBattlePoints;
                }
                refreshBattlePoints();

                var addAdversaryDiv = document.createElement("div");
                var srdSearch = document.createElement("input");
                srdSearch.type = "search";
                srdSearch.placeholder = "Search SRD Adversaries";
                srdSearch.setAttribute("list", "srd-adversaries");
                addAdversaryDiv.appendChild(srdSearch);
                encounterDiv.appendChild(addAdversaryDiv);

                var adversariesDiv = document.createElement("div");
                for (var j = 0; j < encounter.adversaries.length; j++) {
                    addAdversary(adversariesDiv, encounter, encounter.adversaries[j], refreshBattlePoints, saveState);
                }
                encounterDiv.appendChild(adversariesDiv);

                var addAdversaryButton = document.createElement("button");
                addAdversaryButton.innerText = "Add Adversary";
                addAdversaryButton.onclick = function() {
                    var selectedOption = srdSearch.value.trim();
                    if (!selectedOption) {
                        // TODO: Or some "custom" type?
                        selectedOption = "Jagged Knife bandit";
                    }
                    var srdAdversary = srdAdversaries.find(function(a) {
                        return a.name.localeCompare(selectedOption, undefined, { sensitivity: 'base' }) === 0;
                    });
                    if (srdAdversary) {
                        var adversary = convertFromSRD(srdAdversary);
                        var maxDuplicateNumber = 0;
                        for (var k = 0; k < encounter.adversaries.length; k++) {
                            var existingAdversaryNameParts = encounter.adversaries[k].name.split(" #");
                            if (existingAdversaryNameParts[0] === adversary.name) {
                                if (existingAdversaryNameParts.length > 1) {
                                    maxDuplicateNumber = Math.max(parseInt(existingAdversaryNameParts[1]), maxDuplicateNumber);
                                }
                            }
                        }
                        adversary.name += " #" + (maxDuplicateNumber + 1);

                        if (!encounter.adversaries) {
                            encounter.adversaries = [];
                        }
                        encounter.adversaries.push(adversary);
                        addAdversary(adversariesDiv, encounter, adversary, refreshBattlePoints, saveState);
                        saveState();
                    }
                };
                addAdversaryDiv.appendChild(addAdversaryButton);

                srdSearch.addEventListener("keyup", function(event) {
                    if (event.keyCode === 13) { // Enter key
                        event.preventDefault();
                        addAdversaryButton.click();
                    }
                });

                encountersDiv.appendChild(encounterDiv);
            }
        }

        // TODO: This is probably a silly way to do this, we
        //       don't actually want all these DOM elements.
        //       But it's an easy way to get that autocomplete for now.
        // TODO: Also, we want a broader search option, should be able
        //       to search by source, tier, and other arbitrary property text,
        //       and allow easier browsing.
        var srdDatalist = document.createElement("datalist");
        srdDatalist.id = "srd-adversaries";
        for (var i = 0; i < srdAdversaries.length; i++) {
            var option = document.createElement("option");
            option.value = srdAdversaries[i].name;
            srdDatalist.appendChild(option);
        }
        document.body.appendChild(srdDatalist);

        var savedEncounters = localStorage.getItem("encounters");
        if (savedEncounters) {
            try {
                var encounters = JSON.parse(savedEncounters);
                displayEncounters(encounters);
            } catch (error) {
                console.error("Error loading saved encounters:", error);
                displayEncounters(sampleEncounters);
            }
        } else {
            console.warn("No saved encounters found, displaying sample encounters.");
            displayEncounters(sampleEncounters);
        }

        var fileInput = document.getElementById("load-encounters");
        fileInput.addEventListener("change", function(event) {
            var file = event.target.files[0];
            if (file) {
                var reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        var encounters = JSON.parse(e.target.result);
                        displayEncounters(encounters);
                    } catch (error) {
                        console.error("Error loading encounters:", error);
                    }
                };
                reader.onerror = function(e) {
                    console.error("Error reading file:", e);
                };
                reader.readAsText(file);
            }
        });
    </script>
</html>