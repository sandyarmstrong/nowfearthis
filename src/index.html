<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Fright Night</title>
        <script src="adversaries.js"></script>
        <script src="environments.js"></script>
        <style>
            :root {
                /* --body-bg-color: rgb(13, 17, 23);
                --text-color: rgb(159, 177, 209);
                --adversary-bg-color: rgb(22, 26, 32);
                --adversary-border-color: rgb(50, 54, 59);
                --adversary-text-color: var(--text-color);
                --header-text-color: #c3d0e5; */

                /* --body-bg-color: rgb(38,36,43);
                --text-color: white; (95,114,176)
                --adversary-bg-color: rgb(45,44,64);
                --stats-bg-color: rgb(50,52,86);
                --adversary-border-color: rgb(63,73,126);
                --adversary-text-color: var(--text-color);
                --header-text-color: white; */

                /** Palette courtesy of https://colorffy.com/dark-theme-generator?colors=825aa2-121212 */
                /** Base colors */
                --clr-dark-a0: #000000;
                --clr-light-a0: #ffffff;

                /** Theme primary colors */
                --clr-primary-a0: #825aa2;
                --clr-primary-a10: #906bac;
                --clr-primary-a20: #9e7db6;
                --clr-primary-a30: #ac8fc1;
                --clr-primary-a40: #b9a1cb;
                --clr-primary-a50: #c7b3d5;

                /** Theme surface colors */
                --clr-surface-a0: #121212;
                --clr-surface-a10: #282828;
                --clr-surface-a20: #3f3f3f;
                --clr-surface-a30: #575757;
                --clr-surface-a40: #717171;
                --clr-surface-a50: #8b8b8b;

                /** Theme tonal surface colors */
                --clr-surface-tonal-a0: #1c191f;
                --clr-surface-tonal-a10: #312e34;
                --clr-surface-tonal-a20: #47444a;
                --clr-surface-tonal-a30: #5f5c61;
                --clr-surface-tonal-a40: #777579;
                --clr-surface-tonal-a50: #918f93;

                --body-bg-color: var(--clr-surface-a0);
                --text-color: var(--clr-light-a0);
                --adversary-bg-color: var(--clr-surface-a10);
                --stats-bg-color: var(--clr-surface-a20);
                --adversary-border-color: var(--adversary-bg-color);
                --adversary-text-color: var(--text-color);
                --header-text-color: var(--clr-primary-a50);

                --button-bg-color: var(--clr-primary-a20);
                --button-bg-hover-color: var(--clr-primary-a10);
                --button-bg-active-color: var(--clr-primary-a0);
                --button-text-color: var(--clr-dark-a0);
            }
            body {
                background-color: var(--body-bg-color);
                color: var(--text-color);
                margin: 0px;
            }
            .hidden {
                display: none;
            }
            #copyright, #repo-info {
                font-size: smaller;
                margin-top: 10px;
            }

            #top-bar {
                display: flex;
                align-items: center;
                justify-content: space-between;
                top: 0px;
                left: 0px;
                right: 0px;
                padding-left: 10px;
                padding-right: 14px;
                background-color: var(--clr-surface-a10);
                border-bottom: 1px solid var(--clr-surface-a20);
            }
            .top-bar-group > * {
                display: inline-block;
            }
            input#load-encounters {
                /* Hide the file input element and style its label as a button */
                display: none;
            }
            #load-encounters-container {
                /* Need vertical margin to make room for label padding */
                margin: 10px 0px;
            }
            #load-encounters-container label {
                /* TODO: When styling real buttons, don't forget to update this to match */
                background-color: var(--button-bg-color);
                color: var(--button-text-color);
                padding: 5px;
                border-radius: 8px;
                height: auto;
            }
            #load-encounters-container label:hover {
                background-color: var(--button-bg-hover-color);
            }
            #load-encounters-container label:active {
                background-color: var(--button-bg-active-color);
            }

            button {
                padding: 5px;
                border-radius: 8px;
                color: var(--button-text-color);
                border: 0px;
                background-color: var(--button-bg-color);
            }
            button:hover {
                background-color: var(--button-bg-hover-color);
            }
            button:active {
                background-color: var(--button-bg-active-color);
            }
            button:disabled {
                background-color: var(--clr-surface-a50);
                /* opacity: 0.7; */
            }

            button.instance-action {
                background-color: var(--clr-surface-tonal-a0);
            }
            button.instance-action:hover {
                background-color: var(--clr-surface-tonal-a10);
            }
            button.instance-action:active {
                background-color: var(--clr-surface-tonal-a20);
            }
            button.instance-action:disabled {
                background-color: var(--clr-surface-tonal-a30);
                opacity: 0.7;
            }


            #encounter {
                margin: 10px;
            }

            .encounter-bar p {
                margin: 0px;
            }
            .encounter-bar > * {
                display: inline-block;
                margin-right: 10px;
            }

            .inactive {
                opacity: 0.3;
            }

            .adversary {
                position: relative; /* For action button */
                display: inline-block;
                vertical-align: top;
                /*
                    22em is empirical width needed to fit full ATK line for "Volcanic Dragon: Ashen Tyrant".
                    Longest ATK line in SRD is "Fallen Warlord: Undefeated Champion",
                    which requires 27em (at 22em, both ATK and Experience lines overflow).
                    27em feels way too wide. Trying 23em, which is enough to stop Fallen Warlord's
                    Experience line from overflowing.
                */
                width: 23em;
                border: 1px ridge var(--adversary-border-color);
                border-radius: 5px;
                margin-right: 5px;
                margin-top: 5px;
                padding: 5px 10px;
                background-color: var(--adversary-bg-color);
                color: var(--adversary-text-color);
            }
            .adversary h3 {
                margin: 8px 0px;
                color: var(--header-text-color);
            }
            .adversary p {
                margin: 2px 0px;
            }
            .adversary .source {
                font-style: italic;
                font-size: smaller;
            }
            .adversary .tier {
                font-style: italic;
                font-weight: bold;
            }
            .adversary .description {
                font-size: smaller;
                font-style: italic;
            }
            .adversary .motives {
                font-size: smaller;
            }
            .adversary .stats {
                background-color: var(--stats-bg-color);
                border-radius: 3px;
            }
            .adversary .statLabel, .adversary .motivesLabel {
                font-weight: bold;
            }
            .adversary .divider {
                font-size: larger;
                margin: 0px 3px;
            }
            .features {
                margin-left: 0.75em;
            }
            .featuresExpander summary {
                font-weight: bold;
            }
            .features .feature {
                text-indent: -0.75em
            }
            .featureLabel {
                font-style: italic;
                font-weight: bold;
            }

            .instance {
                position: relative; /* For action button */
                margin-top: 10px;
                background-color: var(--stats-bg-color);
                border-radius: 3px;
            }
            .instance h4 {
                margin: 0px;
            }
            .add-conditions, .add-modifications {
                margin: 5px 0px;
            }

            .slots {
                display: inline-block
            }

            .conditions {
                margin: 5px 0px;
            }
            ul.conditions-list {
                list-style: none;
                display: inline;
                padding: 0px;
                font-size: smaller;
            }
            ul.conditions-list li {
                display: inline-block;
                background-color: var(--clr-surface-a40);
                border-radius: 3px;
                margin-right: 5px;
                margin-bottom: 5px;
                padding: 2px;
            }
            button.inline-delete {
                background-color: transparent;
                color: var(--clr-primary-a50);
                border: 0px;
                border-radius: 3px;
                padding: 0px;
                margin-left: 5px;
                font-size: smaller;
            }
            button.inline-delete:hover {
                background-color: var(--clr-primary-a30);
            }
            button.inline-delete:active {
                background-color: var(--clr-primary-a10);
            }

            button.inline-add {
                border: 0px;
                border-radius: 2px;
                padding: 3px 4px;
            }

            button.action {
                float: right;
            }
            .top-actions {
                position: absolute;
                right: 5px;
                top: 5px;
            }
            .top-actions button {
                padding: 2px;
                margin-left: 3px;
                border-radius: 4px;
                font-size: smaller;
            }

            .actions-menu {
                position: absolute;
                right: 5px;
                top: 30px;
                margin: 0px;
                padding: 0px;
                list-style-type: none;
                /* TODO: Make this look like a menu, round some corners, etc */
            }
            .actions-menu button {
                border-radius: 0px;
                width: 100%;
            }

            #editor-overlay {
                position: fixed;
                z-index: 1000; /* Ensure it is above other content */
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
            }
            .editor {
                position: absolute;
                z-index: 1001; /* Ensure it is above the overlay */
                width: 27em;
                top: 50px;
                left: 50%;
                transform: translateX(-50%);
                background-color: var(--clr-surface-tonal-a10);
                padding: 20px;
                border-radius: 10px;
                box-shadow: 10px 10px 10px black;
            }
        </style>
    </head>

    <body>
        <datalist id="srd-conditions">
            <option value="Hidden"></option>
            <option value="Restrained"></option>
            <option value="Vulnerable"></option>
            <option value="Asleep"></option>
            <option value="Stunned"></option>
            <option value="Silenced"></option>
            <option value="Corroded"></option>
            <option value="Ranger's Focus"></option>
            <option value="Cloaked"></option>
            <option value="Dizzied"></option>
            <option value="Enveloped"></option>
        </datalist>

        <datalist id="modifiable-properties">
            <option value="difficulty"></option>
            <option value="majorThreshold"></option>
            <option value="severeThreshold"></option>
        </datalist>

        <div id="top-bar">
            <div class="top-bar-group">
                <select id="current-encounter">
                </select>
                <button id="edit-encounter" title="Edit Encounter">✏️</button>
                <button id="delete-encounter" title="Delete Encounter">🗑️</button>
                <!-- TODO: Separator-->
                <button id="add-encounter" title="Create New Encounter">➕ Create New Encounter</button>
            </div>
            <!-- TODO: Move these items to ... menu, and add import/export customs -->
            <div class="top-bar-group">
                <button id="save-encounters" title="Save Encounters">💾</button>
                <div id="load-encounters-container">
                    <label for="load-encounters" title="Load Encounters (replaces existing encounters)">📂</label>
                    <input type="file" id="load-encounters" accept=".json" />
                </div>
            </div>
        </div>

        <div id="encounter"></div>

        <div id="editor-overlay" class="hidden"></div>
        <div id="encounter-editor" class="editor hidden">
            <form id="encounter-form">
                <label for="encounter-name">Name:</label>
                <input type="text" id="encounter-name" required />
                <br>
                <label for="encounter-tier">Tier:</label>
                <input type="number" id="encounter-tier" min="1" max="4" value="1" required />
                <label for="encounter-player-count">Player Count:</label>
                <input type="number" id="encounter-player-count" min="1" max="20" value="4" required />
                <br>
                <label for="encounter-target-battle-points">Target Battle Points:</label>
                <input type="number" id="encounter-target-battle-points" min="1" max="99" value="14" required />
                <span id="encounter-recommended-battle-points"></span>
                <p>When planning a battle, start with <strong>[(3 x the number of PCs in combat) + 2]</strong> Battle Points and make the following adjustments:</p>
                <ul>
                    <li><strong>-1</strong> for an easier or shorter fight</li>
                    <li><strong>-2</strong> if you're using 2 or more Solo adversaries</li>
                    <li><strong>-2</strong> if you add +1d4 (or a static +2) to all adversaries' damage rolls</li>
                    <li><strong>+1</strong> if you choose an adversary from a lower tier</li>
                    <li><strong>+1</strong> if you don't include any Bruisers, Hordes, Leaders, or Solos</li>
                    <li><strong>+2</strong> for a harder or longer fight</li>
                </ul>
                <button type="button" id="cancel-encounter-edit">Cancel</button>
                <button type="submit" id="save-encounter-edit">Save Encounter</button>
            </form>
        </div>
        <div id="adversary-editor" class="editor hidden">
            <!-- Only advantage of Form that I can see is that it gives validation and submit-on-enter for free-->
            <form id="adversary-form">
                <fieldset>
                    <legend>Basics</legend>
                    <label for="adversary-name">Name:</label>
                    <input type="text" id="adversary-name" size="30" required />
                    <br>
                    <label for="adversary-tier">Tier:</label>
                    <input type="number" id="adversary-tier" min="1" max="4" value="1" required />
                    <label for="adversary-type">Type:</label>
                    <select id="adversary-type">
                        <option value="Bruiser">Bruiser</option>
                        <option value="Horde">Horde</option>
                        <option value="Leader">Leader</option>
                        <option value="Minion">Minion</option>
                        <option value="Ranged">Ranged</option>
                        <option value="Skulk">Skulk</option>
                        <option value="Social">Social</option>
                        <option value="Solo">Solo</option>
                        <option value="Standard">Standard</option>
                        <option value="Support">Support</option>
                    </select>
                    <br>
                    <label for="adversary-description">Description:</label>
                    <textarea id="adversary-description" cols="30" rows="3"></textarea>
                    <br>
                    <label for="adversary-motives">Motives & Tactics:</label>
                    <textarea id="adversary-motives" cols="30" rows="2"></textarea>
                </fieldset>
                <fieldset>
                    <legend>Stats</legend>
                    <label for="adversary-difficulty">Difficulty:</label>
                    <input type="number" id="adversary-difficulty" min="0" max="20" value="12" required />
                    <br>
                    <label for="adversary-major-threshold">Major Threshold:</label>
                    <input type="number" id="adversary-major-threshold" min="0" max="20" value="8" />
                    /
                    <label for="adversary-severe-threshold">Severe Threshold:</label>
                    <input type="number" id="adversary-severe-threshold" min="0" max="20" value="14" />
                    <br>
                    <label for="adversary-hp">HP:</label>
                    <input type="number" id="adversary-hp" min="1" max="20" value="5" required />
                    <label for="adversary-stress">Stress:</label>
                    <input type="number" id="adversary-stress" min="0" max="20" value="2" required />
                    <br>
                    <label for="adversary-experience">Experience:</label>
                    <input type="text" id="adversary-experience" />
                </fieldset>
                <fieldset>
                    <legend>Attack</legend>
                    <label for="adversary-attack-modifier">Modifier:</label>
                    <!-- <input type="number" id="adversary-attack-modifier" min="-10" max="20" value="0" /> -->
                    <input type="text" id="adversary-attack-modifier" size="4" placeholder="e.g. +3" />
                    <label for="adversary-attack-description">Description:</label>
                    <input type="text" id="adversary-attack-description" placeholder="e.g. Mace" />
                    <br>
                    <label for="adversary-attack-range">Range:</label>
                    <select id="adversary-attack-range">
                        <option value="Melee">Melee</option>
                        <option value="Very Close">Very Close</option>
                        <option value="Close">Close</option>
                        <option value="Far">Far</option>
                    </select>
                    <label for="adversary-attack-damage">Damage:</label>
                    <input type="text" id="adversary-attack-damage" size="12" placeholder="e.g. 1d10+3 phy" />
                </fieldset>
                <fieldset>
                    <legend>Features</legend>
                    <button id="add-feature">+ Add Feature</button>
                    <div id="adversary-features"></div>
                </fieldset>
                <button type="button" id="cancel-adversary-edit">Cancel</button>
                <button type="submit" id="save-adversary-edit">Save</button>
            </form>
        </div>

        <div id="repo-info">
            <p>Fright Night is free and open source and works entirely offline. Please <a href="https://github.com/sandyarmstrong/frightnight/issues">report any bugs or feature requests</a>.</p>
        </div>

        <div id="copyright">
            <p>This project includes materials from the Daggerheart System Reference Document 1.0,
                © Critical Role, LLC. under the terms of the Darrington Press Community Gaming (DPCGL) License.
                More information can be found at <a href="https://www.daggerheart.com">https://www.daggerheart.com</a>.
                Minor formatting modifications were provided as part of the excellent
                <a href="https://github.com/seansbox/daggerheart-srd">https://github.com/seansbox/daggerheart-srd</a>.</p>
        </div>
    </body>

    <script>
        // TODO: Populate with some real examples
        const sampleState = {
            "encounters": [
                {
                    "name": "Forest Ambush",
                    "targetBattlePoints": 10, // Allows telling user they might need more or less adversaries
                    "currentFear": 5, // Convenient. Also allows remembering fear state for different groups
                    "playerTier": 1, // Needed to help calculate battle points, if adversary tiers differ
                    "playerCount": 3, // Need to calculate minion battle points
                    "description": "A group of bandits ambushes the party in a dense forest.", // TODO: Useful?
                    "adversaries": [
                        {
                            "name": "Bandit",
                            "originalName": "Jagged Knife Bandit",
                            "source": "SRD",
                            "tier": 1,
                            "type": "Standard",
                            "difficulty": 12,
                            "majorThreshold": 8,
                            "severeThreshold": 14,
                            "hp": 5,
                            "stress": 3,
                            "instances": [
                                {
                                    "name": "Bandit #1",
                                    "hpMarked": 3,
                                    "stressMarked": 0,
                                    "conditions": [
                                        "Restrained",
                                        "Vulnerable"
                                    ],
                                    "modifications": [
                                        {
                                            "modificationName": "Distracted",
                                            "propertyName": "difficulty",
                                            "modification": "-2"
                                        }
                                    ]
                                },
                                {
                                    "name": "Bandit #2",
                                    "hpMarked": 0,
                                    "stressMarked": 0,
                                    "conditions": [],
                                    "modifications": []
                                }
                            ],
                        }
                    ],
                    "environments": [], // Big TODO
                }
            ],
            "custom": { // Yay homebrew, allow searching this, adding, modifying
                "adversaries": [],
                "environments": []
            }
        };

        // TODO: Change all code that puts user data directly into innerHTML

        const adversaryRemovedEvent = new Event("adversaryRemoved");
        const adversaryCopiedEvent = new Event("adversaryCopied");
        const adversaryCopiedFromSourceEvent = new Event("adversaryCopiedFromSource");
        const adversarySavedToCustomEvent = new Event("adversarySavedToCustom");
        const adversaryDeletedFromCustomEvent = new Event("adversaryDeletedFromCustom");

        const editorOverlay = document.getElementById("editor-overlay");
        const encounterEditor = document.getElementById("encounter-editor");
        const adversaryEditor = document.getElementById("adversary-editor");

        let expandAllFeatures = false;

        function hideAdversaryEditor() {
            const adversary = adversaryEditor.adversary;
            adversaryEditor.adversary = undefined;
            adversaryEditor.classList.add("hidden");
            editorOverlay.classList.add("hidden");
            if (adversary) {
                const adversaryElements = Array.from(document.querySelectorAll(".adversary"));
                for (let i = 0; i < adversaryElements.length; i++) {
                    if (adversaryElements[i].adversary == adversary) {
                        adversaryElements[i].scrollIntoView({ behavior: "instant", block: "center" });
                    }
                }
            }
        }

        adversaryEditor.addEventListener("keyup", function(event) {
            if (event.keyCode === 27) { // Escape key
                hideAdversaryEditor();
            }
        });

        function createFeatureEditorElement(feature, idSuffix)  {
            const featureElement = document.createElement("div");
            featureElement.className = "feature";
            featureElement.innerHTML = `<label for="adversary-feature-name-${idSuffix}">Name:</label><input type="text" class="adversary-feature-name" id="adversary-feature-name-${idSuffix}" value="${feature?.name ?? ""}"><label for="adversary-feature-text-${idSuffix}">Description:</label><textarea id="adversary-feature-text-${idSuffix}" class="adversary-feature-text" rows="4" cols="50">${feature?.text ?? ""}</textarea>`;
            return featureElement;
        }

        function showAdversaryEditor(adversary) {
            // Basics
            adversaryEditor.querySelector("#adversary-name").value = adversary.name;
            adversaryEditor.querySelector("#adversary-tier").value = adversary.tier;
            adversaryEditor.querySelector("#adversary-type").value = adversary.type; // TODO: Case mangling as needed
            adversaryEditor.querySelector("#adversary-description").value = adversary.description || "";
            adversaryEditor.querySelector("#adversary-motives").value = adversary.motivesAndTactics || "";

            // Stats
            adversaryEditor.querySelector("#adversary-difficulty").value = adversary.difficulty;
            adversaryEditor.querySelector("#adversary-major-threshold").value = adversary.majorThreshold;
            adversaryEditor.querySelector("#adversary-severe-threshold").value = adversary.severeThreshold;
            adversaryEditor.querySelector("#adversary-hp").value = adversary.hp;
            adversaryEditor.querySelector("#adversary-stress").value = adversary.stress;
            adversaryEditor.querySelector("#adversary-experience").value = adversary.experience || "";

            // Attack
            adversaryEditor.querySelector("#adversary-attack-modifier").value = adversary.attackModifier || ""; // TODO: Should input be number, then conversion?
            adversaryEditor.querySelector("#adversary-attack-description").value = adversary.attackDescription || "";
            adversaryEditor.querySelector("#adversary-attack-range").value = adversary.attackRange || ""; // TODO: Case mangling as needed
            adversaryEditor.querySelector("#adversary-attack-damage").value = adversary.attackDamage || "";

            // Features
            const featuresContainer = adversaryEditor.querySelector("#adversary-features");
            featuresContainer.innerHTML = ""; // Clear any existing children
            if (adversary.features && adversary.features.length > 0) {
                for (let i = 0; i < adversary.features.length; i++) {
                    const feature = adversary.features[i];
                    const featureElement = createFeatureEditorElement(feature, i);
                    featuresContainer.appendChild(featureElement);
                }
            }

            editorOverlay.classList.remove("hidden");
            adversaryEditor.classList.remove("hidden");
            adversaryEditor.adversary = adversary;
            adversaryEditor.querySelector("#adversary-name").select();
            window.scrollTo(0, 0);
        }

        document.querySelector("#add-feature").addEventListener("click", function() {
            const featureContainer = adversaryEditor.querySelector("#adversary-features");
            const featureElement = createFeatureEditorElement(null, featureContainer.children.length);
            featureContainer.appendChild(featureElement);
            // TODO: Allow deletion (but could also do this by deleting all text for a feature)
        });

        document.querySelector("#cancel-adversary-edit").addEventListener("click", function() {
            hideAdversaryEditor();
        });

        document.querySelector("#adversary-form").addEventListener("submit", function(event) {
            event.preventDefault(); // Prevent page refresh

            const adversary = adversaryEditor.adversary;
            if (adversary) {
                // Basics
                adversary.name = adversaryEditor.querySelector("#adversary-name").value.trim();
                adversary.tier = parseInt(adversaryEditor.querySelector("#adversary-tier").value);
                adversary.type = adversaryEditor.querySelector("#adversary-type").value;
                // TODO: Don't set optional fields if empty
                adversary.description = adversaryEditor.querySelector("#adversary-description").value.trim();
                adversary.motivesAndTactics = adversaryEditor.querySelector("#adversary-motives").value.trim();

                // Stats
                adversary.difficulty = parseInt(adversaryEditor.querySelector("#adversary-difficulty").value);
                adversary.majorThreshold = parseInt(adversaryEditor.querySelector("#adversary-major-threshold").value);
                adversary.severeThreshold = parseInt(adversaryEditor.querySelector("#adversary-severe-threshold").value);
                adversary.hp = parseInt(adversaryEditor.querySelector("#adversary-hp").value);
                if (adversary.instances) {
                    adversary.instances.forEach(function(instance) {
                        instance.hpMarked = Math.min(instance.hpMarked, adversary.hp);
                    });
                }
                adversary.stress = parseInt(adversaryEditor.querySelector("#adversary-stress").value);
                if (adversary.instances) {
                    adversary.instances.forEach(function(instance) {
                        instance.stressMarked = Math.min(instance.stressMarked, adversary.stress);
                    });
                }
                adversary.experience = adversaryEditor.querySelector("#adversary-experience").value.trim();

                // Attack
                adversary.attackModifier = adversaryEditor.querySelector("#adversary-attack-modifier").value.trim();
                adversary.attackDescription = adversaryEditor.querySelector("#adversary-attack-description").value.trim();
                adversary.attackRange = adversaryEditor.querySelector("#adversary-attack-range").value;
                adversary.attackDamage = adversaryEditor.querySelector("#adversary-attack-damage").value.trim();

                // Features
                adversary.features = [];
                const featureElements = adversaryEditor.querySelectorAll("#adversary-features .feature");
                featureElements.forEach(function(featureElement) {
                    const feature = {
                        name: featureElement.querySelector(".adversary-feature-name").value.trim(),
                        text: featureElement.querySelector(".adversary-feature-text").value.trim()
                    };
                    if (feature.name || feature.text) { // TODO: Require both?
                        adversary.features.push(feature);
                    }
                });
            }

            saveState();
            refreshDisplay();
            hideAdversaryEditor();
        });

        function hideEncounterEditor() {
            encounterEditor.classList.add("hidden");
            editorOverlay.classList.add("hidden");
        }

        encounterEditor.addEventListener("keyup", function(event) {
            if (event.keyCode === 27) { // Escape key
                hideEncounterEditor();
            }
        });

        function updateEditorBattlePointsRecommendation() {
            const playerCount = parseInt(document.querySelector("#encounter-player-count").value);
            const recommendedBattlePoints = (3 * playerCount) + 2;
            document.querySelector("#encounter-recommended-battle-points").innerText = `(Base recommendation: ${recommendedBattlePoints})`;
        }

        function showEncounterEditor(encounter) {
            if (!encounter) {
                encounter = {
                    name: "New Encounter",
                    playerTier: 1,
                    playerCount: 4,
                    targetBattlePoints: 14, // TODO: Automatically adjust when playerCount changes?
                };
                encounterEditor.encounter = null;
            } else {
                encounterEditor.encounter = encounter;
            }

            encounterEditor.querySelector("#encounter-name").value = encounter.name;
            encounterEditor.querySelector("#encounter-tier").value = encounter.playerTier ?? 1;
            encounterEditor.querySelector("#encounter-player-count").value = encounter.playerCount ?? 4;
            encounterEditor.querySelector("#encounter-target-battle-points").value = encounter.targetBattlePoints ?? 14;

            updateEditorBattlePointsRecommendation();

            editorOverlay.classList.remove("hidden");
            encounterEditor.classList.remove("hidden");
            encounterEditor.querySelector("#encounter-name").select();
            window.scrollTo(0, 0);
        }

        document.querySelector("#encounter-form").addEventListener("submit", function(event) {
            event.preventDefault(); // Prevent page refresh

            let encounter = encounterEditor.encounter;
            if (!encounter) {
                if (!state.encounters) {
                    state.encounters = [];
                }
                encounter = {}
                state.encounters.push(encounter);
                selectedEncounterIndex = state.encounters.length - 1;
            }

            encounter.name = encounterEditor.querySelector("#encounter-name").value.trim();
            encounter.playerTier = parseInt(encounterEditor.querySelector("#encounter-tier").value);
            encounter.playerCount = parseInt(encounterEditor.querySelector("#encounter-player-count").value);
            encounter.targetBattlePoints = parseInt(encounterEditor.querySelector("#encounter-target-battle-points").value);

            saveState();
            refreshDisplay();
            hideEncounterEditor();
        });

        document.querySelector("#cancel-encounter-edit").addEventListener("click", function() {
            hideEncounterEditor();
        });

        document.querySelector("#add-encounter").addEventListener("click", function() {
            showEncounterEditor();
        });

        document.querySelector("#edit-encounter").addEventListener("click", function() {
            const encounter = state.encounters[selectedEncounterIndex];
            showEncounterEditor(encounter);
        });

        document.querySelector("#delete-encounter").addEventListener("click", function() {
            if (state.encounters && state.encounters.length > 0) {
                state.encounters.splice(selectedEncounterIndex, 1);
                selectedEncounterIndex = Math.min(selectedEncounterIndex, state.encounters.length - 1);
                saveState();
                if (state.encounters.length === 0) {
                    showEncounterEditor();
                }
                refreshDisplay();
            }
        });

        document.querySelector("#encounter-player-count").addEventListener("change", function() {
            updateEditorBattlePointsRecommendation();
        });

        // TODO: This is annoying if you are scrolled down, and every adversary above changes expansion,
        //       messing with your scroll position. Fix scroll position or just don't do this.
        function handleFeaturesToggle(event) {
            const opened = event.target.open;
            if (expandAllFeatures != opened) {
                expandAllFeatures = opened;
                for (const element of document.getElementsByClassName("featuresExpander")) {
                    if (element.open != expandAllFeatures) {
                        element.open = expandAllFeatures;
                    }
                }
            }
        }

        function createFearTracker(encounter) {
            const maxFear = 12;
            // TODO: Nice simple rich tooltip guide: https://jsfiddle.net/8nnwytbL/
            // TODO: Roller for getting fear on rests?
            // TODO: Replace this with a stylized number input?
            const fearDiv = document.createElement("div");
            const fearValue = document.createElement("span");
            const useFearButton = document.createElement("button");
            const gainFearButton = document.createElement("button");

            if (encounter.currentFear === undefined) {
                encounter.currentFear = 0;
            }

            function updateFearDisplay() {
                fearValue.innerHTML = "";
                fearValue.title = `${encounter.currentFear} Fear | Start: {number of PCs} | Short rest: 1d4 | Long rest: 1d4 + {number of PCs}`;

                for (let i = 0; i < maxFear; i++) {
                    const fearIcon = document.createElement("span");
                    fearIcon.className = "fear-icon";
                    if (i >= encounter.currentFear) {
                        fearIcon.classList.add("inactive");
                    }
                    fearIcon.innerText = "💀";
                    fearValue.appendChild(fearIcon);
                }

                useFearButton.disabled = encounter.currentFear <= 0;
                gainFearButton.disabled = encounter.currentFear >= maxFear;
            }
            updateFearDisplay();

            useFearButton.innerText = "-";
            useFearButton.title = "Use 1 Fear";
            useFearButton.onclick = function() {
                if (encounter.currentFear > 0) {
                    encounter.currentFear--;
                    updateFearDisplay();
                    saveState();
                }
            };

            gainFearButton.innerText = "+";
            gainFearButton.title = "Gain 1 Fear (max 12)";
            gainFearButton.onclick = function() {
                if (encounter.currentFear < maxFear) {
                    encounter.currentFear++;
                    updateFearDisplay();
                    saveState();
                }
            };

            fearDiv.appendChild(useFearButton);
            fearDiv.appendChild(fearValue);
            fearDiv.appendChild(gainFearButton);

            return fearDiv;
        }

        function updateResource(container, adversary, adversarySlotsPropertyName, instance, instanceMarkedPropertyName) {
            const elements = [];
            const slots = adversary[adversarySlotsPropertyName];
            const marked = instance[instanceMarkedPropertyName];

            // TODO: Reduce opacity or something when HP is fully marked?
            //       - Would also need to do it on initial/refresh layout
            //       - Would also need to differentiate between HP and Stress
            // TODO: Add "Vulnerable (stress full)" condition when stress is fully marked?
            //       Would have to make sure it couldn't be deleted otherwise though.

            for (let i = 0; i < slots; i++) {
                const slot = document.createElement("input");
                slot.type = "checkbox";
                if (i < marked) {
                    slot.checked = true;
                }
                slot.onclick = function(event) {
                    if (event.target.checked) {
                        instance[instanceMarkedPropertyName]++;
                    } else {
                        instance[instanceMarkedPropertyName]--;
                    }
                    saveState();
                    updateResource(container, adversary, adversarySlotsPropertyName, instance, instanceMarkedPropertyName);
                };
                elements.push(slot);
            }

            container.replaceChildren(...elements);
        }

        function setupAdversaryActionButton(adversaryElement, adversary) {
            const actionsMenu = document.createElement("menu");
            actionsMenu.className = "actions-menu";

            const copyAction = document.createElement("li");
            copyAction.innerHTML = `<button class="menu-action">Copy</button>`;
            copyAction.title = "Copy this adversary, including all changed state";
            copyAction.onclick = function() {
                adversaryElement.dispatchEvent(adversaryCopiedEvent);
                actionsMenu.remove();
            };
            actionsMenu.appendChild(copyAction);

            const copyFromSourceAction = document.createElement("li");
            copyFromSourceAction.innerHTML = `<button class="menu-action">Copy From Source</button>`;
            copyFromSourceAction.title = "Copy this adversary from the source, ignoring all changes";
            copyFromSourceAction.onclick = function() {
                adversaryElement.dispatchEvent(adversaryCopiedFromSourceEvent);
                actionsMenu.remove();
            };
            actionsMenu.appendChild(copyFromSourceAction);

            const saveCustomAction = document.createElement("li");
            // TODO: Disable when no changes have been made?
            saveCustomAction.innerHTML = `<button class="menu-action">Save to Custom Adversaries</button>`;
            saveCustomAction.title = "Save this adversary to your custom adversaries for later use";
            saveCustomAction.onclick = function() {
                adversaryElement.dispatchEvent(adversarySavedToCustomEvent);
                actionsMenu.remove();
            };
            actionsMenu.appendChild(saveCustomAction);

            const deleteCustomAction = document.createElement("li");
            deleteCustomAction.innerHTML = `<button class="menu-action" ${adversary.source == 'Custom' ? '' : 'disabled'}>Delete from Custom Adversaries</button>`;
            deleteCustomAction.title = "Delete from your custom adversaries";
            deleteCustomAction.onclick = function() {
                adversaryElement.dispatchEvent(adversaryDeletedFromCustomEvent);
                actionsMenu.remove();
            };
            actionsMenu.appendChild(deleteCustomAction);

            const topActions = document.createElement("div");
            topActions.className = "top-actions";
            adversaryElement.appendChild(topActions);

            const addInstanceButton = document.createElement("button");
            addInstanceButton.innerText = "➕";
            addInstanceButton.title = "Add another instance of this adversary";
            addInstanceButton.onclick = function() {
                const newInstance = {
                    // TODO: Review naming, this doesn't work well if you add several, delete several, add again.
                    //       May need to parse the names to find the largest, like we do for adversary display names.
                    name: adversary.name + " #" + (adversary.instances.length + 1),
                    hpMarked: 0,
                    stressMarked: 0
                };
                if (!adversary.instances) {
                    adversary.instances = [];
                }
                adversary.instances.push(newInstance);
                saveState();
                refreshDisplay();
            };
            topActions.appendChild(addInstanceButton);

            const editButton = document.createElement("button");
            editButton.innerText = "✏️";
            editButton.title = "Edit this adversary";
            editButton.onclick = function() {
                showAdversaryEditor(adversary);
            };
            topActions.appendChild(editButton);

            const deleteButton = document.createElement("button");
            deleteButton.innerText = "🗑️";
            deleteButton.title = "Remove this adversary from the encounter";
            deleteButton.onclick = function() {
                adversaryElement.dispatchEvent(adversaryRemovedEvent);
            };
            topActions.appendChild(deleteButton);

            const actionsButton = document.createElement("button");
            actionsButton.innerText = "🎭";
            actionsButton.title = "Adversary management actions";
            actionsButton.onclick = function() {
                if (actionsMenu.parentElement) {
                    actionsMenu.remove();
                } else {
                    adversaryElement.appendChild(actionsMenu);
                }
            };
            topActions.appendChild(actionsButton);
        }

        function updateConditionsDisplay(container, instance) {
            container.innerHTML = "";

            if ((!instance.conditions || instance.conditions.length == 0) &&
                (!instance.modifications || instance.modifications.length === 0)) {
                return;
            }

            const conditionsList = document.createElement("ul");
            conditionsList.className = "conditions-list";
            container.appendChild(conditionsList);

            if (instance.conditions && instance.conditions.length > 0) {
                for (let i = 0; i < instance.conditions.length; i++) {
                    const condition = instance.conditions[i];

                    const conditionItem = document.createElement("li");
                    conditionsList.appendChild(conditionItem);

                    const conditionText = document.createElement("span");
                    conditionText.innerText = condition;
                    conditionItem.appendChild(conditionText);

                    const removeButton = document.createElement("button");
                    removeButton.className = "inline-delete";
                    removeButton.innerText = "❌";
                    removeButton.title = "Remove condition";
                    removeButton.onclick = function(event) {
                        instance.conditions = instance.conditions.filter(function(c) {
                            return c !== condition;
                        });
                        updateConditionsDisplay(container, instance);
                        saveState();
                    };
                    conditionItem.appendChild(removeButton);
                }
            }

            if (instance.modifications && instance.modifications.length > 0) {
                for (let i = 0; i < instance.modifications.length; i++) {
                    const modification = instance.modifications[i];

                    const modificationItem = document.createElement("li");
                    conditionsList.appendChild(modificationItem);

                    const modificationText = document.createElement("span");
                    modificationText.innerText = `${modification.modificationName} (${modification.propertyName} ${modification.modification})`;
                    modificationItem.appendChild(modificationText);

                    const removeButton = document.createElement("button");
                    removeButton.className = "inline-delete";
                    removeButton.innerText = "❌";
                    removeButton.title = "Remove modification";
                    removeButton.onclick = function(event) {
                        instance.modifications = instance.modifications.filter(function(m) {
                            return m !== modification;
                        });
                        updateConditionsDisplay(container, instance);
                        saveState();
                    };
                    modificationItem.appendChild(removeButton);
                }
            }
        }

        function createAdversaryElement(encounter, adversary) {
            // TODO: Allow reordering?

            let warning = "";
            if (adversary.tier > encounter.playerTier) {
                warning += ", ⚠️ above player tier";
            } else if (adversary.tier < encounter.playerTier) {
                warning += ", ⚠️ below player tier"
            }

            const adversaryDiv = document.createElement("div");
            adversaryDiv.className = "adversary";
            adversaryDiv.adversary = adversary;
            adversaryDiv.innerHTML = `<h3 title="Source: ${adversary.originalName}, ${adversary.source} ">${adversary.name}</h3>`;

            const battlePoints = getStatBlockBattlePoints(adversary.type, encounter.playerCount) * adversary.instances.length;
            const tierAndType = document.createElement("p");
            tierAndType.className = "tier";
            tierAndType.innerText = `Tier ${adversary.tier} ${adversary.type} (${battlePoints} pts${warning})`;
            adversaryDiv.appendChild(tierAndType);

            if (adversary.description) {
                const description = document.createElement("p");
                description.className =  "description";
                description.innerText = adversary.description;
                adversaryDiv.appendChild(description);
            }

            if (adversary.motivesAndTactics) {
                const motives = document.createElement("p");
                motives.className =  "motives";
                motives.innerHTML = `<span class="motivesLabel">Motives & Tactics:</span> ${adversary.motivesAndTactics}`;
                adversaryDiv.appendChild(motives);
            }

            const stats = document.createElement("p");
            stats.className = "stats";
            let thresholds = "None";
            if (Number.isInteger(adversary.majorThreshold) && Number.isInteger(adversary.severeThreshold)) {
                thresholds = `${adversary.majorThreshold}/${adversary.severeThreshold}`;
            }
            stats.innerHTML = `<span class="statLabel">Difficulty:</span> ${adversary.difficulty} <span class="divider">|</span> <span class="statLabel">Thresholds:</span> ${thresholds}`;
            if (adversary.attackDescription) {
                stats.innerHTML += `<br><span class="statLabel">ATK:</span> ${adversary.attackModifier} <span class="divider">|</span> <span class="statLabel">${adversary.attackDescription}:</span> ${adversary.attackRange} <span class="divider">|</span> ${adversary.attackDamage}`;
            }
            if (adversary.experience) {
                // TODO: <hr> is lame to style, but add some sort of divider above this (top border?)
                stats.innerHTML += `<br><span class="statLabel experiences">Experience:</span> ${adversary.experience}`;
            }
            adversaryDiv.appendChild(stats);

            if (adversary.features && adversary.features.length > 0) {
                const featuresContainer = document.createElement("details");
                featuresContainer.open = expandAllFeatures;
                featuresContainer.className = "featuresExpander";
                featuresContainer.innerHTML = `<summary>FEATURES</summary>`;
                const featuresDiv = document.createElement("div");
                featuresDiv.className = "features";
                featuresContainer.appendChild(featuresDiv);
                featuresContainer.addEventListener("toggle", handleFeaturesToggle);

                for (let i = 0; i < adversary.features.length; i++) {
                    const featureElement = document.createElement("p");
                    featureElement.className = "feature";
                    featuresDiv.appendChild(featureElement);

                    const label = document.createElement("span");
                    label.className = "featureLabel";
                    label.innerText = `${adversary.features[i].name}:`;
                    featureElement.appendChild(label);

                    const description = document.createElement("span");
                    description.innerText = ` ${adversary.features[i].text}`;
                    featureElement.appendChild(description);
                }

                adversaryDiv.appendChild(featuresContainer);
            }

            for (let i = 0; i < adversary.instances.length; i++) {
                const instance = adversary.instances[i];

                const instanceDiv = document.createElement("div");
                instanceDiv.className = "instance";
                adversaryDiv.appendChild(instanceDiv);

                const instanceName = document.createElement("input")
                instanceName.type = "text";
                instanceName.size = 30;
                instanceName.value = instance.name;
                instanceName.addEventListener("input", function(event) {
                    instance.name = event.target.value;
                    saveState();
                });
                instanceDiv.appendChild(instanceName);

                const hpDiv = document.createElement("div");
                hpDiv.className = "slotInfo";
                hpDiv.innerHTML = "HP:";
                const hpSlotsDiv = document.createElement("div");
                hpSlotsDiv.className = "slots";
                updateResource(hpSlotsDiv, adversary, "hp", instance, "hpMarked");
                hpDiv.appendChild(hpSlotsDiv);
                instanceDiv.appendChild(hpDiv);

                const stressDiv = document.createElement("div");
                stressDiv.className = "slotInfo";
                stressDiv.innerHTML = "Stress:";
                const stressSlotsDiv = document.createElement("div");
                stressSlotsDiv.className = "slots";
                updateResource(stressSlotsDiv, adversary, "stress", instance, "stressMarked");
                stressDiv.appendChild(stressSlotsDiv);
                instanceDiv.appendChild(stressDiv);

                // TODO: Parse modifications and reflect them in the stats
                const conditionsDiv = document.createElement("div");
                conditionsDiv.className = "conditions";

                updateConditionsDisplay(conditionsDiv, instance);

                const addConditionsDiv = document.createElement("div");
                addConditionsDiv.className = "add-conditions";
                const addConditionInput = document.createElement("input");
                addConditionInput.type = "text";
                addConditionInput.placeholder = "Condition Name";
                addConditionInput.setAttribute("list", "srd-conditions");
                const addConditionButton = document.createElement("button");
                addConditionButton.className = "inline-add";
                addConditionButton.innerText = "+";
                addConditionButton.title = "Add condition";
                addConditionButton.onclick = function(event) {
                    const condition = addConditionInput.value.trim();
                    if (condition && (!instance.conditions || !instance.conditions.includes(condition))) {
                        if (!instance.conditions) {
                            instance.conditions = [];
                        }
                        instance.conditions.push(condition);
                        addConditionInput.value = "";
                        updateConditionsDisplay(conditionsDiv, instance);
                        saveState();
                    }
                };
                addConditionInput.addEventListener("keyup", function(event) {
                    if (event.keyCode === 13) { // Enter key
                        event.preventDefault();
                        addConditionButton.click();
                    }
                });
                addConditionsDiv.appendChild(addConditionInput);
                addConditionsDiv.appendChild(addConditionButton);
                instanceDiv.appendChild(conditionsDiv);

                // modificationsContainer.addEventListener("toggle", handleFeaturesToggle);

                // TODO: This UI is pretty big, taking up a lot of space if
                //       there are a lot of adversaries, even if there are no modifications.
                //       Could make the input into a modal instead. Could also consider
                //       displaying modifications directly in the stats, with details
                //       on hover (but then how to delete?).
                const addModificationsDiv = document.createElement("div");
                addModificationsDiv.className = "add-modifications";
                const addModificationNameInput = document.createElement("input");
                addModificationNameInput.type = "text";
                addModificationNameInput.placeholder = "Modification Name";
                const addModificationPropertyInput = document.createElement("input");
                addModificationPropertyInput.type = "text";
                addModificationPropertyInput.placeholder = "Target Property";
                addModificationPropertyInput.setAttribute("list", "modifiable-properties");
                const addModificationValueInput = document.createElement("input");
                addModificationValueInput.type = "text";
                addModificationValueInput.placeholder = "Modifier (e.g. -2, +3, 10)";
                const addModificationButton = document.createElement("button");
                addModificationButton.className = "inline-add";
                addModificationButton.innerText = "+";
                addModificationButton.title = "Add modification";
                addModificationButton.onclick = function(event) {
                    const modificationName = addModificationNameInput.value.trim();
                    const propertyName = addModificationPropertyInput.value.trim();
                    const modificationValue = addModificationValueInput.value.trim();
                    if (modificationName && propertyName && modificationValue) {
                        if (!instance.modifications) {
                            instance.modifications = [];
                        }
                        instance.modifications.push({
                            modificationName: modificationName,
                            propertyName: propertyName,
                            modification: modificationValue
                        });
                        addModificationNameInput.value = "";
                        addModificationPropertyInput.value = "";
                        addModificationValueInput.value = "";
                        updateConditionsDisplay(conditionsDiv, instance);
                        saveState();
                    }
                };
                addModificationsDiv.appendChild(addModificationNameInput);
                addModificationsDiv.appendChild(addModificationPropertyInput);
                addModificationsDiv.appendChild(addModificationValueInput);
                addModificationsDiv.appendChild(addModificationButton);

                // TODO: Change this to a modal, triggered by an Add button that is displayed inline at the end of the list?
                const addConditionsAndModifications = document.createElement("details");
                addConditionsAndModifications.className = "modificationsExpander";
                // TODO: Should we have the same toggle all behavior for these as we have for Features?
                //       Could feel weird if there are a lot of instances...
                addConditionsAndModifications.innerHTML = `<summary>Add Conditions/Modifications</summary>`;
                addConditionsAndModifications.appendChild(addConditionsDiv);
                addConditionsAndModifications.appendChild(addModificationsDiv);
                instanceDiv.appendChild(addConditionsAndModifications);

                const instanceTopActions = document.createElement("div");
                instanceTopActions.className = "top-actions";
                instanceDiv.appendChild(instanceTopActions);

                const removeInstanceButton = document.createElement("button");
                removeInstanceButton.className = "instance-action";
                removeInstanceButton.innerText = "🗑️";
                removeInstanceButton.title = "Remove this instance of the adversary";
                removeInstanceButton.onclick = function(event) {
                    event.target.closest(".instance").remove();
                    adversary.instances = adversary.instances.filter(function(i) {
                        return i !== instance;
                    });
                    saveState();
                    refreshDisplay();
                };
                instanceTopActions.appendChild(removeInstanceButton);
            }

            setupAdversaryActionButton(adversaryDiv, adversary);

            return adversaryDiv;
        }

        function addAdversary(container, encounter, adversary, refreshBattlePoints) {
            const adversaryElement = createAdversaryElement(encounter, adversary);

            adversaryElement.addEventListener("adversaryRemoved", function(event) {
                encounter.adversaries = encounter.adversaries.filter(function(a) {
                    return a !== adversary;
                });
                container.removeChild(adversaryElement);
                refreshBattlePoints();
                saveState();
            });
            adversaryElement.addEventListener("adversaryCopied", function(event) {
                const newAdversary = JSON.parse(JSON.stringify(adversary)); // Deep copy
                newAdversary.name += " (copy)"; // TODO: Decide naming
                if (!encounter.adversaries) {
                    encounter.adversaries = [];
                }
                encounter.adversaries.push(newAdversary);
                addAdversary(container, encounter, newAdversary, refreshBattlePoints);
                saveState();
            });
            adversaryElement.addEventListener("adversaryCopiedFromSource", function(event) {
                // TODO: This is mostly a dupe of addAdversaryButton.onclick
                let newAdversary = null;
                if (adversary.source == "SRD") {
                    const sourceAdversary = srdAdversaries.find(function(a) {
                        return a.name === adversary.originalName;
                    });
                    newAdversary = convertFromSRD(sourceAdversary);
                } else if (adversary.source == "Custom" && state.custom && state.custom.adversaries) { // TODO: Case-insensive?
                    const sourceAdversary = state.custom.adversaries.find(function(a) {
                        return a.name === adversary.originalName;
                    });
                    newAdversary = JSON.parse(JSON.stringify(sourceAdversary));
                } else {
                    console.warn("Only 'SRD' and 'Custom' sources are supported");
                    return;
                }

                if (!newAdversary.instances || newAdversary.instances.length == 0) {
                    newAdversary.instances = [
                        {
                            name: newAdversary.name + " #1",
                            hpMarked: 0,
                            stressMarked: 0
                        }
                    ];
                }

                if (!encounter.adversaries) {
                    encounter.adversaries = [];
                }
                encounter.adversaries.push(newAdversary);
                addAdversary(container, encounter, newAdversary, refreshBattlePoints);
                saveState();
            });
            adversaryElement.addEventListener("adversarySavedToCustom", function(event) {
                adversary.source = "Custom";
                adversary.originalName = adversary.name; // TODO: Enforce unique names (easy here, hard if we offer import)
                const newCustomAdversary = JSON.parse(JSON.stringify(adversary));
                delete newCustomAdversary.instances;
                if (!state.custom) {
                    state.custom = {};
                }
                if (!state.custom.adversaries) {
                    state.custom.adversaries = [];
                }
                state.custom.adversaries.push(newCustomAdversary);
                saveState();
                refreshDisplay(); // To add to search
            });
            adversaryElement.addEventListener("adversaryDeletedFromCustom", function(event) {
                if (adversary.source !== "Custom") {
                    console.warn("Trying to delete a non-custom adversary from custom list");
                    return;
                }
                if (!state.custom) {
                    state.custom = {};
                }
                if (!state.custom.adversaries) {
                    state.custom.adversaries = [];
                }
                state.custom.adversaries = state.custom.adversaries.filter(function(a) {
                    return a.name !== adversary.originalName;
                });
                adversary.source = "Orphaned";
                saveState();
                refreshDisplay();
            });

            container.appendChild(adversaryElement);
            refreshBattlePoints();
        }

        function convertFromSRD(srdAdversary) {
            const thresholds = srdAdversary.thresholds.split("/");
            const adversary = {
                name: srdAdversary.name,
                originalName: srdAdversary.name,
                source: "SRD",
                tier: parseInt(srdAdversary.tier),
                type: srdAdversary.type,
                description: srdAdversary.description,
                motivesAndTactics: srdAdversary.motives_and_tactics,
                difficulty: parseInt(srdAdversary.difficulty),
                hp: parseInt(srdAdversary.hp),
                stress: parseInt(srdAdversary.stress),
                majorThreshold: parseInt(thresholds[0]),
                severeThreshold: parseInt(thresholds[1]),
                attackModifier: srdAdversary.atk,
                attackDescription: srdAdversary.attack,
                attackRange: srdAdversary.range,
                attackDamage: srdAdversary.damage,
                experience: srdAdversary.experience,
            };
            if (srdAdversary.feats && srdAdversary.feats.length > 0) {
                adversary.features = srdAdversary.feats.map(function(feat) {
                    return {
                        name: feat.name,
                        text: feat.text
                    };
                });
            }
            return adversary;
        }

        function getStatBlockBattlePoints(adversaryType, playerCount) {
            switch(adversaryType.toLowerCase()) {
                case "minion":
                    return 1 / playerCount;
                case "social":
                case "support":
                    return 1;
                case "horde":
                case "ranged":
                case "skulk":
                case "standard":
                    return 2;
                case "leader":
                    return 3;
                case "bruiser":
                    return 4;
                case "solo":
                    return 5;
                default:
                    console.warn("Unknown adversary type:", adversaryType);
                    return 0;
            }
        }

        function calculateBattlePoints(encounter)
        {
            let currentBattlePoints = 0;
            for (let j = 0; j < encounter.adversaries.length; j++) {
                const adversary = encounter.adversaries[j];
                const adversaryPoints = getStatBlockBattlePoints(adversary.type, encounter.playerCount);
                // TODO: Deal with tier differences
                currentBattlePoints += adversaryPoints * adversary.instances.length;
            }
            return currentBattlePoints;
        }

        function refreshDisplay() {
            encounterSelector.innerHTML = ""; // Clear any existing options
            for (let i = 0; i < state.encounters.length; i++) {
                const encounter = state.encounters[i];
                const option = document.createElement("option");
                option.value = i;
                // TODO: Validate various fields
                option.innerText = `${encounter.name} (Tier ${encounter.playerTier} | ${encounter.playerCount} Players)`;
                encounterSelector.appendChild(option);
            }

            const validatedEncounterIndex = Math.max(0, Math.min(selectedEncounterIndex, state.encounters.length - 1));
            console.log("validatedEncounterIndex: " + validatedEncounterIndex);
            if (encounterSelector.value !== validatedEncounterIndex) {
                encounterSelector.value = validatedEncounterIndex;
            }

            const encounterDiv = document.getElementById("encounter");
            encounterDiv.className = "encounter";
            encounterDiv.innerHTML = ""; // Clear any existing content

            const encounter = state.encounters[selectedEncounterIndex];
            if (!encounter) {
                encounterDiv.innerHTML = "<p>No encounters found. Please create a new encounter.</p>";
                return;
            }

            // Clear custom entries from search
            for (let i = adversaryDatalist.children.length - 1; i >= 0; i--) {
                const option = adversaryDatalist.children[i];
                if (!option.isSRD) {
                    option.remove();
                }
            }

            // Add custom entries
            // TODO: Sort alpha by name, mixing sources
            // TODO: This is not encounter-specific data, should it not be refreshed here?
            if (state.custom && state.custom.adversaries && state.custom.adversaries.length > 0) {
                state.custom.adversaries.forEach(function(adversary) {
                    const option = document.createElement("option");
                    option.value = adversary.name;
                    adversaryDatalist.appendChild(option);
                });
            }

            // TODO: Validate various fields
            if (!encounter.adversaries) {
                encounter.adversaries = [];
            }

            const encounterBar = document.createElement("div");
            encounterBar.className = "encounter-bar";
            encounterDiv.appendChild(encounterBar);

            // TODO: Better would be a list of adversaries to choose from,
            //       with filtering based on tier/type + text search.
            //       Rows should include name, source, battle points.
            const addAdversaryDiv = document.createElement("div");
            const srdSearch = document.createElement("input");
            srdSearch.type = "search";
            srdSearch.placeholder = "Search Adversaries";
            srdSearch.setAttribute("list", "searchable-adversaries");
            addAdversaryDiv.appendChild(srdSearch);
            encounterBar.appendChild(addAdversaryDiv);

            // TODO: Should be able to initiate edit from here? Should this move to top bar?
            const battlePointsDiv = document.createElement("div");
            battlePointsDiv.innerHTML = `<p>Target Battle Points: ${encounter.targetBattlePoints} (<span name="current-battle-points"></span> <span name="remaining-suffix"></span>) <span title="TODO: Click for summary from BUILDING BALANCED ENCOUNTERS">ℹ️</span></p>`;
            encounterBar.appendChild(battlePointsDiv);

            function refreshBattlePoints() {
                const currentBattlePoints = calculateBattlePoints(encounter);

                // Round to nearest 0.1 for display
                const remainingBattlePoints = Math.round((encounter.targetBattlePoints - currentBattlePoints) * 10) / 10;

                if (remainingBattlePoints < 0) {
                    battlePointsDiv.querySelector("[name='current-battle-points']").innerText = `⚠️ ${Math.abs(remainingBattlePoints)}`;
                    battlePointsDiv.querySelector("[name='remaining-suffix']").innerText = "over";
                } else {
                    battlePointsDiv.querySelector("[name='current-battle-points']").innerText = Math.abs(remainingBattlePoints);
                    battlePointsDiv.querySelector("[name='remaining-suffix']").innerText = "left";
                }
            }
            refreshBattlePoints();

            const fearDiv = createFearTracker(encounter);
            encounterBar.appendChild(fearDiv);

            const adversariesDiv = document.createElement("div");
            for (let j = 0; j < encounter.adversaries.length; j++) {
                addAdversary(adversariesDiv, encounter, encounter.adversaries[j], refreshBattlePoints);
            }
            encounterDiv.appendChild(adversariesDiv);

            const addAdversaryButton = document.createElement("button");
            addAdversaryButton.innerText = "Add Adversary";
            addAdversaryButton.onclick = function() {
                let selectedOption = srdSearch.value.trim();
                if (!selectedOption) {
                    // TODO: Or some "custom" type?
                    selectedOption = "Jagged Knife Bandit";
                }
                let adversary = null;
                const srdAdversary = srdAdversaries.find(function(a) {
                    return a.name.localeCompare(selectedOption, undefined, { sensitivity: 'base' }) === 0;
                });
                if (srdAdversary) {
                    adversary = convertFromSRD(srdAdversary);
                } else if (state.custom && state.custom.adversaries) {
                    adversary = state.custom.adversaries.find(function(a) {
                        return a.name.localeCompare(selectedOption, undefined, { sensitivity: 'base'}) === 0;
                    });
                    if (adversary) {
                        adversary = JSON.parse(JSON.stringify(adversary)); // Deep copy
                    }
                }
                // TODO: Else, custom with given name?

                if (adversary) {
                    if (!adversary.instances || adversary.instances.length == 0) {
                        adversary.instances = [
                            {
                                name: adversary.name + " #1",
                                hpMarked: 0,
                                stressMarked: 0
                            }
                        ];
                    }

                    if (!encounter.adversaries) {
                        encounter.adversaries = [];
                    }
                    encounter.adversaries.push(adversary);
                    addAdversary(adversariesDiv, encounter, adversary, refreshBattlePoints);
                    saveState();
                }
            };
            addAdversaryDiv.appendChild(addAdversaryButton);

            srdSearch.addEventListener("keyup", function(event) {
                if (event.keyCode === 13) { // Enter key
                    event.preventDefault();
                    addAdversaryButton.click();
                }
            });
        }

        console.log("fetching state...");
        let selectedEncounterIndex = parseInt(localStorage.getItem("selected-encounter-index"));
        if (!selectedEncounterIndex) {
            selectedEncounterIndex = 0;
        }

        let state = sampleState;
        const persistedStateJson = localStorage.getItem("encounters-state");
        if (persistedStateJson) {
            try {
                state = JSON.parse(persistedStateJson);
            } catch (error) {
                console.error("Error loading saved encounters:", error);
            }
        } else {
            console.warn("No saved encounters found, displaying sample encounters.");
        }

        const fileInput = document.getElementById("load-encounters");
        fileInput.addEventListener("change", function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        state = JSON.parse(e.target.result);
                        refreshDisplay();
                    } catch (error) {
                        console.error("Error loading encounters:", error);
                    }
                };
                reader.onerror = function(e) {
                    console.error("Error reading file:", e);
                };
                reader.readAsText(file);
            }
        });

        const saveEncountersButton = document.getElementById("save-encounters");
        saveEncountersButton.addEventListener("click", function() {
            const json = JSON.stringify(state, null, "    ");
            const blob = new Blob([json], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "encounters.json";
            a.click();
            URL.revokeObjectURL(url);
        });

        const encounterSelector = document.getElementById("current-encounter");
        encounterSelector.addEventListener("change", function() {
            selectedEncounterIndex = parseInt(encounterSelector.value);
            saveState();
            refreshDisplay();
        });

        function saveState() {
            localStorage.setItem("encounters-state", JSON.stringify(state));
            localStorage.setItem("selected-encounter-index", selectedEncounterIndex)
        }

        // TODO: This is probably a silly way to do this, we
        //       don't actually want all these DOM elements.
        //       But it's an easy way to get that autocomplete for now.
        // TODO: Also, we want a broader search option, should be able
        //       to search by source, tier, and other arbitrary property text,
        //       and allow easier browsing.
        const adversaryDatalist = document.createElement("datalist");
        adversaryDatalist.id = "searchable-adversaries";
        for (let i = 0; i < srdAdversaries.length; i++) {
            const option = document.createElement("option");
            option.value = srdAdversaries[i].name;
            option.isSRD = true;
            adversaryDatalist.appendChild(option);
        }
        document.body.appendChild(adversaryDatalist);

        refreshDisplay();
    </script>
</html>