<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Now Fear This</title>
        <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
        <link rel="manifest" href="site.webmanifest">
        <script src="statBlocks.js"></script>
        <script src="sample-encounters.js"></script>
        <style>
            :root {
                /** Palette courtesy of https://colorffy.com/dark-theme-generator?colors=825aa2-121212 */
                /** Base colors */
                --clr-dark-a0: #000000;
                --clr-light-a0: #ffffff;

                /** Theme primary colors */
                --clr-primary-a0: #825aa2;
                --clr-primary-a10: #906bac;
                --clr-primary-a20: #9e7db6;
                --clr-primary-a30: #ac8fc1;
                --clr-primary-a40: #b9a1cb;
                --clr-primary-a50: #c7b3d5;

                /** Theme surface colors */
                --clr-surface-a0: #121212;
                --clr-surface-a10: #282828;
                --clr-surface-a20: #3f3f3f;
                --clr-surface-a30: #575757;
                --clr-surface-a40: #717171;
                --clr-surface-a50: #8b8b8b;

                /** Theme tonal surface colors */
                --clr-surface-tonal-a0: #1c191f;
                --clr-surface-tonal-a10: #312e34;
                --clr-surface-tonal-a20: #47444a;
                --clr-surface-tonal-a30: #5f5c61;
                --clr-surface-tonal-a40: #777579;
                --clr-surface-tonal-a50: #918f93;

                --body-bg-color: var(--clr-surface-a0);
                --text-color: var(--clr-light-a0);
                --statBlock-bg-color: var(--clr-surface-a10);
                --stats-bg-color: var(--clr-surface-a20);
                --statBlock-text-color: var(--text-color);
                --header-text-color: var(--clr-primary-a50);

                --button-bg-color: var(--clr-primary-a20);
                --button-bg-hover-color: var(--clr-primary-a10);
                --button-bg-active-color: var(--clr-primary-a0);
                --button-text-color: var(--clr-dark-a0);
            }
            @media (max-width: 1100px) {
                :root {
                    font-size: 36px;
                }
                /* Apparently none of this input element sizing works the same on Safari */
                button, select, input, textarea {
                    font-size: inherit;
                }
                input[type='checkbox'] {
                    width: 1em;
                    height: 1em;
                }
            }
            body {
                background-color: var(--body-bg-color);
                color: var(--text-color);
                margin: 0px;
            }
            #copyright, #repo-info {
                font-size: smaller;
                margin-top: 10px;
                max-width: 50em;

                a {
                    color: var(--clr-primary-a50);
                }
                a:visited {
                    color: var(--clr-primary-a30);
                }
            }

            .load-button input {
                /* Hide the file input element and style its label as a button */
                display: none;
            }
            .load-button label {
                display: block;
                user-select: none;
            }
            button, .load-button label {
                padding: 5px;
                color: var(--button-text-color);
                background-color: var(--button-bg-color);
                border: 0px;
            }
            button {
                border-radius: 8px;
            }
            button:hover, .load-button label:hover {
                background-color: var(--button-bg-hover-color);
            }
            button:active, .load-button label:active {
                background-color: var(--button-bg-active-color);
            }
            button:disabled {
                background-color: var(--clr-surface-a50);
                /* opacity: 0.7; */
            }

            button.child-action {
                background-color: var(--clr-surface-tonal-a0);
                &:hover {
                    background-color: var(--clr-surface-tonal-a10);
                }
                &:active {
                    background-color: var(--clr-surface-tonal-a20);
                }
                &:disabled {
                    background-color: var(--clr-surface-tonal-a30);
                    opacity: 0.7;
                }
            }

            button.subtle {
                background-color: transparent;
                border-radius: 4px;
                margin: 0px;
                padding: 2px;
                &:hover {
                    background-color: var(--clr-surface-a20);
                }
                &:active {
                    background-color: var(--clr-surface-a30);
                }
            }

            #top-bar {
                display: flex;
                align-items: center;
                justify-content: space-between;
                top: 0px;
                left: 0px;
                right: 0px;
                padding: 3px 10px;
                background-color: var(--clr-surface-a10);
                border-bottom: 1px solid var(--clr-surface-a20);

                #fear-tracker {
                    display: inline-block;
                }
            }
            button#add-encounter {
                border-radius: 4px;
                padding: 3px;
            }

            .below-top-bar {
                margin: 10px
            }

            .encounter-bar p {
                margin: 0px;
            }
            .encounter-bar > * {
                display: inline-block;
                margin-right: 10px;
            }

            .inactive {
                opacity: 0.3;
            }

            .statBlock, .no-encounters {
                position: relative; /* For action button */
                display: inline-block;
                vertical-align: top;
                /*
                    22em is empirical width needed to fit full ATK line for "Volcanic Dragon: Ashen Tyrant".
                    Longest ATK line in SRD is "Fallen Warlord: Undefeated Champion",
                    which requires 27em (at 22em, both ATK and Experience lines overflow).
                    27em feels way too wide. Trying 23em, which is enough to stop Fallen Warlord's
                    Experience line from overflowing.
                */
                width: 23em;
                border-radius: 5px;
                margin-right: 5px;
                margin-top: 5px;
                padding: 5px 10px;
                background-color: var(--statBlock-bg-color);
                color: var(--statBlock-text-color);
            }
            @media (max-width: 1100px) {
                .statBlock {
                    width: 90%;
                    left: 50%;
                    transform: translateX(-50%);
                }
            }
            .statBlock h3 { /* h2 size closer to SRD styling, but causes overlap with buttons */
                margin: 8px 0px;
                color: var(--header-text-color);
                text-transform: uppercase;
            }
            #conditions-editor h3 {
                margin: 0px;
                margin-bottom: 10px;
                color: var(--header-text-color);
            }
            .statBlock p {
                margin: 2px 0px;
            }
            .statBlock .source {
                font-style: italic;
                font-size: smaller;
            }
            .statBlock .tier {
                font-style: italic;
                font-weight: bold;
            }
            .statBlock .description {
                font-size: smaller;
                font-style: italic;
            }
            .statBlock .motives {
                font-size: smaller;
            }
            .statBlock .stats {
                background-color: var(--stats-bg-color);
                border-top: 1px solid var(--clr-surface-a0);
                border-bottom: 1px solid var(--clr-surface-a0);
                padding: 5px;
            }
            .statBlock .statLabel, .statBlock .motivesLabel {
                font-weight: bold;
            }
            .statBlock .experiences {
                border-top: 1px dotted var(--clr-surface-a50);
                margin-top: 2px;
                padding-top: 2px;
            }
            .statBlock .divider {
                margin: 0px 3px;
                font-weight: bold;
            }
            .features {
                margin-left: 0.75em;
            }
            .featuresExpander summary {
                font-weight: bold;
            }
            .features .feature {
                text-indent: -0.75em
            }
            .featureLabel {
                font-style: italic;
                font-weight: bold;
            }

            .instance {
                position: relative; /* For action button */
                margin-top: 10px;
                background-color: var(--stats-bg-color);
                border: 1px solid var(--stats-bg-color);
                border-radius: 3px;
                padding: 4px;

                &.vulnerable {
                    border-color: orange;
                }
                &.defeated {
                    opacity: 0.5;
                }
            }
            .instance h4 {
                margin: 0px;
            }
            .add-conditions, .add-modifications {
                margin: 5px 0px;
            }

            .slots {
                display: inline-block
            }

            .conditions {
                margin-top: 5px
            }
            ul.conditions-list {
                list-style: none;
                display: inline;
                padding: 0px;
                font-size: smaller;

                li {
                    display: inline-block;
                    background-color: var(--clr-surface-a40);
                    border-radius: 3px;
                    margin-right: 5px;
                    margin-bottom: 5px;
                    padding: 2px;
                }
            }
            button.inline-delete {
                background-color: transparent;
                color: var(--clr-primary-a50);
                border: 0px;
                border-radius: 3px;
                padding: 0px;
                margin-left: 5px;
                font-size: smaller;
                &:hover {
                    background-color: var(--clr-primary-a30);
                }
                &:active {
                    background-color: var(--clr-primary-a10);
                }
            }

            .countdowns-container {
                font-size: smaller;
                .countdowns {
                    list-style: none;
                    padding: 0px;
                    margin: 0px;
                    /* margin-top: 4px;
                    &:empty {
                        margin-top: 0px;
                    } */
                    li {
                        margin-top: 4px;
                    }
                }
                button.add-countdown-button {
                    font-size: smaller;
                }
            }

            button.inline-add {
                border: 0px;
                border-radius: 2px;
                padding: 3px 4px;
            }
            .add-modifications, .add-conditions {
                padding: 10px;
            }

            button.add-conditions-button {
                font-size: smaller;
            }

            button.action {
                float: right;
            }
            .top-actions {
                position: absolute;
                right: 5px;
                top: 5px; /* Make sure to update menu positioning in actionsButton click handler if this changes */

                button {
                    padding: 2px;
                    margin-left: 3px;
                    border-radius: 4px;
                    font-size: smaller;
                }
            }

            .actions-menu {
                z-index: 999; /* Above most things, below the overlay */
                position: absolute;
                right: 5px;
                margin: 0px;
                padding: 0px;
                list-style-type: none;

                button, div {
                    border-radius: 0px;
                    width: 100%;
                    text-align: left;

                    /* Force button-likes in the menu to have the same font/size.
                    This does not perfectly match the default for buttons. */
                    font-family: serif;
                    font-size: inherit;
                }
            }

            .battle-point-advice {
                font-size: smaller;
            }

            .overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;

                &#editor-overlay {
                    z-index: 1000; /* Ensure it is above other content */
                    background-color: rgba(0, 0, 0, 0.5);
                    backdrop-filter:blur(3px);
                }
                &#active-menu-overlay {
                    z-index: 998; /* Ensure it is above most content, but below the menu */
                    background-color: rgba(0, 0, 0, 0.0); /* Transparent */
                }
            }

            .editor {
                position: absolute;
                z-index: 1001; /* Ensure it is above the overlay */
                width: 27em;
                top: 50px;
                left: 50%;
                transform: translateX(-50%);
                background-color: var(--clr-surface-tonal-a10);
                padding: 20px;
                border-radius: 10px;
                box-shadow: 10px 10px 10px black;

                .feature {
                    position: relative; /* For top action bar */
                }
            }
            @media (max-width: 1100px) {
                .editor {
                    width: 90%;
                }
            }

            textarea {
                width: 100%;
            }

            #search-container {
                background-color: var(--clr-surface-a10);
                padding: 5px;
                margin: 5px 0px;
                border-radius: 5px;
                max-width: 48em; /* 44em looks good, 48em is about the width of two statblocks */

                #battle-points {
                    margin-top: 4px;
                    padding: 5px;
                    font-weight: bold;
                    color: var(--text-color);
                }
            }
            #simple-search, .browsing-filters {
                display: flex;
                flex-wrap: wrap;
                gap: 4px;
            }
            #simple-search-input {
                flex-grow: 1;
            }

            #browsing {
                position: relative;
                width: fit-content;
            }
            #browsing-search {
                flex-grow: 1;
            }
            .results th, .results td {
                border: 1px solid var(--clr-surface-a0);
                padding: 5px 10px;
                border-top-width: 0;
                border-left-width: 0;
            }
            .results table {
                overflow-y: auto;
                height: 15em;
                display: block;
            }
            .results td.nowrap {
                white-space: nowrap;
            }
            .results th {
                position: sticky;
                top: 0;
                vertical-align: bottom;
                background: var(--clr-surface-a20); /* Need a background to avoid scrolled rows from showing through */
            }

            @media (max-width: 1100px) {
                button {
                    padding-left: 0.5em !important;
                    padding-right: 0.5em !important;
                }
            }

            /* Keep this last */
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body>
        <datalist id="srd-conditions">
            <option>Hidden</option>
            <option>Restrained</option>
            <option>Vulnerable</option>
            <option>Asleep</option>
            <option>Stunned</option>
            <option>Silenced</option>
            <option>Corroded</option>
            <option>Ranger's Focus</option>
            <option>Cloaked</option>
            <option>Dizzied</option>
            <option>Enveloped</option>
        </datalist>

        <datalist id="modifiable-properties">
            <option>difficulty</option>
            <option>majorThreshold</option>
            <option>severeThreshold</option>
        </datalist>

        <datalist id="srd-environment-types">
            <option>Event</option>
            <option>Exploration</option>
            <option>Social</option>
            <option>Traversal</option>
        </datalist>

        <datalist id="searchable-campaigns">
        </datalist>

        <datalist id="searchable-statBlocks">
        </datalist>

        <div id="top-bar">
            <div>
                <button id="add-encounter" title="Create New Encounter">‚ûï Create New Encounter</button>
                <select id="current-campaign" title="Choose a campaign"></select>
                <select id="current-encounter" title="Choose an encounter"></select>
                <div id="fear-tracker">
                    <button id="use-fear" title="Use 1 Fear">-</button>
                    <span id="fear-value">
                        <span class="fear-icon">üíÄ</span>
                        <span class="fear-icon">üíÄ</span>
                        <span class="fear-icon">üíÄ</span>
                        <span class="fear-icon">üíÄ</span>
                        <span class="fear-icon">üíÄ</span>
                        <span class="fear-icon">üíÄ</span>
                        <span class="fear-icon">üíÄ</span>
                        <span class="fear-icon">üíÄ</span>
                        <span class="fear-icon">üíÄ</span>
                        <span class="fear-icon">üíÄ</span>
                        <span class="fear-icon">üíÄ</span>
                        <span class="fear-icon">üíÄ</span>
                    </span>
                    <button id="gain-fear" title="Gain 1 Fear (max 12)">+</button>
                </div>
            </div>
            <div>
                <button id="toggle-encounter-menu" class="subtle" title="Encounter Actions">‚öôÔ∏è</button>
                <menu id="encounter-menu" class="actions-menu hidden">
                    <li><button id="edit-encounter">‚úèÔ∏è Edit Encounter</button></li>
                    <li><button id="delete-encounter">üóëÔ∏è Delete Encounter</button></li>
                    <li><button id="save-encounters">üíæ Download Encounters JSON</button></li>
                    <li><div id="load-encounters-container" class="load-button">
                        <label for="load-encounters" title="Load Encounters (replaces existing encounters)">üìÇ Load Encounters JSON</label>
                        <input type="file" id="load-encounters" accept=".json" />
                    </div></li>
                    <li><button id="export-custom">‚úàÔ∏è Export Custom JSON</button></li>
                    <li><div id="import-custom-container" class="load-button">
                        <label for="import-custom">üéÅ Import Custom JSON</label>
                        <input type="file" id="import-custom" accept=".json" />
                    </div></li>
                </menu>
            </div>
        </div>

        <div id="editor-overlay" class="hidden overlay"></div>
        <div id="active-menu-overlay" class="hidden overlay"></div>

        <!-- Could remove overlay and instead use <dialog> instead of these divs,
             but Safari doesn't support closedBy=any so it wouldn't really have the
             behavior I want. Plus it's more styling work due to <dialog>'s use of
             the canvastext color. Would need to unset a lot of default [popover]
             styling.

             Another option might be to use <dialog>, but non-modally, with a custom
             overlay, and drive it with the Popover API? This would be fine if
             fixed or viewport-relative positioning was always ok, since Firefox
             doesn't yet support anchor positioning. But viewport-relative
             positioning is not always ok.
        -->
        <div id="encounter-editor" class="editor hidden">
            <form id="encounter-form">
                <label>Name:
                    <input type="text" id="encounter-name" required />
                </label>
                <br>
                <label>Campaign:
                    <!-- autocomplete=off to restrict dataset to those explicitly in the list -->
                    <input
                        type="text"
                        id="encounter-campaign-name"
                        placeholder="(optional)"
                        autocomplete="off"
                        list="searchable-campaigns" />
                </label>
                <br>
                <label>Tier:
                    <input type="number" id="encounter-tier" min="1" max="4" value="1" required />
                </label>
                <label>Player Count:
                    <input type="number" id="encounter-player-count" min="1" max="20" value="4" required />
                </label>
                <br>
                <label>Target Battle Points:
                    <input type="number" id="encounter-target-battle-points" min="1" max="99" value="14" required />
                </label>
                <span id="encounter-recommended-battle-points"></span>
                <div class="battle-point-advice">
                    <p>When planning a battle, start with <strong>[(3 x the number of PCs in combat) + 2]</strong> Battle Points and make the following adjustments:</p>
                    <ul>
                        <li><strong>-1</strong> for an easier or shorter fight</li>
                        <li><strong>-2</strong> if you're using 2 or more Solo adversaries</li>
                        <li><strong>-2</strong> if you add +1d4 (or a static +2) to all adversaries' damage rolls</li>
                        <li><strong>+1</strong> if you choose an adversary from a lower tier</li>
                        <li><strong>+1</strong> if you don't include any Bruisers, Hordes, Leaders, or Solos</li>
                        <li><strong>+2</strong> for a harder or longer fight</li>
                    </ul>
                </div>
                <button type="button" id="cancel-encounter-edit">Cancel</button>
                <button type="submit">Save Encounter</button>
            </form>
        </div>

        <div id="statBlock-editor" class="editor hidden">
            <form id="statBlock-form">
                <fieldset>
                    <legend>Basics</legend>
                    <label>Name:
                        <input type="text" id="statBlock-name" size="30" required />
                    </label>
                    <br>
                    <label>Tier:
                        <input type="number" id="statBlock-tier" min="1" max="4" value="1" required />
                    </label>
                    <span class="statBlock-editor-adversary">
                        <label>Type:
                            <select id="adversary-type" list="srd-adversary-types">
                                <option value="">(none)</option>
                                <option>Bruiser</option>
                                <option>Horde</option>
                                <option>Leader</option>
                                <option>Minion</option>
                                <option>Ranged</option>
                                <option>Skulk</option>
                                <option>Social</option>
                                <option>Solo</option>
                                <option>Standard</option>
                                <option>Support</option>
                            </select>
                        </label>
                        <label>
                            <input type="number" id="adversary-count-per-hp" min="1" max="20" value="1" />
                            /HP
                        </label>
                    </span>
                    <span class="statBlock-editor-environment">
                        <label>Type:
                            <input type="text" id="environment-type" list="srd-environment-types" />
                        </label>
                    </span>
                    <br>
                    <label>Description:
                        <textarea id="statBlock-description" rows="3"></textarea>
                    </label>
                    <div class="statBlock-editor-adversary">
                        <label>Motives & Tactics:
                            <textarea id="adversary-motives" rows="2"></textarea>
                        </label>
                    </div>
                    <div class="statBlock-editor-environment">
                        <label>Impulses:
                            <textarea id="environment-impulses" rows="2"></textarea>
                        </label>
                    </div>
                </fieldset>
                <fieldset>
                    <legend>Stats</legend>
                    <label>Difficulty:
                        <input type="number" id="statBlock-difficulty" min="0" max="40" value="12" required />
                    </label>
                    <div class="statBlock-editor-adversary">
                        <label>Major Threshold:
                            <input type="number" id="adversary-major-threshold" min="0" max="20" value="8" />
                        </label>
                        /
                        <label>Severe Threshold:
                            <input type="number" id="adversary-severe-threshold" min="0" max="20" value="14" />
                        </label>
                        <br>
                        <label>HP:
                            <input type="number" id="adversary-hp" min="1" max="40" value="5" />
                        </label>
                        <label>Stress:
                            <input type="number" id="adversary-stress" min="0" max="40" value="2" />
                        </label>
                        <br>
                        <label>Experience:
                            <input type="text" id="adversary-experience" />
                        </label>
                    </div>
                    <div class="statBlock-editor-environment">
                        <label>Potential Adversaries:
                            <textarea id="environment-potential-adversaries" rows="3"></textarea>
                        </label>
                    </div>
                </fieldset>
                <fieldset class="statBlock-editor-adversary">
                    <legend>Attack</legend>
                    <label>Modifier:
                        <input type="text" id="adversary-attack-modifier" size="5" placeholder="e.g. +3" />
                    </label>
                    <label>Description:
                        <input type="text" id="adversary-attack-description" placeholder="e.g. Mace" />
                    </label>
                    <br>
                    <label>Range:
                        <select id="adversary-attack-range">
                            <option>Melee</option>
                            <option>Very Close</option>
                            <option>Close</option>
                            <option>Far</option>
                        </select>
                    </label>
                    <label>Damage:
                        <input type="text" id="adversary-attack-damage" size="12" placeholder="e.g. 1d10+3 phy" />
                    </label>
                </fieldset>
                <fieldset>
                    <legend>Features</legend>
                    <button type="button" id="add-feature">+ Add Feature</button>
                    <div id="statBlock-features">
                        <template id="feature-editor-template">
                            <div class="feature">
                                <label>Name:
                                    <input type="text" class="statBlock-feature-name" size="30" />
                                </label>
                                <br />
                                <label>Description:
                                    <textarea type="text" class="statBlock-feature-text" rows="4"></textarea>
                                </label>
                            </div>
                        </template>
                    </div>
                </fieldset>
                <button type="button" id="cancel-statBlock-edit">Cancel</button>
                <button type="submit">Save</button>
            </form>
        </div>

        <div id="conditions-editor" class="editor hidden"> <!-- TODO: Position over statBlock instead? -->
            <h3 class="instance-name"></h3>
            <div class="conditions">
                <ul class="conditions-list">
                    <!-- TODO: Should this live here or elsewhere, considering it's
                               shared with statblock? -->
                    <template id="condition-template">
                        <li>
                            <span></span>
                            <button class="inline-delete" title="Remove condition">‚ùå</button>
                        </li>
                    </template>
                </ul>
            </div>
            <div class="add-conditions">
                <input type="text" placeholder="Condition Name" list="srd-conditions" id="condition-name">
                <button class="inline-add" id="add-condition">‚ûï Add Condition</button>
            </div>
            <div class="add-modifications">
                <input type="text" placeholder="Modification Name" id="modification-name">
                <input type="text" placeholder="Target Property" list="modifiable-properties" id="modification-property">
                <input type="text" placeholder="Modifier (e.g. -2, +3, 10)" id="modification-value">
                <button class="inline-add" id="add-modification">‚ûï Add Modification</button>
            </div>
            <button id="done-adding-conditions">Close</button>
        </div>

        <div class="below-top-bar">

            <div id="search-container">
                <div id="simple-search" class="hidden">
                    <button id="show-full-search" class="subtle" title="Expand to Full Search">‚è¨</button>
                    <input
                        id="simple-search-input"
                        type="search"
                        placeholder="Search Adversaries & Environments"
                        list="searchable-statBlocks" />
                    <button id="simple-search-add-button">‚ûï Add</button>
                </div>

                <div id="browsing">
                    <!-- TODO: Allow keyboard navigation of table and adding of statBlocks directly from search input?-->
                    <div class="browsing-filters">
                        <!-- TODO: There is some new styling bug causing search to jump when toggling this -->
                        <button id="hide-full-search" class="subtle" title="Collapse to Simple Search">‚è´</button>
                        <input id="browsing-search" type="text" placeholder="Search Adversaries & Environments" />
                        <select id="browsing-source">
                            <option value="">Any source</option>
                            <option>SRD</option>
                            <option>Custom</option>
                            <option>Extra</option>
                        </select>
                        <select id="browsing-tier">
                            <option value="">Any tier</option>
                            <option value="1">Tier 1</option>
                            <option value="2">Tier 2</option>
                            <option value="3">Tier 3</option>
                            <option value="4">Tier 4</option>
                        </select>
                        <select id="browsing-category">
                            <option value="">Any category</option>
                            <option value="Adversary">Adversaries</option>
                            <option value="Environment">Environments</option>
                        </select>
                        <select id="browsing-type">
                            <option value="">Any type</option>
                            <!-- Hide group when specific categories selected? Would require resetting type if category changes, sometimes -->
                            <optgroup label="Adversaries">
                                <option>Bruiser</option>
                                <option>Horde</option>
                                <option>Leader</option>
                                <option>Minion</option>
                                <option>Ranged</option>
                                <option>Skulk</option>
                                <option>Social</option>
                                <option>Solo</option>
                                <option>Standard</option>
                                <option>Support</option>
                            </optgroup>
                            <optgroup label="Environments">
                                <option>Event</option>
                                <option>Exploration</option>
                                <option>Social</option>
                                <option>Traversal</option>
                            </optgroup>
                        </select>
                        <button id="browsing-reset-filters">Reset Filters</button>
                    </div>
                    <div class="results">
                        <table>
                            <thead>
                                <tr>
                                    <th scope="col"></th>
                                    <th scope="col">Name</th>
                                    <!-- TODO: Make some columns disappear when insufficient width -->
                                    <th scope="col">Type</th>
                                    <th scope="col">Points</th>
                                    <th scope="col">Description</th>
                                </tr>
                            </thead>
                            <tbody>
                            </tbody>
                            <template id="results-row-template">
                                <tr>
                                    <td class="nowrap"><button>‚ûï Add</button></td>
                                    <td></td>
                                    <td class="nowrap"></td>
                                    <td class="nowrap"></td>
                                    <td></td>
                                </tr>
                            </template>
                        </table>
                    </div>
                </div>

                <button id="battle-points" class="subtle">
                    Target Battle Points: <span id="target-battle-points"></span> (<span id="current-battle-points"></span> <span id="current-battle-points-suffix"></span>)
                </button>
            </div>

            <template id="countdown-template">
                <li class="countdown">
                    <input type="text" size="30" class="countdown-name" placeholder="Countdown Name" title="Countdown name">
                    <input type="number" min="0" max="99" class="countdown-value" title="Countdown value, effect triggers at 0">
                    <button class="inline-delete" title="Remove countdown">‚ùå</button>
                </li>
            </template>

            <template id="countdowns-template">
                <div class="countdowns-container">
                    <ul class="countdowns">
                    </ul>
                </div>
            </template>

            <div id="encounter"></div>

            <div id="repo-info">
                <p><em><a href="https://nowfearthis.app">Now Fear This</a></em> is <a href="https://codeberg.org/sandyarmstrong/nowfearthis">free and open source</a> and works entirely offline. Please <a href="https://codeberg.org/sandyarmstrong/nowfearthis/issues">report any bugs or feature requests</a>.</p>
            </div>

            <div id="copyright">
                <p>This project includes materials from the Daggerheart System Reference Document 1.0,
                    ¬© Critical Role, LLC. under the terms of the Darrington Press Community Gaming (DPCGL) License.
                    More information can be found at <a href="https://www.daggerheart.com">https://www.daggerheart.com</a>.
                <p>Site favicon courtesy of <a href="https://github.com/twitter/twemoji/blob/master/LICENSE-GRAPHICS">twemoji</a>.</p>
            </div>

        </div>
    </body>

    <script>
        const statBlockRemovedEvent = new Event("statBlockRemoved");
        const statBlockCopiedEvent = new Event("statBlockCopied");
        const statBlockCopiedFromSourceEvent = new Event("statBlockCopiedFromSource");
        const statBlockSavedToCustomEvent = new Event("statBlockSavedToCustom");
        const statBlockDeletedFromCustomEvent = new Event("statBlockDeletedFromCustom");

        const activeMenuOverlay = document.getElementById("active-menu-overlay");
        const editorOverlay = document.getElementById("editor-overlay");
        const encounterEditor = document.getElementById("encounter-editor");
        const statBlockEditor = document.getElementById("statBlock-editor");
        const conditionsEditor = document.getElementById("conditions-editor");

        const simpleSearch = document.getElementById("simple-search");
        const simpleSearchInput = document.getElementById("simple-search-input");
        const fullSearch = document.getElementById("browsing");
        const fullSearchInput = document.getElementById("browsing-search");
        const fullSearchSource = document.getElementById("browsing-source");
        const battlePointsDisplay = document.getElementById("battle-points");

        const resultsRowTemplate = document.getElementById("results-row-template");
        const conditionTemplate = document.getElementById("condition-template");
        const featureEditorTemplate = document.getElementById("feature-editor-template");

        const extraStatBlocks = [
            {
                "name": "Blank Adversary",
                "originalName": "Blank Adversary",
                "source": "Extra",
                "tier": 1,
                "category": "Adversary",
                "description": "",
                "difficulty": 10,
                "type": "Standard"
            },
            {
                "name": "Blank Environment",
                "originalName": "Blank Environment",
                "source": "Extra",
                "tier": 1,
                "category": "Environment",
                "description": "",
                "difficulty": 10,
                "type": "Event"
            },
            {
                "name": "Countdowns",
                "originalName": "Countdowns",
                "source": "Extra",
                "tier": 1,
                "category": "Environment",
                "description": "Add countdowns here that are independent of any other adversary or environment. Countdown effects trigger at 0.",
                "difficulty": 10,
                "type": "Event",
                "features": [
                    {
                        "name": "Dynamic Advancement",
                        "text": "Create a Progress countdown and a Consequence countdown. Have players make action rolls to determine results, following this table:\n\nFailure+Fear | Progress: 0 | Consequence: 3\nFailure+Hope | Progress: 0 | Consequence: 2\nSuccess+Fear | Progress: 1 | Consequence: 1\nSuccess+Hope | Progress: 2 | Consequence: 0\nCrit Success | Progress: 3 | Consequence: 0"
                    }
                ]
            },
        ];

        function createElement(tagName, className = null, innerText = null) {
            const element = document.createElement(tagName);
            if (className) {
                element.className = className;
            }
            if (innerText) {
                element.innerText = innerText;
            }
            return element;
        }

        function createElementWithInnerHTML(tagName, className, innerHTML) {
            const element = document.createElement(tagName);
            if (className) {
                element.className = className;
            }
            if (innerHTML) {
                element.innerHTML = innerHTML;
            }
            return element;
        }

        function stringBaseCompare(a, b) {
            return a.localeCompare(b, "en", { sensitivity: "base" });
        }

        activeMenuOverlay.addEventListener("click", function() {
            document.querySelectorAll(".actions-menu").forEach(function(menu) {
                if (!menu.classList.contains("hidden")) {
                    menu.classList.add("hidden");
                }
            });
            activeMenuOverlay.classList.add("hidden");
        });

        document.getElementById("editor-overlay").addEventListener("click", function() {
            if (!statBlockEditor.classList.contains("hidden")) {
                hideStatBlockEditor();
            } else if (!encounterEditor.classList.contains("hidden")) {
                hideEncounterEditor();
            } else if (!conditionsEditor.classList.contains("hidden")) {
                hideConditionsEditor();
            }
        });

        function hideEncounterMenu() {
            const encounterMenu = document.getElementById("encounter-menu");
            encounterMenu.classList.add("hidden");
            activeMenuOverlay.classList.add("hidden");
        }

        document.getElementById("toggle-encounter-menu").addEventListener("click", function(event) {
            const encounterMenu = document.getElementById("encounter-menu");
            if (encounterMenu.classList.contains("hidden")) {
                const rect = event.target.getBoundingClientRect();
                encounterMenu.style.top = `${rect.bottom + window.scrollY}px`;
                encounterMenu.classList.remove("hidden");
                activeMenuOverlay.classList.remove("hidden");
            } else {
                hideEncounterMenu();
            }
        });

        function hideStatBlockEditor() {
            const statBlock = statBlockEditor.statBlock;
            statBlockEditor.statBlock = undefined;
            statBlockEditor.classList.add("hidden");
            editorOverlay.classList.add("hidden");
            if (statBlock) {
                const statBlockElements = Array.from(document.querySelectorAll(".statBlock"));
                for (let i = 0; i < statBlockElements.length; i++) {
                    if (statBlockElements[i].statBlock == statBlock) {
                        statBlockElements[i].scrollIntoView({ behavior: "instant", block: "nearest" });
                    }
                }
            }
        }

        statBlockEditor.addEventListener("keyup", function(event) {
            if (event.keyCode === 27) { // Escape key
                hideStatBlockEditor();
            }
        });

        function createFeatureEditorElement(feature, idSuffix)  {
            const featureElement = featureEditorTemplate.content.cloneNode(true).children[0];
            featureElement.querySelector(".statBlock-feature-name").value = feature?.name ?? "";
            featureElement.querySelector(".statBlock-feature-text").value = feature?.text ?? "";

            const instanceTopActions = createElement("div", "top-actions");
            featureElement.appendChild(instanceTopActions);

            // TODO: Could put this and Name in a flex container instead, to avoid overlap when super narrow
            const removeFeatureButton = createElement("button", "child-action", "üóëÔ∏è");
            removeFeatureButton.type = "button";
            removeFeatureButton.title = "Remove this feature";
            removeFeatureButton.onclick = function(event) {
                event.target.closest(".feature").remove();
                // Editor will handle saving state and refreshing display
            };
            instanceTopActions.appendChild(removeFeatureButton);

            return featureElement;
        }

        function refreshCounterPerHpDisplay() {
            const countPerHpInput = statBlockEditor.querySelector("#adversary-count-per-hp");
            if (statBlockEditor.querySelector("#adversary-type").value === "Horde") {
                countPerHpInput.parentElement.classList.remove("hidden");
            } else {
                countPerHpInput.parentElement.classList.add("hidden");
                countPerHpInput.value = 1;
            }
        }

        statBlockEditor.querySelector("#adversary-type").addEventListener("change", function() {
            refreshCounterPerHpDisplay();
        });

        function showStatBlockEditor(statBlock) {
            // Basics
            statBlockEditor.querySelector("#statBlock-name").value = statBlock.name;
            statBlockEditor.querySelector("#statBlock-tier").value = statBlock.tier;
            statBlockEditor.querySelector("#statBlock-description").value = statBlock.description || "";
            statBlockEditor.querySelector("#adversary-motives").value = statBlock.motivesAndTactics || "";
            statBlockEditor.querySelector("#environment-impulses").value = statBlock.impulses || "";

            if (statBlock.category == "Adversary") {
                statBlockEditor.querySelector("#adversary-type").value = statBlock.type;
                statBlockEditor.querySelectorAll(".statBlock-editor-adversary").forEach(function(element) {
                    element.classList.remove("hidden");
                });
                statBlockEditor.querySelectorAll(".statBlock-editor-environment").forEach(function(element) {
                    element.classList.add("hidden");
                });
            } else if (statBlock.category == "Environment") {
                statBlockEditor.querySelector("#environment-type").value = statBlock.type;
                statBlockEditor.querySelectorAll(".statBlock-editor-adversary").forEach(function(element) {
                    element.classList.add("hidden");
                });
                statBlockEditor.querySelectorAll(".statBlock-editor-environment").forEach(function(element) {
                    element.classList.remove("hidden");
                });
            }

            statBlockEditor.querySelector("#adversary-count-per-hp").value = statBlock.countPerHp || 1;
            refreshCounterPerHpDisplay();

            // Stats
            statBlockEditor.querySelector("#statBlock-difficulty").value = statBlock.difficulty;
            statBlockEditor.querySelector("#adversary-major-threshold").value = statBlock.majorThreshold;
            statBlockEditor.querySelector("#adversary-severe-threshold").value = statBlock.severeThreshold;
            statBlockEditor.querySelector("#adversary-hp").value = statBlock.hp;
            statBlockEditor.querySelector("#adversary-stress").value = statBlock.stress;
            statBlockEditor.querySelector("#adversary-experience").value = statBlock.experience || "";
            statBlockEditor.querySelector("#environment-potential-adversaries").value = statBlock.potentialAdversaries || "";

            // Attack
            statBlockEditor.querySelector("#adversary-attack-modifier").value = statBlock.attackModifier || "";
            statBlockEditor.querySelector("#adversary-attack-description").value = statBlock.attackDescription || "";
            statBlockEditor.querySelector("#adversary-attack-range").value = statBlock.attackRange || ""; // TODO: Case mangling as needed
            statBlockEditor.querySelector("#adversary-attack-damage").value = statBlock.attackDamage || "";

            // Features
            const featuresContainer = statBlockEditor.querySelector("#statBlock-features");
            featuresContainer.innerHTML = ""; // Clear any existing children
            if (statBlock.features && statBlock.features.length > 0) {
                for (let i = 0; i < statBlock.features.length; i++) {
                    const feature = statBlock.features[i];
                    const featureElement = createFeatureEditorElement(feature, i);
                    featuresContainer.appendChild(featureElement);
                }
            }

            editorOverlay.classList.remove("hidden");
            statBlockEditor.classList.remove("hidden");
            statBlockEditor.statBlock = statBlock;
            statBlockEditor.querySelector("#statBlock-name").select();
            window.scrollTo(0, 0);
        }

        document.querySelector("#add-feature").addEventListener("click", function() {
            const featureContainer = statBlockEditor.querySelector("#statBlock-features");
            const featureElement = createFeatureEditorElement(null, featureContainer.children.length);
            featureContainer.appendChild(featureElement);
        });

        document.querySelector("#cancel-statBlock-edit").addEventListener("click", function() {
            hideStatBlockEditor();
        });

        document.querySelector("#statBlock-form").addEventListener("submit", function(event) {
            event.preventDefault(); // Prevent page refresh

            const statBlock = statBlockEditor.statBlock;
            if (statBlock) {
                // TODO: Don't set optional fields if empty?

                // Basics
                statBlock.name = statBlockEditor.querySelector("#statBlock-name").value.trim();
                statBlock.tier = parseInt(statBlockEditor.querySelector("#statBlock-tier").value);
                statBlock.description = statBlockEditor.querySelector("#statBlock-description").value.trim();
                statBlock.difficulty = parseInt(statBlockEditor.querySelector("#statBlock-difficulty").value);

                if (statBlock.category == "Adversary") {
                    statBlock.countPerHp = parseInt(statBlockEditor.querySelector("#adversary-count-per-hp").value);
                    statBlock.type = statBlockEditor.querySelector("#adversary-type").value;
                    statBlock.motivesAndTactics = statBlockEditor.querySelector("#adversary-motives").value.trim();

                    // Stats
                    statBlock.majorThreshold = parseInt(statBlockEditor.querySelector("#adversary-major-threshold").value);
                    statBlock.severeThreshold = parseInt(statBlockEditor.querySelector("#adversary-severe-threshold").value);
                    statBlock.hp = parseInt(statBlockEditor.querySelector("#adversary-hp").value);
                    if (statBlock.instances) {
                        statBlock.instances.forEach(function(instance) {
                            instance.hpMarked = Math.min(instance.hpMarked, statBlock.hp);
                        });
                    }
                    statBlock.stress = parseInt(statBlockEditor.querySelector("#adversary-stress").value);
                    if (statBlock.instances) {
                        statBlock.instances.forEach(function(instance) {
                            instance.stressMarked = Math.min(instance.stressMarked, statBlock.stress);
                        });
                    }
                    statBlock.experience = statBlockEditor.querySelector("#adversary-experience").value.trim();

                    // Attack
                    statBlock.attackModifier = statBlockEditor.querySelector("#adversary-attack-modifier").value.trim();
                    statBlock.attackDescription = statBlockEditor.querySelector("#adversary-attack-description").value.trim();
                    statBlock.attackRange = statBlockEditor.querySelector("#adversary-attack-range").value;
                    statBlock.attackDamage = statBlockEditor.querySelector("#adversary-attack-damage").value.trim();
                } else if (statBlock.category == "Environment") {
                    statBlock.type = statBlockEditor.querySelector("#environment-type").value;
                    statBlock.impulses = statBlockEditor.querySelector("#environment-impulses").value;
                    statBlock.potentialAdversaries = statBlockEditor.querySelector("#environment-potential-adversaries").value;
                }

                // Features
                statBlock.features = [];
                const featureElements = statBlockEditor.querySelectorAll("#statBlock-features .feature");
                featureElements.forEach(function(featureElement) {
                    const feature = {
                        name: featureElement.querySelector(".statBlock-feature-name").value.trim(),
                        text: featureElement.querySelector(".statBlock-feature-text").value.trim()
                    };
                    if (feature.name || feature.text) { // TODO: Require both?
                        statBlock.features.push(feature);
                    }
                });
            }

            saveState();
            refreshDisplay(); // TODO: CreateOrEditStatBlockElement, EditTotalBattlePoints
            hideStatBlockEditor();
        });

        function showConditionsEditor(instance) {
            conditionsEditor.instance = instance;
            conditionsEditor.classList.remove("hidden");
            editorOverlay.classList.remove("hidden");

            conditionsEditor.querySelector(".instance-name").innerText = instance.name;
            updateConditionsDisplay(conditionsEditor.querySelector(".conditions"), instance, true);

            conditionsEditor.querySelector("#condition-name").select();
            window.scrollTo(0, 0);
        }

        function hideConditionsEditor() {
            const instance = conditionsEditor.instance;
            conditionsEditor.instance = undefined;
            conditionsEditor.classList.add("hidden");
            editorOverlay.classList.add("hidden");

            const instanceElements = Array.from(document.querySelectorAll(".instance"));
            for (let i = 0; i < instanceElements.length; i++) {
                if (instanceElements[i].instance == instance) {
                    const conditionsDiv = instanceElements[i].querySelector(".conditions");
                    if (conditionsDiv) {
                        updateConditionsDisplay(conditionsDiv, instance, false);

                        // TODO: If we don't need to refreshDisplay, can we just present the editor
                        //       without changing our Y position, and then skip this scrolling?
                        conditionsDiv.scrollIntoView({ behavior: "instant", block: "nearest" });
                    }
                    break;
                }
            }
        }

        conditionsEditor.addEventListener("keyup", function(event) {
            if (event.keyCode === 27) { // Escape key
                hideConditionsEditor();
            }
        });

        document.querySelector("#done-adding-conditions").addEventListener("click", function(event) {
            hideConditionsEditor();
        });

        document.querySelector("#add-condition").addEventListener("click", function(event) {
            const instance = conditionsEditor.instance;
            if (!instance) {
                return;
            }

            const addConditionInput = conditionsEditor.querySelector("#condition-name");
            const conditionsDiv = conditionsEditor.querySelector(".conditions");

            const condition = addConditionInput.value.trim();
            if (condition && (!instance.conditions || !instance.conditions.includes(condition))) {
                if (!instance.conditions) {
                    instance.conditions = [];
                }
                instance.conditions.push(condition);
                addConditionInput.value = "";
                saveState();
                updateConditionsDisplay(conditionsDiv, instance, true);
            }
        });

        document.querySelector("#condition-name").addEventListener("keyup", function(event) {
            if (event.keyCode === 13) { // Enter key
                event.preventDefault();
                document.querySelector("#add-condition").click();
            }
        });

        document.querySelector("#add-modification").addEventListener("click", function(evenet) {
            const instance = conditionsEditor.instance;
            if (!instance) {
                return;
            }

            const addModificationNameInput = conditionsEditor.querySelector("#modification-name");
            const addModificationPropertyInput = conditionsEditor.querySelector("#modification-property");
            const addModificationValueInput = conditionsEditor.querySelector("#modification-value");
            const conditionsDiv = conditionsEditor.querySelector(".conditions");

            const modificationName = addModificationNameInput.value.trim();
            const propertyName = addModificationPropertyInput.value.trim();
            const modificationValue = addModificationValueInput.value.trim();
            if (modificationName && propertyName && modificationValue) {
                if (!instance.modifications) {
                    instance.modifications = [];
                }
                instance.modifications.push({
                    modificationName: modificationName,
                    propertyName: propertyName,
                    modification: modificationValue
                });
                addModificationNameInput.value = "";
                addModificationPropertyInput.value = "";
                addModificationValueInput.value = "";
                saveState();
                updateConditionsDisplay(conditionsDiv, instance, true);
            }
        });

        function hideEncounterEditor() {
            encounterEditor.classList.add("hidden");
            editorOverlay.classList.add("hidden");
        }

        encounterEditor.addEventListener("keyup", function(event) {
            if (event.keyCode === 27) { // Escape key
                hideEncounterEditor();
            }
        });

        function updateEditorBattlePointsRecommendation() {
            const playerCount = parseInt(document.querySelector("#encounter-player-count").value);
            const recommendedBattlePoints = (3 * playerCount) + 2;
            document.querySelector("#encounter-recommended-battle-points").innerText = `(Base recommendation: ${recommendedBattlePoints})`;
        }

        function getNewEncounterName() {
            const baseName = "New Encounter";
            const campaign = ensureCampaign();
            if (!campaign?.encounters?.length) {
                return baseName;
            }

            let max = 0;

            for (const encounter of campaign.encounters) {
                const match = encounter.name.match(new RegExp(`${baseName}\\s*#*(\\d+)?`));
                if (match) {
                    const num = match[1] ? parseInt(match[1]) : 1;
                    if (num > max) {
                        max = num;
                    }
                }
            }

            return max === 0 ? baseName : `${baseName} ${max + 1}`;
        }

        function getSelected() {
            let selectedCampaign = null;
            let selectedEncounter = null;

            if (state?.campaigns?.length) {
                selectedCampaign = state.campaigns[selectedCampaignIndex];
                if (selectedCampaign?.encounters?.length) {
                    selectedEncounter = selectedCampaign.encounters[selectedEncounterIndex];
                }
            }

            return {
                campaign: selectedCampaign,
                encounter: selectedEncounter,
            }
        }

        function getDefaultSelectedIndexes() {
            let defaultCampaignIndex = 0;
            let defaultEncounterIndex = 0;
            if (state.campaigns?.length) {
                defaultCampaignIndex = state.campaigns.length - 1;
                if (state.campaigns[defaultCampaignIndex].encounters?.length) {
                    defaultEncounterIndex = state.campaigns[defaultCampaignIndex].encounters.length - 1;
                }
            }
            return {
                campaignIndex: defaultCampaignIndex,
                encounterIndex: defaultEncounterIndex,
            };
        }

        battlePointsDisplay.addEventListener("click", () => {
            const selected = getSelected();
            showEncounterEditor(selected.encounter);
        });

        function showEncounterEditor(encounter) {
            const selected = getSelected();

            if (!encounter) {
                encounterEditor.encounter = null;

                encounter = {
                    name: getNewEncounterName(),
                    playerTier: selected.encounter?.playerTier ?? 1,
                    playerCount: selected.encounter?.playerCount ?? 4,
                    targetBattlePoints: selected.encounter?.targetBattlePoints ?? 14,
                };
            } else {
                encounterEditor.encounter = encounter;
            }

            encounterEditor.querySelector("#encounter-name").value = encounter.name;
            encounterEditor.querySelector("#encounter-campaign-name").value = selected.campaign?.name ?? "";
            encounterEditor.querySelector("#encounter-tier").value = encounter.playerTier ?? 1;
            encounterEditor.querySelector("#encounter-player-count").value = encounter.playerCount ?? 4;
            encounterEditor.querySelector("#encounter-target-battle-points").value = encounter.targetBattlePoints ?? 14;

            updateEditorBattlePointsRecommendation();

            editorOverlay.classList.remove("hidden");
            encounterEditor.classList.remove("hidden");
            encounterEditor.querySelector("#encounter-name").select();
            window.scrollTo(0, 0);
        }

        document.querySelector("#encounter-form").addEventListener("submit", function(event) {
            event.preventDefault(); // Prevent page refresh

            const campaignName = encounterEditor.querySelector("#encounter-campaign-name").value.trim();
            let encounter = encounterEditor.encounter;
            let needsRefreshDisplay = false;

            if (!state) {
                state = {};
            }
            if (!state.campaigns) {
                state.campaigns = [];
            }
            const previouslySelectedCampaign = state.campaigns[selectedCampaignIndex];

            let campaign = state.campaigns.find(c => stringBaseCompare(c.name, campaignName) == 0);
            if (!campaign) {
                needsRefreshDisplay = true;
                campaign = {
                    name: campaignName,
                    currentFear: 0, // TODO: Or playerCount?,
                    encounters: [],
                }
                state.campaigns.push(campaign);
            }

            if (!encounter) {
                needsRefreshDisplay = true;
                if (!campaign.encounters) {
                    campaign.encounters = [];
                }
                encounter = {}
                campaign.encounters.push(encounter);
            } else if (campaign !== previouslySelectedCampaign) {
                needsRefreshDisplay = true;
                if (previouslySelectedCampaign?.encounters?.length) {
                    const oldIndex = previouslySelectedCampaign.encounters.indexOf(encounter);
                    if (oldIndex >= 0) {
                        previouslySelectedCampaign.encounters.splice(oldIndex, 1);
                        if (!previouslySelectedCampaign.encounters.length) {
                            state.campaigns.splice(selectedCampaignIndex, 1);
                        }
                    }
                }
                campaign.encounters.push(encounter);
            }

            selectedEncounterIndex = campaign.encounters.length - 1;
            selectedCampaignIndex = state.campaigns.indexOf(campaign);

            const previousTier = encounter.playerTier;

            encounter.name = encounterEditor.querySelector("#encounter-name").value.trim();
            encounter.playerTier = parseInt(encounterEditor.querySelector("#encounter-tier").value);
            encounter.playerCount = parseInt(encounterEditor.querySelector("#encounter-player-count").value);
            encounter.targetBattlePoints = parseInt(encounterEditor.querySelector("#encounter-target-battle-points").value);

            if (previousTier !== encounter.playerTier) {
                needsRefreshDisplay = true;
            }

            saveState();
            if (needsRefreshDisplay) {
                refreshDisplay();
            } else {
                refreshBattlePoints();
            }
            hideEncounterEditor();

            updateBrowsingTier();
        });

        document.querySelector("#cancel-encounter-edit").addEventListener("click", function() {
            hideEncounterEditor();
        });

        document.querySelector("#add-encounter").addEventListener("click", function() {
            showEncounterEditor();
        });

        document.querySelector("#edit-encounter").addEventListener("click", function() {
            const encounter = getSelected().encounter;
            showEncounterEditor(encounter);
            hideEncounterMenu();
        });

        document.querySelector("#delete-encounter").addEventListener("click", function() {
            const selected = getSelected();
            if (selected.encounter) {
                selected.campaign.encounters.splice(selectedEncounterIndex, 1);
                if (!selected.campaign.encounters.length) {
                    state.campaigns.splice(selectedCampaignIndex, 1);
                    selectedCampaignIndex = Math.max(Math.min(selectedCampaignIndex, state.campaigns.length - 1), 0);
                }
                const lastEncounterIndex = state.campaigns?.length ? state.campaigns[selectedCampaignIndex].encounters.length - 1 : 0;
                selectedEncounterIndex = Math.max(Math.min(selectedEncounterIndex, lastEncounterIndex), 0);

                saveState();
                if (!state.campaigns.length) {
                    showEncounterEditor();
                }

                refreshDisplay();
            }
            hideEncounterMenu();
        });

        document.querySelector("#encounter-player-count").addEventListener("change", function() {
            updateEditorBattlePointsRecommendation();
        });

        function statBlockMatchesSearch(statBlock, searchText) {
            if (!searchText) {
                return true;
            }

            const statBlockName = statBlock.name.toLowerCase();
            // TODO: Include potentialAdversaries? But only if also shown in Description cell?
            const statBlockDescription = statBlock.description.toLowerCase();
            const statBlockType = statBlock.type.toLowerCase();
            const statBlockCategory = statBlock.category.toLowerCase();

            // All terms must match somewhere
            const terms = searchText.toLowerCase().split(/\s+/);
            for (const term of terms) {
                if (!term) {
                    continue; // Skip empty terms
                }
                if (!(statBlockName.includes(term) ||
                    statBlockDescription.includes(term) ||
                    statBlockType.includes(term) ||
                    statBlockCategory.includes(term))) {
                    return false;
                }
            }

            return true;
        }

        function updateBrowsingTier() {
            const selected = getSelected();
            if (selected.encounter) {
                // Update the tier dropdown based on the current encounter
                document.querySelector("#browsing-tier").value = selected.encounter.playerTier || "";
                updateBrowsingTableFiltering();
            }
        }

        function updateBrowsingTableFiltering() {
            const selectedSource = fullSearchSource.value;
            const selectedTier = parseInt(document.querySelector("#browsing-tier").value);
            const selectedCategory = document.querySelector("#browsing-category").value;
            const selectedType = document.querySelector("#browsing-type").value;
            const searchText = fullSearchInput.value;

            const rows = browsingTableBody.querySelectorAll("tr");
            rows.forEach(function(row) {
                if ((!selectedSource || row.statBlock.source == selectedSource) &&
                    (!selectedTier || row.statBlock.tier == selectedTier || row.statBlock.source === "Extra") &&
                    (!selectedCategory || row.statBlock.category == selectedCategory) &&
                    (!selectedType || row.statBlock.type == selectedType) &&
                    (!searchText || statBlockMatchesSearch(row.statBlock, searchText))) {
                    row.style.display = "";
                } else {
                    row.style.display = "none";
                }
            });
        }

        fullSearchInput.addEventListener("input", function(event) {
            updateBrowsingTableFiltering();
        });
        fullSearchSource.addEventListener("change", function(event) {
            updateBrowsingTableFiltering();
        });
        document.getElementById("browsing-tier").addEventListener("change", function(event) {
            updateBrowsingTableFiltering();
        });
        document.getElementById("browsing-type").addEventListener("change", function(event) {
            updateBrowsingTableFiltering();
        });
        document.getElementById("browsing-category").addEventListener("change", function(event) {
            updateBrowsingTableFiltering();
        });
        document.getElementById("browsing-reset-filters").addEventListener("click", function(event) {
            fullSearchInput.value = "";
            fullSearchSource.value = "";
            document.getElementById("browsing-tier").value = "";
            document.getElementById("browsing-category").value = "";
            document.getElementById("browsing-type").value = "";
            updateBrowsingTableFiltering();
        });

        simpleSearchInput.addEventListener("keyup", function(event) {
            if (event.keyCode === 13) { // Enter key
                event.preventDefault();
                document.getElementById("simple-search-add-button").click();
            }
        });

        document.getElementById("simple-search-add-button").addEventListener("click", () => {
            let selectedOption = simpleSearchInput.value.trim();
            if (!selectedOption) {
                // TODO: Or some "custom" type?
                selectedOption = "Jagged Knife Bandit";
            }
            let statBlock = srdStatBlocks.find(function(b) {
                return b.name === selectedOption
            });
            if (!statBlock && state.custom && state.custom.statBlocks) {
                statBlock = state.custom.statBlocks.find(function(b) {
                    return b.name === selectedOption;
                });
            }
            if (statBlock) {
                statBlock = JSON.parse(JSON.stringify(statBlock));
            }
            // TODO: Else, custom with given name?

            if (statBlock) {
                if (statBlock.category == "Adversary" && !statBlock.instances?.length) {
                    statBlock.instances = [
                        {
                            name: statBlock.name + " #1",
                            hpMarked: 0,
                            stressMarked: 0
                        }
                    ];
                }

                const encounter = ensureEncounter();
                if (!encounter.statBlocks) {
                    encounter.statBlocks = [];
                }
                encounter.statBlocks.push(statBlock);
                saveState();

                const statBlocks =  document.querySelector("#statBlocks");
                if (statBlocks) {
                    addStatBlock(statBlocks, encounter, statBlock);
                } else {
                    refreshDisplay();
                }
            }
        });

        document.getElementById("show-full-search").addEventListener("click", function(event) {
            fullSearch.classList.remove("hidden");
            simpleSearch.classList.add("hidden");
            if (fullSearchInput.value != simpleSearchInput.value) {
                fullSearchInput.value = simpleSearchInput.value;
                updateBrowsingTableFiltering();
            }
            fullSearchInput.focus();
            preferSimpleSearch = false;
            saveState();
        });

        document.getElementById("hide-full-search").addEventListener("click", function(event) {
            fullSearch.classList.add("hidden");
            simpleSearch.classList.remove("hidden");
            simpleSearchInput.value = fullSearchInput.value;
            simpleSearchInput.focus();
            preferSimpleSearch = true;
            saveState();
        });

        const maxFear = 12;

        document.getElementById("use-fear").addEventListener("click", event => {
            const campaign = getSelected().campaign;
            if (campaign.currentFear > 0) {
                campaign.currentFear--;
                updateFearDisplay(campaign);
                saveState();
            }
        });

        document.getElementById("gain-fear").addEventListener("click", event => {
            const campaign = getSelected().campaign;
            if (campaign.currentFear < maxFear) {
                campaign.currentFear++;
                updateFearDisplay(campaign);
                saveState();
            }
        });

        function updateFearDisplay(campaign) {
            const fearValue = document.getElementById("fear-value");
            fearValue.title = `${campaign.currentFear} Fear | Start: {number of PCs} | Short rest: 1d4 | Long rest: 1d4 + {number of PCs}`;

            const fearIcons = fearValue.querySelectorAll(".fear-icon");
            for (let i = 0; i < fearIcons.length; i++) {
                if (i >= campaign.currentFear) {
                    fearIcons[i].classList.add("inactive");
                } else {
                    fearIcons[i].classList.remove("inactive");
                }
            }

            document.getElementById("use-fear").disabled = campaign.currentFear <= 0;
            document.getElementById("gain-fear").disabled = campaign.currentFear >= maxFear;
        }

        function refreshBattlePoints() {
            const encounter = getSelected().encounter;
            const currentBattlePoints = calculateBattlePoints(encounter);

            battlePointsDisplay.classList.remove("hidden");
            battlePointsDisplay.querySelector("#target-battle-points").innerText = encounter.targetBattlePoints;

            // Round to nearest 0.1 for display
            const remainingBattlePoints = Math.round((encounter.targetBattlePoints - currentBattlePoints) * 10) / 10;

            if (remainingBattlePoints < 0) {
                battlePointsDisplay.querySelector("#current-battle-points").innerText = `‚ö†Ô∏è ${Math.abs(remainingBattlePoints)}`;
                battlePointsDisplay.querySelector("#current-battle-points-suffix").innerText = "over";
            } else {
                battlePointsDisplay.querySelector("#current-battle-points").innerText = Math.abs(remainingBattlePoints);
                battlePointsDisplay.querySelector("#current-battle-points-suffix").innerText = "left";
            }
        }

        function ensureCampaign() {
            if (!state) {
                state = {}
            }

            if (!state.campaigns?.length) {
                state.campaigns = [
                    {
                        name: "",
                        currentFear: 0,
                    }
                ]
            }

            if (!selectedCampaignIndex ||
                selectedCampaignIndex < 0 ||
                selectedCampaignIndex >= state.campaigns.length) {
                selectedCampaignIndex = state.campaigns.length - 1;
            }

            return state.campaigns[selectedCampaignIndex];
        }

        function ensureEncounter() {
            const campaign = ensureCampaign();

            if (!campaign.encounters?.length) {
                campaign.encounters = [
                    {
                        name: getNewEncounterName(),
                        playerTier: 1,
                        playerCount: 4,
                        targetBattlePoints: 14,
                    }
                ];
            }
            if (!selectedEncounterIndex ||
                selectedEncounterIndex < 0 ||
                selectedEncounterIndex >= campaign.encounters.length) {
                selectedEncounterIndex = campaign.encounters.length - 1;
            }

            return campaign.encounters[selectedEncounterIndex];
        }

        function onBrowserAddButtonClick(event) {
            const tr = event.target.closest("tr");
            const statBlockCopy = JSON.parse(JSON.stringify(tr.statBlock));
            if (statBlockCopy.category == "Adversary" && !statBlockCopy.instances?.length) {
                statBlockCopy.instances = [
                    {
                        name: statBlockCopy.name + " #1",
                        hpMarked: 0,
                        stressMarked: 0
                    }
                ];
            }

            const encounter = ensureEncounter();
            if (!encounter.statBlocks) {
                encounter.statBlocks = [];
            }
            encounter.statBlocks.push(statBlockCopy);
            saveState();

            const statBlocks =  document.querySelector("#statBlocks");
            if (statBlocks) {
                addStatBlock(
                    statBlocks,
                    encounter,
                    statBlockCopy,
                    refreshBattlePoints);
            } else {
                refreshDisplay();
            }
        }

        function addStatBlockToSearch(statBlock) {
            // Find insertion position
            let insertBeforeIndex = 1;
            for (let i = 0; i < statBlockDatalist.children.length; i++) {
                if (stringBaseCompare(statBlockDatalist.children[i].value, statBlock.name) > 0) {
                    break;
                }
                insertBeforeIndex++;
            }

            // Datalist for basic search
            const option = document.createElement("option");
            option.statBlock = statBlock;
            option.value = statBlock.name;

            statBlockDatalist.insertBefore(option, statBlockDatalist.childNodes[insertBeforeIndex]);

            // Table for browsing
            let battlePoints = "";
            if (statBlock.category === "Adversary") {
                battlePoints = statBlock.type === "Minion" ?
                    "1/player" :
                    getStatBlockBattlePoints(statBlock.type, 1);
            }
            const tr = resultsRowTemplate.content.cloneNode(true).children[0];
            tr.statBlock = statBlock;
            const tds = tr.querySelectorAll("td");
            tds[0].querySelector("button").addEventListener("click", onBrowserAddButtonClick);
            tds[1].textContent = statBlock.name;
            tds[2].textContent = statBlock.type;
            tds[3].textContent = battlePoints;
            tds[4].textContent = statBlock.description;
            browsingTableBody.insertBefore(tr, browsingTableBody.childNodes[insertBeforeIndex]);

            if (statBlock.source?.length && ["SRD", "Custom", "Extra"].indexOf(statBlock.source) != 0) {
                let sourceFound = false;
                for (let i = 0; i < fullSearchSource.childElementCount; i++) {
                    if (fullSearchSource.children[i].value == statBlock.source) {
                        sourceFound = true;
                        break;
                    }
                }
                if (!sourceFound) {
                    const newSourceOption = createElement("option", null, statBlock.source);
                    fullSearchSource.appendChild(newSourceOption);
                }
            }
        }

        function updateResource(
            container,
            adversary,
            adversarySlotsPropertyName,
            instance,
            instanceMarkedPropertyName,
            slotsFullClassName) {
            const slots = adversary[adversarySlotsPropertyName];
            const marked = instance[instanceMarkedPropertyName];

            const instanceDiv = container.closest(".instance");
            const slotInfoDiv = container.closest(".slotInfo");
            if (marked === slots) {
                slotInfoDiv.title = `This adversary is ${slotsFullClassName}`;
                instanceDiv.classList.add(slotsFullClassName);
            } else {
                slotInfoDiv.title = "";
                instanceDiv.classList.remove(slotsFullClassName);
            }

            if (container.childElementCount != slots) {
                const checkboxes = [];
                for (let i = 0; i < slots; i++) {
                    const slot = document.createElement("input");
                    slot.type = "checkbox";
                    slot.onclick = function(event) {
                        if (event.target.checked) {
                            instance[instanceMarkedPropertyName]++;
                        } else {
                            instance[instanceMarkedPropertyName]--;
                        }
                        saveState();
                        updateResource(
                            container,
                            adversary,
                            adversarySlotsPropertyName,
                            instance,
                            instanceMarkedPropertyName,
                            slotsFullClassName);
                    };
                    checkboxes.push(slot)
                }

                container.replaceChildren(...checkboxes);
            }

            for (let i = 0; i < slots; i++) {
                container.children[i].checked = i < marked;
            }
        }

        function setupStatBlockActionButton(statBlockElement, statBlock) {
            const actionsMenu = createElement("menu", "actions-menu hidden");

            function dismissActionsMenu() {
                actionsMenu.classList.add("hidden");
                activeMenuOverlay.classList.add("hidden");
            }

            const copyAction = createElementWithInnerHTML("li", null, `<button class="menu-action">Duplicate</button>`);
            copyAction.title = "Copy this stat block, including all changed state";
            copyAction.onclick = function() {
                statBlockElement.dispatchEvent(statBlockCopiedEvent);
                dismissActionsMenu();
            };
            actionsMenu.appendChild(copyAction);

            const copyFromSourceAction = createElementWithInnerHTML("li", null, `<button class="menu-action">Copy From Source</button>`);
            copyFromSourceAction.title = "Copy this stat block from the source, ignoring all changes";
            copyFromSourceAction.onclick = function() {
                statBlockElement.dispatchEvent(statBlockCopiedFromSourceEvent);
                dismissActionsMenu();
            };
            actionsMenu.appendChild(copyFromSourceAction);

            const saveCustomAction = createElementWithInnerHTML("li", null, `<button class="menu-action">Save to Custom Source</button>`);
            // TODO: Disable when no changes have been made?
            saveCustomAction.title = "Save this stat block to your custom stat block source for later use";
            saveCustomAction.onclick = function() {
                statBlockElement.dispatchEvent(statBlockSavedToCustomEvent);
                dismissActionsMenu();
            };
            actionsMenu.appendChild(saveCustomAction);

            const deleteCustomAction = document.createElement("li");
            // TODO: Add class to help identify this so statBlockSavedToCustom/statBlockDeletedFromCustom
            //       can change enabled state.
            const deleteCustomActionButton = createElement("button", "menu-action", "Delete from Custom Source");
            deleteCustomActionButton.disabled = statBlock.source !== 'Custom';
            deleteCustomAction.appendChild(deleteCustomActionButton);
            deleteCustomAction.title = "Delete from your custom stat block source";
            deleteCustomAction.onclick = function() {
                statBlockElement.dispatchEvent(statBlockDeletedFromCustomEvent);
                dismissActionsMenu();
            };
            actionsMenu.appendChild(deleteCustomAction);

            const topActions = document.createElement("div");
            topActions.className = "top-actions";
            statBlockElement.appendChild(topActions);

            if (statBlock.category == "Adversary") {
                const addInstanceButton = createElement("button", null, "‚ûï");
                addInstanceButton.title = "Add another instance of this adversary";
                addInstanceButton.onclick = function() {
                    const newInstance = {
                        // TODO: Review naming, this doesn't work well if you add several, delete several, add again.
                        //       May need to parse the names to find the largest, like we do for encounter names.
                        name: statBlock.name + " #" + (statBlock.instances.length + 1),
                        hpMarked: 0,
                        stressMarked: 0
                    };
                    if (!statBlock.instances) {
                        statBlock.instances = [];
                    }
                    statBlock.instances.push(newInstance);
                    saveState();
                    refreshDisplay(); // TODO: EditStatBlock (add instance element, update BP), EditTotalBattlePoints
                };
                topActions.appendChild(addInstanceButton);
            } else {
                const addCountdownButton = createElement("button", null, "‚è≤Ô∏è");
                addCountdownButton.title = "Add a countdown";
                addCountdownButton.onclick = function() {
                    updateCountdownsDisplay(statBlock, statBlockElement, true);
                };
                topActions.appendChild(addCountdownButton);
            }

            const editButton = createElement("button", null, "‚úèÔ∏è");
            editButton.title = "Edit this stat block";
            editButton.onclick = function() {
                showStatBlockEditor(statBlock);
            };
            topActions.appendChild(editButton);

            const deleteButton = createElement("button", null, "üóëÔ∏è");
            deleteButton.title = "Remove this stat block from the encounter";
            deleteButton.onclick = function() {
                statBlockElement.dispatchEvent(statBlockRemovedEvent);
            };
            topActions.appendChild(deleteButton);

            const actionsButton = createElement("button", null, "üé≠");
            actionsButton.title = "Stat block management actions";
            actionsButton.onclick = function(event) {
                const rect = event.target.getBoundingClientRect();
                actionsMenu.style.top = `${rect.height + 5}px`;
                actionsMenu.classList.remove("hidden");
                activeMenuOverlay.classList.remove("hidden");
            };
            statBlockElement.appendChild(actionsMenu)
            topActions.appendChild(actionsButton);
        }

        // TODO: Pass list directly instead of container
        function updateConditionsDisplay(container, instance, inDialog) {
            const conditionsList = container.querySelector(".conditions-list");
            conditionsList.innerHTML = "";
            let hasConditionsOrModifications = false;

            if (instance.conditions && instance.conditions.length > 0) {
                for (let i = 0; i < instance.conditions.length; i++) {
                    hasConditionsOrModifications = true;
                    const condition = instance.conditions[i];
                    const conditionItem = conditionTemplate.content.cloneNode(true).children[0];
                    conditionItem.children[0].textContent = condition;
                    conditionItem.children[1].onclick = function(event) {
                        instance.conditions = instance.conditions.filter(function(c) {
                            return c !== condition;
                        });
                        updateConditionsDisplay(container, instance, inDialog);
                        saveState();
                    };
                    conditionsList.appendChild(conditionItem);
                }
            }

            if (instance.modifications && instance.modifications.length > 0) {
                for (let i = 0; i < instance.modifications.length; i++) {
                    hasConditionsOrModifications = true;
                    const modification = instance.modifications[i];
                    const conditionItem = conditionTemplate.content.cloneNode(true).children[0];
                    conditionItem.children[0].textContent = `${modification.modificationName} (${modification.propertyName} ${modification.modification})`
                    conditionItem.children[1].onclick = function(event) {
                        instance.modifications = instance.modifications.filter(function(m) {
                            return m !== modification;
                        });
                        updateConditionsDisplay(container, instance, inDialog);
                        saveState();
                    };
                    conditionsList.appendChild(conditionItem);
                }
            }

            // TODO: Maybe have this in the editor HTML, and hide/show instead of recreating?
            //       Same with button below, except in statblock HTML?
            if (inDialog && !hasConditionsOrModifications) {
                conditionsList.appendChild(createElement("li", "placeholder", "No conditions or modifications, add below"));
            }

            // TODO: Templatize? Also is it kosher for a list to contain a naked button?
            if (!inDialog) {
                const editConditions = createElement("button", "add-conditions-button", "Add Conditions");
                editConditions.title = "Add conditions or modifications to this adversary instance";
                editConditions.onclick = function(event) {
                    showConditionsEditor(instance);
                }
                conditionsList.appendChild(editConditions);
            }
        }

        function createStatBlockElement(encounter, statBlock) {
            // TODO: Allow reordering?

            let warning = "";
            if (statBlock.tier > encounter.playerTier) {
                warning += "‚ö†Ô∏è above player tier";
            } else if (statBlock.tier < encounter.playerTier) {
                warning += "‚ö†Ô∏è below player tier"
            }

            const statBlockDiv = createElement("article", "statBlock");
            statBlockDiv.statBlock = statBlock;
            // TODO: Make it easier for source to be identified and changed
            //       in statBlockSavedToCustom/statBlockDeletedFromCustom
            // TODO: This should be in a container (flexbox?) with action buttons
            //       so that long names don't ovelap.
            const statBlockHeader = createElement("h3", null, statBlock.name);
            statBlockHeader.title = `Source: ${statBlock.originalName}, ${statBlock.source}`;
            statBlockDiv.appendChild(statBlockHeader);

            let tierTypeSuffix = "";
            let tierTypeSuffixComponents = [];
            if (statBlock.countPerHp > 1 || statBlock.type === "Horde") {
                tierTypeSuffixComponents.push(`${statBlock.countPerHp}/HP`);
            }
            if (statBlock.category === "Adversary") {
                const battlePoints = getStatBlockBattlePoints(statBlock.type, encounter.playerCount) * (statBlock.instances?.length || 0);
                tierTypeSuffixComponents.push(`${battlePoints} pts`);
            }
            if (warning) {
                tierTypeSuffixComponents.push(warning);
            }
            if (tierTypeSuffixComponents.length > 0) {
                tierTypeSuffix = ` (${tierTypeSuffixComponents.join(", ")})`;
            }

            const tierAndType = createElement("p", "tier", `Tier ${statBlock.tier} ${statBlock.type}${tierTypeSuffix}`);
            statBlockDiv.appendChild(tierAndType);

            if (statBlock.description) {
                statBlockDiv.appendChild(createElement("p", "description", statBlock.description));
            }

            if (statBlock.motivesAndTactics) {
                const motives = document.createElement("p");
                motives.className =  "motives";
                motives.appendChild(createElement("span", "motivesLabel", "Motives & Tactics:"));
                motives.appendChild(document.createTextNode(` ${statBlock.motivesAndTactics}`));
                statBlockDiv.appendChild(motives);
            }
            if (statBlock.impulses) {
                const impulses = document.createElement("p");
                impulses.className =  "motives";
                impulses.appendChild(createElement("span", "motivesLabel", "Impulses:"));
                impulses.appendChild(document.createTextNode(` ${statBlock.impulses}`));
                statBlockDiv.appendChild(impulses);
            }

            const stats = document.createElement("p");
            stats.className = "stats";

            const difficultyDiv = document.createElement("div");
            stats.appendChild(difficultyDiv);
            difficultyDiv.appendChild(createElement("span", "statLabel", "Difficulty:"));
            difficultyDiv.appendChild(document.createTextNode(` ${statBlock.difficulty} `));

            if (statBlock.majorThreshold || statBlock.severeThreshold) {
                let majorThreshold = statBlock.majorThreshold || "None";
                let severeThreshold = statBlock.severeThreshold || "None";
                thresholds = `${majorThreshold}/${severeThreshold}`;

                difficultyDiv.appendChild(createElement("span", "divider", "|"));
                difficultyDiv.appendChild(document.createTextNode(" "));
                difficultyDiv.appendChild(createElement("span", "statLabel", "Thresholds:"));
                difficultyDiv.appendChild(document.createTextNode(` ${thresholds}`));
            }

            if (statBlock.attackDescription) {
                stats.innerHTML += `<div><span class="statLabel">ATK:</span> ${statBlock.attackModifier} <span class="divider">|</span> <span class="statLabel">${statBlock.attackDescription}:</span> ${statBlock.attackRange} <span class="divider">|</span> ${statBlock.attackDamage}</div>`;
            }
            if (statBlock.experience) {
                stats.innerHTML += `<div class="experiences"><span class="statLabel">Experience:</span> ${statBlock.experience}</div>`;
            }
            if (statBlock.potentialAdversaries) {
                stats.innerHTML += `<div><span class="statLabel">Potential Adversaries:</span> ${statBlock.potentialAdversaries}</div>`;
            }
            statBlockDiv.appendChild(stats);

            if (statBlock.features && statBlock.features.length > 0) {
                const featuresContainer = createElementWithInnerHTML("details", "featuresExpander", `<summary>FEATURES</summary>`);
                const featuresDiv = createElement("div", "features");
                featuresContainer.appendChild(featuresDiv);

                for (let i = 0; i < statBlock.features.length; i++) {
                    const featureElement = createElement("p", "feature");
                    featuresDiv.appendChild(featureElement);

                    featureElement.appendChild(createElement("span", "featureLabel", `${statBlock.features[i].name}:`));
                    featureElement.appendChild(createElement("span", null, ` ${statBlock.features[i].text}`));
                }

                statBlockDiv.appendChild(featuresContainer);
            }

            for (let i = 0; i < statBlock.instances?.length || 0; i++) {
                const instance = statBlock.instances[i];

                // TODO: In theory this should maybe be a section or sub-article instead, but would
                //       need an h4 for instance name.
                const instanceDiv = createElement("div", "instance");
                instanceDiv.instance = instance;
                statBlockDiv.appendChild(instanceDiv);

                const instanceName = document.createElement("input")
                instanceName.type = "text";
                instanceName.size = 30; // TODO: Change all size like we changed cols to scale down when narrow
                instanceName.value = instance.name;
                instanceName.addEventListener("input", function(event) {
                    instance.name = event.target.value;
                    saveState();
                });
                instanceDiv.appendChild(instanceName);

                const hpDiv = createElement("div", "slotInfo", "HP:");
                const hpSlotsDiv = createElement("div", "slots");
                hpDiv.appendChild(hpSlotsDiv);
                instanceDiv.appendChild(hpDiv);
                updateResource(hpSlotsDiv, statBlock, "hp", instance, "hpMarked", "defeated");

                const stressDiv = createElement("div", "slotInfo", "Stress:");
                const stressSlotsDiv = createElement("div", "slots");
                stressDiv.appendChild(stressSlotsDiv);
                instanceDiv.appendChild(stressDiv);
                updateResource(stressSlotsDiv, statBlock, "stress", instance, "stressMarked", "vulnerable");

                const conditionsDiv = createElement("div", "conditions");
                conditionsDiv.innerHTML = "<ul class='conditions-list'></ul>";
                instanceDiv.appendChild(conditionsDiv);
                updateConditionsDisplay(conditionsDiv, instance, false);

                updateCountdownsDisplay(instance, instanceDiv);

                const instanceTopActions = createElement("div", "top-actions");
                instanceDiv.appendChild(instanceTopActions);

                const addCountdownButton = createElement("button", "child-action", "‚è≤Ô∏è");
                addCountdownButton.title = "Add a countdown";
                addCountdownButton.onclick = function() {
                    updateCountdownsDisplay(instance, instanceDiv, true);
                };
                instanceTopActions.appendChild(addCountdownButton);

                const removeInstanceButton = createElement("button", "child-action", "üóëÔ∏è");
                removeInstanceButton.title = "Remove this instance of the adversary";
                removeInstanceButton.onclick = function(event) {
                    event.target.closest(".instance").remove();
                    statBlock.instances = statBlock.instances.filter(function(i) {
                        return i !== instance;
                    });
                    saveState();
                    refreshDisplay(); // TODO: EditStatBlock (update BP), EditTotalBattlePoints
                };
                instanceTopActions.appendChild(removeInstanceButton);
            }

            if (statBlock.category !== "Adversary") {
                updateCountdownsDisplay(statBlock, statBlockDiv);
            }

            setupStatBlockActionButton(statBlockDiv, statBlock);

            return statBlockDiv;
        }

        function updateCountdownsDisplay(item, container, addNewCountdown) {
            if (addNewCountdown) {
                const newCountdown = {
                    name: "",
                    value: 6,
                };
                if (!item.countdowns) {
                    item.countdowns = [];
                }
                item.countdowns.push(newCountdown);
                saveState();
            }

            let countdownsContainer = container.querySelector(".countdowns-container");
            if (!countdownsContainer) {
                countdownsContainer = document.getElementById("countdowns-template").content.cloneNode(true).children[0];
                container.appendChild(countdownsContainer);
            }

            const countdownsList = countdownsContainer.querySelector(".countdowns");

            let startIndex = item.countdowns?.length - 1;
            if (!addNewCountdown) {
                countdownsList.innerHTML = ""; // Clear existing countdowns
                startIndex = 0;
            }

            if (item.countdowns?.length) {
                for (let i = startIndex; i < item.countdowns.length; i++) {
                    const countdown = item.countdowns[i];
                    const countdownItem = document.getElementById("countdown-template").content.cloneNode(true).children[0];

                    const nameInput = countdownItem.querySelector(".countdown-name");
                    nameInput.value = countdown.name;
                    nameInput.addEventListener("input", function(event) {
                        countdown.name = event.target.value;
                        saveState();
                    });

                    const valueInput = countdownItem.querySelector(".countdown-value");
                    valueInput.value = countdown.value;
                    valueInput.addEventListener("input", function(event) {
                        countdown.value = parseInt(event.target.value);
                        saveState();
                    });

                    countdownItem.querySelector(".inline-delete").onclick = function(event) {
                        item.countdowns.splice(item.countdowns.indexOf(countdown), 1);
                        countdownsList.removeChild(countdownItem);
                        saveState();
                    };

                    countdownsList.appendChild(countdownItem);
                    if (addNewCountdown && i == item.countdowns.length - 1) {
                        nameInput.focus();
                    }
                }
            }
        }

        function addStatBlock(container, encounter, statBlock) {
            const statBlockElement = createStatBlockElement(encounter, statBlock);

            statBlockElement.addEventListener("statBlockRemoved", function(event) {
                encounter.statBlocks = encounter.statBlocks.filter(function(a) {
                    return a !== statBlock;
                });
                container.removeChild(statBlockElement);
                refreshBattlePoints();
                saveState();
            });
            statBlockElement.addEventListener("statBlockCopied", function(event) {
                const newStatBlock = JSON.parse(JSON.stringify(statBlock));
                newStatBlock.name += " (copy)"; // TODO: Decide naming
                if (!encounter.statBlocks) {
                    encounter.statBlocks = [];
                }
                encounter.statBlocks.push(newStatBlock);
                addStatBlock(container, encounter, newStatBlock);
                saveState();
            });
            statBlockElement.addEventListener("statBlockCopiedFromSource", function(event) {
                // TODO: This is mostly a dupe of click handlers for search add buttons
                let newStatBlock = null;
                if (statBlock.source == "SRD") {
                    const sourceStatBlock = srdStatBlocks.find(function(a) {
                        return a.name === statBlock.originalName;
                    });
                    newStatBlock = JSON.parse(JSON.stringify(sourceStatBlock));
                } else if (statBlock.source == "Extra") {
                    const sourceStatBlock = extraStatBlocks.find(function(a) {
                        return a.name === statBlock.originalName;
                    });
                    newStatBlock = JSON.parse(JSON.stringify(sourceStatBlock));
                } else if (state.custom && state.custom.statBlocks) {
                    const sourceStatBlock = state.custom.statBlocks.find(function(a) {
                        return a.name === statBlock.originalName;
                    });
                    newStatBlock = JSON.parse(JSON.stringify(sourceStatBlock));
                }

                if (newStatBlock.category == "Adversary" && !newStatBlock.instances?.length) {
                    newStatBlock.instances = [
                        {
                            name: newStatBlock.name + " #1",
                            hpMarked: 0,
                            stressMarked: 0
                        }
                    ];
                }

                if (!encounter.statBlocks) {
                    encounter.statBlocks = [];
                }
                encounter.statBlocks.push(newStatBlock);
                addStatBlock(container, encounter, newStatBlock);
                saveState();
            });
            statBlockElement.addEventListener("statBlockSavedToCustom", function(event) {
                // TODO: Warn user of overwrite?
                statBlock.source = "Custom";
                statBlock.originalName = statBlock.name;
                const newCustomStatBlock = JSON.parse(JSON.stringify(statBlock));
                delete newCustomStatBlock.instances;
                delete newCustomStatBlock.countdowns;
                if (!state.custom) {
                    state.custom = {};
                }
                if (!state.custom.statBlocks) {
                    state.custom.statBlocks = [];
                } else {
                    // Can only have one custom statblock of a given name
                    state.custom.statBlocks = state.custom.statBlocks.filter(function(a) {
                        return a.name !== statBlock.name;
                    });
                }
                state.custom.statBlocks.push(newCustomStatBlock);
                state.custom.statBlocks.sort((a, b) => stringBaseCompare(a.name, b.name));
                saveState();
                refreshDisplay(); // TODO: EditStatBlock (just tooltip/menu state)
                refreshCustomStatBlocksInSearch();
            });
            statBlockElement.addEventListener("statBlockDeletedFromCustom", function(event) {
                if (statBlock.source !== "Custom") {
                    console.warn("Trying to delete a non-custom statBlock from custom list");
                    return;
                }
                if (!state.custom) {
                    state.custom = {};
                }
                if (!state.custom.statBlocks) {
                    state.custom.statBlocks = [];
                } else {
                    state.custom.statBlocks = state.custom.statBlocks.filter(function(a) {
                        return a.name !== statBlock.originalName;
                    });
                }
                statBlock.source = "Orphaned";
                saveState();
                refreshDisplay(); // TODO: EditStatBlock (just tooltip/menu state)
                refreshCustomStatBlocksInSearch();
            });

            container.appendChild(statBlockElement);
            refreshBattlePoints();
        }

        function getStatBlockBattlePoints(adversaryType, playerCount) {
            switch(adversaryType.toLowerCase()) {
                case "minion":
                    return 1 / playerCount;
                case "social":
                case "support":
                    return 1;
                case "horde":
                case "ranged":
                case "skulk":
                case "standard":
                    return 2;
                case "leader":
                    return 3;
                case "bruiser":
                    return 4;
                case "solo":
                    return 5;
                default:
                    return 0;
            }
        }

        function calculateBattlePoints(encounter)
        {
            let currentBattlePoints = 0;
            for (let j = 0; j < encounter.statBlocks.length; j++) {
                const statBlock = encounter.statBlocks[j];
                const adversaryPoints = statBlock.category == "Adversary" ? getStatBlockBattlePoints(statBlock.type, encounter.playerCount) : 0;
                // TODO: Deal with tier differences
                currentBattlePoints += adversaryPoints * (statBlock.instances?.length || 0);
            }
            return currentBattlePoints;
        }

        function refreshDisplay() {
            // TODO: Is it really necessary to wipe the encounter/campaign selectors on each refresh?
            campaignSelector.innerHTML = "";
            encounterSelector.innerHTML = "";
            const searchableCampaigns = document.getElementById("searchable-campaigns");
            searchableCampaigns.innerHTML = "";
            battlePointsDisplay.classList.add("hidden");
            const encounterDiv = document.getElementById("encounter");
            encounterDiv.innerHTML = ""; // Clear any existing content

            let campaign = null;
            let encounter = null;
            if (state?.campaigns?.length) {
                selectedCampaignIndex = Math.max(Math.min(selectedCampaignIndex, state.campaigns.length - 1), 0);
                campaign = state.campaigns[selectedCampaignIndex];
                if (campaign.encounters?.length) {
                    selectedEncounterIndex = Math.max(Math.min(selectedEncounterIndex, campaign.encounters.length - 1), 0);
                    encounter = campaign.encounters[selectedEncounterIndex];
                } else {
                    // If selected campaign has no encounters, find the first one that does
                    for (let i = 0; i < state.campaigns.length; i++) {
                        campaign = state.campaigns[i];
                        if (campaign.encounters?.length) {
                            selectedCampaignIndex = i;
                            selectedEncounterIndex = campaign.encounters.length - 1;
                            encounter = campaign.encounters[selectedEncounterIndex];
                            break;
                        }
                    }
                }
            }

            if (!encounter) {
                // TODO: Move this to the HTML?
                const noEncounters = createElement("p", "no-encounters");
                encounterDiv.appendChild(noEncounters);
                const noEncountersSpan = createElement("span", null, "No encounters found. Start adding adversaries or environments to create your first encounter, or ");
                noEncounters.appendChild(noEncountersSpan);
                const loadSamplesButon = createElement("button", "load-samples", "Load Sample Encounters");
                noEncounters.appendChild(loadSamplesButon)
                loadSamplesButon.addEventListener("click", () => {
                    loadState(JSON.parse(JSON.stringify(sampleState)));
                    const defaults = getDefaultSelectedIndexes();
                    selectedCampaignIndex = defaults.campaignIndex;
                    selectedEncounterIndex = defaults.encounterIndex;
                    saveState();
                    refreshDisplay();
                });
                return;
            }

            // Display campaigns and encounters in reverse order, with latest showing first
            for (let i = state.campaigns.length - 1; i >= 0; i--) {
                // TODO: Validate various fields
                let displayName = state.campaigns[i].name;
                if (!displayName) {
                    displayName = "(default)";
                }
                const option = createElement("option", null, displayName);
                const searchableOption = createElement("option", null, state.campaigns[i].name);
                option.value = i;
                campaignSelector.appendChild(option);
                searchableCampaigns.appendChild(searchableOption);
            }
            campaignSelector.value = selectedCampaignIndex;

            if (state.campaigns.length == 1) {
                campaignSelector.classList.add("hidden");
            } else {
                campaignSelector.classList.remove("hidden");
            }

            for (let i = campaign.encounters.length - 1; i >= 0; i--) {
                const encounter = campaign.encounters[i];
                // TODO: Validate various fields
                const option = createElement("option", null, `${encounter.name} (Tier ${encounter.playerTier} | ${encounter.playerCount} Players)`);
                option.value = i;
                encounterSelector.appendChild(option);
            }
            encounterSelector.value = selectedEncounterIndex;

            if (!encounter.statBlocks) {
                encounter.statBlocks = [];
            }

            const encounterBar = document.createElement("div");
            encounterBar.className = "encounter-bar";
            encounterDiv.appendChild(encounterBar);

            refreshBattlePoints();

            updateFearDisplay(campaign);

            const statBlocksDiv = document.createElement("main");
            statBlocksDiv.id = "statBlocks";
            for (let j = 0; j < encounter.statBlocks.length; j++) {
                addStatBlock(statBlocksDiv, encounter, encounter.statBlocks[j]);
            }
            encounterDiv.appendChild(statBlocksDiv);
        }

        let preferSimpleSearch = localStorage.getItem("prefer-simple-search") === "true";
        if (preferSimpleSearch) {
            simpleSearch.classList.remove("hidden");
            fullSearch.classList.add("hidden");
        } else {
            simpleSearch.classList.add("hidden");
            fullSearch.classList.remove("hidden");
        }

        // TODO: Validate these when state is loaded?
        let selectedCampaignIndex = parseInt(localStorage.getItem("selected-campaign-index"));
        if (!selectedCampaignIndex || selectedCampaignIndex < 0) {
            selectedCampaignIndex = 0;
        }
        let selectedEncounterIndex = parseInt(localStorage.getItem("selected-encounter-index"));
        if (!selectedEncounterIndex || selectedEncounterIndex < 0) {
            selectedEncounterIndex = 0;
        }

        function loadState(incomingState) {
            // Convert from encounter-first to campaign-first, if needed
            if (!incomingState?.campaigns && incomingState?.encounters) {
                const encounters = incomingState.encounters;
                delete incomingState.encounters;

                let latestFear = 0;
                for (const encounter of encounters) {
                    if (encounter.currentFear) {
                        latestFear = encounter.currentFear;
                    }
                    delete encounter.currentFear;
                }

                const campaign = {
                    name: "",
                    currentFear: latestFear,
                    encounters: encounters,
                };
                incomingState.campaigns = [ campaign ];
            }

            state = incomingState;
        }

        let state = null;
        try {
            loadState(JSON.parse(localStorage.getItem("encounters-state")));
        } catch (error) {
            console.error("Error loading saved encounters:", error);
        }

        function loadFromJsonFile(fileInputEvent, callback) {
            const file = fileInputEvent.target.files[0];
            if (!file) {
                callback(null);
                return;
            }
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    callback(JSON.parse(e.target.result));
                } catch (error) {
                    console.error("Error loading encounters:", error);
                    callback(null);
                }
            };
            reader.onerror = function(e) {
                console.error("Error reading file:", e);
                callback(null);
            };
            reader.readAsText(file);
        }

        document.getElementById("load-encounters").addEventListener("change", function(event) {
            // TODO: Confirm, as this will overwrite all user state.
            loadFromJsonFile(event, function(loadedState) {
                if (loadedState) {
                    loadState(loadedState);
                    const defaults = getDefaultSelectedIndexes();
                    selectedCampaignIndex = defaults.campaignIndex;
                    selectedEncounterIndex = defaults.encounterIndex;
                    saveState();
                    refreshDisplay();
                } else {
                    alert("Failed to load encounters from file.");
                }
                hideEncounterMenu();
            });
        });

        document.getElementById("import-custom").addEventListener("change", function(event) {
            loadFromJsonFile(event, function(loadedState) {
                if (loadedState && loadedState.custom && loadedState.custom.statBlocks) {
                    if (!state) {
                        state = {};
                    }
                    if (!state.custom) {
                        state.custom = {};
                    }
                    if (!state.custom.statBlocks) {
                        state.custom.statBlocks = [];
                    }
                    state.custom.statBlocks.push(...loadedState.custom.statBlocks);
                    state.custom.statBlocks.sort((a, b) => stringBaseCompare(a.name, b.name));
                    saveState();
                    refreshCustomStatBlocksInSearch();
                } else {
                    alert("Failed to load custom stat blocks from file.");
                }
                hideEncounterMenu();
            });
        });

        function saveToJsonFile(filename, data) {
            const json = JSON.stringify(data, null, "    ");
            const blob = new Blob([json], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        document.getElementById("save-encounters").addEventListener("click", function() {
            saveToJsonFile("encounters.json", state);
            hideEncounterMenu();
        });

        document.getElementById("export-custom").addEventListener("click", function() {
            if (state.custom && state.custom.statBlocks && state.custom.statBlocks.length > 0) {
                saveToJsonFile("custom-stat-blocks.json", { custom: { statBlocks: state.custom.statBlocks } });
            } else {
                alert("No custom stat blocks to export.");
            }
            hideEncounterMenu();
        });

        const campaignSelector = document.getElementById("current-campaign");
        campaignSelector.addEventListener("change", function() {
            selectedCampaignIndex = parseInt(campaignSelector.value);
            saveState();
            refreshDisplay();
            updateBrowsingTier()
        });

        const encounterSelector = document.getElementById("current-encounter");
        encounterSelector.addEventListener("change", function() {
            selectedEncounterIndex = parseInt(encounterSelector.value);
            saveState();
            refreshDisplay();
            updateBrowsingTier()
        });

        function saveState() {
            localStorage.setItem("encounters-state", JSON.stringify(state));
            localStorage.setItem("selected-campaign-index", selectedCampaignIndex);
            localStorage.setItem("selected-encounter-index", selectedEncounterIndex);
            localStorage.setItem("prefer-simple-search", preferSimpleSearch);
        }

        function refreshCustomStatBlocksInSearch() {
            // Clear custom entries from search
            for (let i = statBlockDatalist.children.length - 1; i >= 0; i--) {
                const option = statBlockDatalist.children[i];
                const source = option.statBlock.source;
                if (source !== "SRD" && source !== "Extra") {
                    option.remove();
                }
            }
            for (let i = browsingTableBody.children.length - 1; i >= 0; i--) {
                const row = browsingTableBody.children[i];
                const source = row.statBlock.source;
                if (source !== "SRD" && source !== "Extra") {
                    row.remove();
                }
            }

            addStatBlocksToSearch(state?.custom?.statBlocks);
        }

        function addStatBlocksToSearch(statBlocks) {
            if (statBlocks?.length) {
                statBlocks.forEach(function(statBlock) {
                    addStatBlockToSearch(statBlock);
                });
            }
        }

        const statBlockDatalist = document.getElementById("searchable-statBlocks");
        const browsingTableBody = fullSearch.querySelector("tbody");
        for (let i = 0; i < srdStatBlocks.length; i++) {
            addStatBlockToSearch(srdStatBlocks[i]);
        }
        addStatBlocksToSearch(state?.custom?.statBlocks);
        addStatBlocksToSearch(extraStatBlocks);

        refreshDisplay();
        updateBrowsingTableFiltering(); // TODO: Move into refreshDisplay?
    </script>
</html>
