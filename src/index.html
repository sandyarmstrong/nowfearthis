<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Now Fear This</title>
        <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
        <link rel="manifest" href="site.webmanifest">
        <script src="statBlocks.js"></script>
        <script src="sample-encounters.js"></script>
        <style>
            :root {
                /** Palette courtesy of https://colorffy.com/dark-theme-generator?colors=825aa2-121212 */
                /** Base colors */
                --clr-dark-a0: #000000;
                --clr-light-a0: #ffffff;

                /** Theme primary colors */
                --clr-primary-a0: #825aa2;
                --clr-primary-a10: #906bac;
                --clr-primary-a20: #9e7db6;
                --clr-primary-a30: #ac8fc1;
                --clr-primary-a40: #b9a1cb;
                --clr-primary-a50: #c7b3d5;

                /** Theme surface colors */
                --clr-surface-a0: #121212;
                --clr-surface-a10: #282828;
                --clr-surface-a20: #3f3f3f;
                --clr-surface-a30: #575757;
                --clr-surface-a40: #717171;
                --clr-surface-a50: #8b8b8b;

                /** Theme tonal surface colors */
                --clr-surface-tonal-a0: #1c191f;
                --clr-surface-tonal-a10: #312e34;
                --clr-surface-tonal-a20: #47444a;
                --clr-surface-tonal-a30: #5f5c61;
                --clr-surface-tonal-a40: #777579;
                --clr-surface-tonal-a50: #918f93;

                --body-bg-color: var(--clr-surface-a0);
                --text-color: var(--clr-light-a0);
                --statBlock-bg-color: var(--clr-surface-a10);
                --stats-bg-color: var(--clr-surface-a20);
                --statBlock-border-color: var(--statBlock-bg-color);
                --statBlock-text-color: var(--text-color);
                --header-text-color: var(--clr-primary-a50);

                --button-bg-color: var(--clr-primary-a20);
                --button-bg-hover-color: var(--clr-primary-a10);
                --button-bg-active-color: var(--clr-primary-a0);
                --button-text-color: var(--clr-dark-a0);
            }
            body {
                background-color: var(--body-bg-color);
                color: var(--text-color);
                margin: 0px;
            }
            #copyright, #repo-info {
                font-size: smaller;
                margin-top: 10px;
            }

            #top-bar {
                display: flex;
                align-items: center;
                justify-content: space-between;
                top: 0px;
                left: 0px;
                right: 0px;
                padding-left: 10px;
                padding-right: 14px; /* Extra room for scroll bar */
                background-color: var(--clr-surface-a10);
                border-bottom: 1px solid var(--clr-surface-a20);
            }

            .load-button input {
                /* Hide the file input element and style its label as a button */
                display: none;
            }
            .load-button label {
                display: block;
                user-select: none;
            }
            button, .load-button label {
                padding: 5px;
                color: var(--button-text-color);
                background-color: var(--button-bg-color);
                border: 0px;
            }
            button {
                border-radius: 8px;
            }
            button:hover, .load-button label:hover {
                background-color: var(--button-bg-hover-color);
            }
            button:active, .load-button label:active {
                background-color: var(--button-bg-active-color);
            }
            button:disabled {
                background-color: var(--clr-surface-a50);
                /* opacity: 0.7; */
            }

            button.instance-action {
                background-color: var(--clr-surface-tonal-a0);
            }
            button.instance-action:hover {
                background-color: var(--clr-surface-tonal-a10);
            }
            button.instance-action:active {
                background-color: var(--clr-surface-tonal-a20);
            }
            button.instance-action:disabled {
                background-color: var(--clr-surface-tonal-a30);
                opacity: 0.7;
            }

            #encounter {
                margin: 10px;
            }

            .encounter-bar p {
                margin: 0px;
            }
            .encounter-bar > * {
                display: inline-block;
                margin-right: 10px;
            }

            .inactive {
                opacity: 0.3;
            }

            .statBlock {
                position: relative; /* For action button */
                display: inline-block;
                vertical-align: top;
                /*
                    22em is empirical width needed to fit full ATK line for "Volcanic Dragon: Ashen Tyrant".
                    Longest ATK line in SRD is "Fallen Warlord: Undefeated Champion",
                    which requires 27em (at 22em, both ATK and Experience lines overflow).
                    27em feels way too wide. Trying 23em, which is enough to stop Fallen Warlord's
                    Experience line from overflowing.
                */
                width: 23em;
                border: 1px ridge var(--statBlock-border-color);
                border-radius: 5px;
                margin-right: 5px;
                margin-top: 5px;
                padding: 5px 10px;
                background-color: var(--statBlock-bg-color);
                color: var(--statBlock-text-color);
            }
            .statBlock h3 {
                margin: 8px 0px;
                color: var(--header-text-color);
            }
            #conditions-editor h3 {
                margin: 0px;
                margin-bottom: 10px;
                color: var(--header-text-color);
            }
            .statBlock p {
                margin: 2px 0px;
            }
            .statBlock .source {
                font-style: italic;
                font-size: smaller;
            }
            .statBlock .tier {
                font-style: italic;
                font-weight: bold;
            }
            .statBlock .description {
                font-size: smaller;
                font-style: italic;
            }
            .statBlock .motives {
                font-size: smaller;
            }
            .statBlock .stats {
                background-color: var(--stats-bg-color);
                border-top: 1px solid var(--clr-surface-a0);
                border-bottom: 1px solid var(--clr-surface-a0);
                padding: 5px;
            }
            .statBlock .statLabel, .statBlock .motivesLabel {
                font-weight: bold;
            }
            .statBlock .experiences {
                border-top: 1px dotted var(--clr-surface-a50);
                margin-top: 2px;
                padding-top: 2px;
            }
            .statBlock .divider {
                margin: 0px 3px;
                font-weight: bold;
            }
            .features {
                margin-left: 0.75em;
            }
            .featuresExpander summary {
                font-weight: bold;
            }
            .features .feature {
                text-indent: -0.75em
            }
            .featureLabel {
                font-style: italic;
                font-weight: bold;
            }

            .instance {
                position: relative; /* For action button */
                margin-top: 10px;
                background-color: var(--stats-bg-color);
                border-radius: 3px;
                padding: 5px;
            }
            .instance h4 {
                margin: 0px;
            }
            .add-conditions, .add-modifications {
                margin: 5px 0px;
            }

            .slots {
                display: inline-block
            }

            .conditions {
                margin-top: 5px
            }
            ul.conditions-list {
                list-style: none;
                display: inline;
                padding: 0px;
                font-size: smaller;
            }
            ul.conditions-list li {
                display: inline-block;
                background-color: var(--clr-surface-a40);
                border-radius: 3px;
                margin-right: 5px;
                margin-bottom: 5px;
                padding: 2px;
            }
            button.inline-delete {
                background-color: transparent;
                color: var(--clr-primary-a50);
                border: 0px;
                border-radius: 3px;
                padding: 0px;
                margin-left: 5px;
                font-size: smaller;
            }
            button.inline-delete:hover {
                background-color: var(--clr-primary-a30);
            }
            button.inline-delete:active {
                background-color: var(--clr-primary-a10);
            }

            button.inline-add {
                border: 0px;
                border-radius: 2px;
                padding: 3px 4px;
            }
            .add-modifications, .add-conditions {
                padding: 10px;
            }

            button.add-conditions-button {
                font-size: smaller;
            }

            button.action {
                float: right;
            }
            .top-actions {
                position: absolute;
                right: 5px;
                top: 5px;
            }
            .top-actions button {
                padding: 2px;
                margin-left: 3px;
                border-radius: 4px;
                font-size: smaller;
            }

            .actions-menu {
                z-index: 999; /* Above most things, below the overlay */
                position: absolute;
                right: 5px;
                top: 30px;
                margin: 0px;
                padding: 0px;
                list-style-type: none;
            }
            .actions-menu button, .actions-menu div {
                border-radius: 0px;
                width: 100%;
                text-align: left;

                /* Force button-likes in the menu to have the same font/size.
                   This does not perfectly match the default for buttons. */
                font-family: serif;
                font-size: inherit;
            }

            .battle-point-advice {
                font-size: smaller;
            }

            #editor-overlay {
                position: fixed;
                z-index: 1000; /* Ensure it is above other content */
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
            }
            .editor {
                position: absolute;
                z-index: 1001; /* Ensure it is above the overlay */
                width: 27em;
                top: 50px;
                left: 50%;
                transform: translateX(-50%);
                background-color: var(--clr-surface-tonal-a10);
                padding: 20px;
                border-radius: 10px;
                box-shadow: 10px 10px 10px black;
            }

            #browsing {
                background-color: var(--clr-surface-a10);
                position: relative;
                width: fit-content; /* TODO: Better to pick a width, table can resize like this */
                padding: 10px;
                margin: 10px;
                border-radius: 10px;
            }
            .browsing-filters {
                display: flex;
                flex-wrap: wrap;
            }
            #browsing-search {
                flex-grow: 1;
            }
            .results th, .results td {
                border: 1px solid var(--clr-surface-a0);
            }
            .results table {
                overflow-y: auto;
                max-width: 48em; /* 44em looks good, 48em is about the width of two statblocks */
                height: 15em;
                display: block;
                /* margin: 0 auto; */
            }
            .results td.nowrap {
                white-space: nowrap;
            }
            .results th, .results td {
                padding: 5px 10px;
                border-top-width: 0;
                border-left-width: 0;
            }
            .results th {
                position: sticky;
                top: 0;
                vertical-align: bottom;
                background: var(--clr-surface-a20); /* Need a background to avoid scrolled rows from showing through */
            }

            /* Keep this last */
            .hidden {
                display: none;
            }
        </style>
    </head>

    <body>
        <datalist id="srd-conditions">
            <option>Hidden</option>
            <option>Restrained</option>
            <option>Vulnerable</option>
            <option>Asleep</option>
            <option>Stunned</option>
            <option>Silenced</option>
            <option>Corroded</option>
            <option>Ranger's Focus</option>
            <option>Cloaked</option>
            <option>Dizzied</option>
            <option>Enveloped</option>
        </datalist>

        <datalist id="modifiable-properties">
            <option>difficulty</option>
            <option>majorThreshold</option>
            <option>severeThreshold</option>
        </datalist>

        <datalist id="srd-environment-types">
            <option>Event</option>
            <option>Exploration</option>
            <option>Social</option>
            <option>Traversal</option>
        </datalist>

        <div id="top-bar">
            <div>
                <button id="add-encounter" title="Create New Encounter">‚ûï Create New Encounter</button>
                <select id="current-encounter"></select>
            </div>
            <div>
                <button id="toggle-encounter-menu" title="Encounter Actions">‚öôÔ∏è</button>
                <menu id="encounter-menu" class="actions-menu hidden">
                    <li><button id="edit-encounter">‚úèÔ∏è Edit Encounter</button></li>
                    <li><button id="delete-encounter">üóëÔ∏è Delete Encounter</button></li>
                    <li><button id="save-encounters">üíæ Download Encounters JSON</button></li>
                    <li><div id="load-encounters-container" class="load-button">
                        <label for="load-encounters" title="Load Encounters (replaces existing encounters)">üìÇ Load Encounters JSON</label>
                        <input type="file" id="load-encounters" accept=".json" />
                    </div></li>
                    <li><button id="export-custom">‚úàÔ∏è Export Custom JSON</button></li>
                    <li><div id="import-custom-container" class="load-button">
                        <label for="import-custom">üéÅ Import Custom JSON</label>
                        <input type="file" id="import-custom" accept=".json" />
                    </div></li>
                </menu>
            </div>
        </div>

        <div id="encounter"></div>

        <!-- TODO: Should all these editors use <dialog>? Safari doesn't support closedBy... -->
        <div id="editor-overlay" class="hidden"></div>
        <div id="encounter-editor" class="editor hidden">
            <form id="encounter-form">
                <label for="encounter-name">Name:</label>
                <input type="text" id="encounter-name" required />
                <br>
                <label for="encounter-tier">Tier:</label>
                <input type="number" id="encounter-tier" min="1" max="4" value="1" required />
                <label for="encounter-player-count">Player Count:</label>
                <input type="number" id="encounter-player-count" min="1" max="20" value="4" required />
                <br>
                <label for="encounter-target-battle-points">Target Battle Points:</label>
                <input type="number" id="encounter-target-battle-points" min="1" max="99" value="14" required />
                <span id="encounter-recommended-battle-points"></span>
                <div class="battle-point-advice">
                    <p>When planning a battle, start with <strong>[(3 x the number of PCs in combat) + 2]</strong> Battle Points and make the following adjustments:</p>
                    <ul>
                        <li><strong>-1</strong> for an easier or shorter fight</li>
                        <li><strong>-2</strong> if you're using 2 or more Solo adversaries</li>
                        <li><strong>-2</strong> if you add +1d4 (or a static +2) to all adversaries' damage rolls</li>
                        <li><strong>+1</strong> if you choose an adversary from a lower tier</li>
                        <li><strong>+1</strong> if you don't include any Bruisers, Hordes, Leaders, or Solos</li>
                        <li><strong>+2</strong> for a harder or longer fight</li>
                    </ul>
                </div>
                <button type="button" id="cancel-encounter-edit">Cancel</button>
                <button type="submit" id="save-encounter-edit">Save Encounter</button>
            </form>
        </div>
        <div id="statBlock-editor" class="editor hidden">
            <form id="statBlock-form">
                <fieldset>
                    <legend>Basics</legend>
                    <label for="statBlock-name">Name:</label>
                    <input type="text" id="statBlock-name" size="30" required />
                    <br>
                    <label for="statBlock-tier">Tier:</label>
                    <input type="number" id="statBlock-tier" min="1" max="4" value="1" required />
                    <span class="statBlock-editor-adversary">
                        <label for="adversary-type">Type:</label>
                        <select id="adversary-type" list="srd-adversary-types">
                            <option>Bruiser</option>
                            <option>Horde</option>
                            <option>Leader</option>
                            <option>Minion</option>
                            <option>Ranged</option>
                            <option>Skulk</option>
                            <option>Social</option>
                            <option>Solo</option>
                            <option>Standard</option>
                            <option>Support</option>
                        </select>
                        <input type="number" id="adversary-count-per-hp" min="1" max="20" value="1" />
                        <label for="adversary-count-per-hp" id="adversary-count-per-hp-label">/HP</label>
                    </span>
                    <span class="statBlock-editor-environment">
                        <label for="environment-type">Type:</label>
                        <input type="text" id="environment-type" list="srd-environment-types" />
                    </span>
                    <br>
                    <label for="statBlock-description">Description:</label>
                    <textarea id="statBlock-description" cols="30" rows="3"></textarea>
                    <div class="statBlock-editor-adversary">
                        <label for="adversary-motives">Motives & Tactics:</label>
                        <textarea id="adversary-motives" cols="30" rows="2"></textarea>
                    </div>
                    <div class="statBlock-editor-environment">
                        <label for="environment-impulses">Impulses:</label>
                        <textarea id="environment-impulses" cols="30" rows="2"></textarea>
                    </div>
                </fieldset>
                <fieldset>
                    <legend>Stats</legend>
                    <label for="statBlock-difficulty">Difficulty:</label>
                    <input type="number" id="statBlock-difficulty" min="0" max="40" value="12" required />
                    <div class="statBlock-editor-adversary">
                        <label for="adversary-major-threshold">Major Threshold:</label>
                        <input type="number" id="adversary-major-threshold" min="0" max="20" value="8" />
                        /
                        <label for="adversary-severe-threshold">Severe Threshold:</label>
                        <input type="number" id="adversary-severe-threshold" min="0" max="20" value="14" />
                        <br>
                        <label for="adversary-hp">HP:</label>
                        <input type="number" id="adversary-hp" min="1" max="40" value="5" />
                        <label for="adversary-stress">Stress:</label>
                        <input type="number" id="adversary-stress" min="0" max="40" value="2" />
                        <br>
                        <label for="adversary-experience">Experience:</label>
                        <input type="text" id="adversary-experience" />
                    </div>
                    <div class="statBlock-editor-environment">
                        <label for="environment-potential-adversaries">Potential Adversaries:</label>
                        <textarea id="environment-potential-adversaries" cols="30" rows="3"></textarea>
                    </div>
                </fieldset>
                <fieldset class="statBlock-editor-adversary">
                    <legend>Attack</legend>
                    <label for="adversary-attack-modifier">Modifier:</label>
                    <input type="text" id="adversary-attack-modifier" size="4" placeholder="e.g. +3" />
                    <label for="adversary-attack-description">Description:</label>
                    <input type="text" id="adversary-attack-description" placeholder="e.g. Mace" />
                    <br>
                    <label for="adversary-attack-range">Range:</label>
                    <select id="adversary-attack-range">
                        <option>Melee</option>
                        <option>Very Close</option>
                        <option>Close</option>
                        <option>Far</option>
                    </select>
                    <label for="adversary-attack-damage">Damage:</label>
                    <input type="text" id="adversary-attack-damage" size="12" placeholder="e.g. 1d10+3 phy" />
                </fieldset>
                <fieldset>
                    <legend>Features</legend>
                    <button id="add-feature">+ Add Feature</button>
                    <div id="statBlock-features"></div>
                </fieldset>
                <button type="button" id="cancel-statBlock-edit">Cancel</button>
                <button type="submit" id="save-statBlock-edit">Save</button>
            </form>
        </div>
        <div id="conditions-editor" class="editor hidden"> <!-- TODO: Position over statBlock instead? -->
            <h3 class="instance-name"></h3>
            <div class="conditions"></div>
            <div class="add-conditions">
                <input type="text" placeholder="Condition Name" list="srd-conditions" id="condition-name">
                <button class="inline-add" id="add-condition">‚ûï Add Condition</button>
            </div>
            <div class="add-modifications">
                <input type="text" placeholder="Modification Name" id="modification-name">
                <input type="text" placeholder="Target Property" list="modifiable-properties" id="modification-property">
                <input type="text" placeholder="Modifier (e.g. -2, +3, 10)" id="modification-value">
                <button class="inline-add" id="add-modification">‚ûï Add Modification</button>
            </div>
            <button id="done-adding-conditions">Close</button>
        </div>

        <div id="browsing">
            <!-- TODO: Allow keyboard navigation of table and adding of statBlocks directly from search input?-->
            <div class="browsing-filters">
                <input id="browsing-search" type="text" placeholder="Search Adversaries & Environments" />
                <select id="browsing-source">
                    <option value="">Any source</option>
                    <option>SRD</option>
                    <option>Custom</option>
                </select>
                <select id="browsing-tier">
                    <option value="">Any tier</option>
                    <option value="1">Tier 1</option>
                    <option value="2">Tier 2</option>
                    <option value="3">Tier 3</option>
                    <option value="4">Tier 4</option>
                </select>
                <select id="browsing-category">
                    <option value="">Any category</option>
                    <option value="Adversary">Adversaries</option>
                    <option value="Environment">Environments</option>
                </select>
                <select id="browsing-type">
                    <option value="">Any type</option>
                    <!-- Hide group when specific categories selected? Would require resetting type if category changes, sometimes -->
                    <optgroup label="Adversaries">
                        <option>Bruiser</option>
                        <option>Horde</option>
                        <option>Leader</option>
                        <option>Minion</option>
                        <option>Ranged</option>
                        <option>Skulk</option>
                        <option>Social</option>
                        <option>Solo</option>
                        <option>Standard</option>
                        <option>Support</option>
                    </optgroup>
                    <optgroup label="Environments">
                        <option>Event</option>
                        <option>Exploration</option>
                        <option>Social</option>
                        <option>Traversal</option>
                    </optgroup>
                </select>
                <button id="browsing-reset-filters">Reset Filters</button>
            </div>
            <div class="results">
                <table>
                    <thead>
                        <tr>
                            <th scope="col"></th>
                            <th scope="col">Name</th>
                            <th scope="col">Type</th>
                            <th scope="col">Description</th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div>
        </div>

        <div id="repo-info">
            <p><em>Now Fear This</em> is free and open source and works entirely offline. Please <a href="https://github.com/sandyarmstrong/nowfearthis/issues">report any bugs or feature requests</a>.</p>
        </div>

        <div id="copyright">
            <p>This project includes materials from the Daggerheart System Reference Document 1.0,
                ¬© Critical Role, LLC. under the terms of the Darrington Press Community Gaming (DPCGL) License.
                More information can be found at <a href="https://www.daggerheart.com">https://www.daggerheart.com</a>.
                Minor formatting modifications were provided as part of the excellent
                <a href="https://github.com/seansbox/daggerheart-srd">https://github.com/seansbox/daggerheart-srd</a>.</p>
            <p>Site favicon courtesy of <a href="https://github.com/twitter/twemoji/blob/master/LICENSE-GRAPHICS">twemoji</a>.</p>
        </div>
    </body>

    <script>
        // TODO: Change all code that puts user data directly into innerHTML

        const statBlockRemovedEvent = new Event("statBlockRemoved");
        const statBlockCopiedEvent = new Event("statBlockCopied");
        const statBlockCopiedFromSourceEvent = new Event("statBlockCopiedFromSource");
        const statBlockSavedToCustomEvent = new Event("statBlockSavedToCustom");
        const statBlockDeletedFromCustomEvent = new Event("statBlockDeletedFromCustom");

        const editorOverlay = document.getElementById("editor-overlay");
        const encounterEditor = document.getElementById("encounter-editor");
        const statBlockEditor = document.getElementById("statBlock-editor");
        const conditionsEditor = document.getElementById("conditions-editor");

        let expandAllFeatures = false;

        function createElement(tagName, className = null, innerText = null) {
            const element = document.createElement(tagName);
            if (className) {
                element.className = className;
            }
            if (innerText) {
                element.innerText = innerText;
            }
            return element;
        }

        function createElementWithInnerHTML(tagName, className, innerHTML) {
            const element = document.createElement(tagName);
            if (className) {
                element.className = className;
            }
            if (innerHTML) {
                element.innerHTML = innerHTML;
            }
            return element;
        }

        document.getElementById("editor-overlay").addEventListener("click", function() {
            if (!statBlockEditor.classList.contains("hidden")) {
                hideStatBlockEditor();
            } else if (!encounterEditor.classList.contains("hidden")) {
                hideEncounterEditor();
            } else if (!conditionsEditor.classList.contains("hidden")) {
                hideConditionsEditor();
            }
        });

        function hideEncounterMenu() {
            const encounterMenu = document.getElementById("encounter-menu");
            encounterMenu.classList.add("hidden");
        }

        document.getElementById("toggle-encounter-menu").addEventListener("click", function() {
            const encounterMenu = document.getElementById("encounter-menu");
            if (encounterMenu.classList.contains("hidden")) {
                encounterMenu.classList.remove("hidden");
            } else {
                hideEncounterMenu();
            }
        });

        function hideStatBlockEditor() {
            const statBlock = statBlockEditor.statBlock;
            statBlockEditor.statBlock = undefined;
            statBlockEditor.classList.add("hidden");
            editorOverlay.classList.add("hidden");
            if (statBlock) {
                const statBlockElements = Array.from(document.querySelectorAll(".statBlock"));
                for (let i = 0; i < statBlockElements.length; i++) {
                    if (statBlockElements[i].statBlock == statBlock) {
                        statBlockElements[i].scrollIntoView({ behavior: "instant", block: "center" });
                    }
                }
            }
        }

        statBlockEditor.addEventListener("keyup", function(event) {
            if (event.keyCode === 27) { // Escape key
                hideStatBlockEditor();
            }
        });

        function createFeatureEditorElement(feature, idSuffix)  {
            const featureElement = document.createElement("div");
            featureElement.className = "feature";
            featureElement.innerHTML = `<label for="statBlock-feature-name-${idSuffix}">Name:</label><input type="text" class="statBlock-feature-name" id="statBlock-feature-name-${idSuffix}" value="${feature?.name ?? ""}" size="30"><label for="statBlock-feature-text-${idSuffix}"><br>Description:</label><textarea id="statBlock-feature-text-${idSuffix}" class="statBlock-feature-text" rows="4" cols="50">${feature?.text ?? ""}</textarea>`;
            return featureElement;
        }

        function refreshCounterPerHpDisplay() {
            const countPerHpInput = statBlockEditor.querySelector("#adversary-count-per-hp");
            if (statBlockEditor.querySelector("#adversary-type").value === "Horde") {
                countPerHpInput.classList.remove("hidden");
                statBlockEditor.querySelector("#adversary-count-per-hp-label").classList.remove("hidden");
            } else {
                countPerHpInput.classList.add("hidden");
                statBlockEditor.querySelector("#adversary-count-per-hp-label").classList.add("hidden");
                statBlockEditor.querySelector("#adversary-count-per-hp").value = 1;
            }
        }

        statBlockEditor.querySelector("#adversary-type").addEventListener("change", function() {
            refreshCounterPerHpDisplay();
        });

        function showStatBlockEditor(statBlock) {
            // Basics
            statBlockEditor.querySelector("#statBlock-name").value = statBlock.name;
            statBlockEditor.querySelector("#statBlock-tier").value = statBlock.tier;
            statBlockEditor.querySelector("#statBlock-description").value = statBlock.description || "";
            statBlockEditor.querySelector("#adversary-motives").value = statBlock.motivesAndTactics || "";
            statBlockEditor.querySelector("#environment-impulses").value = statBlock.impulses || "";

            if (statBlock.category == "Adversary") {
                statBlockEditor.querySelector("#adversary-type").value = statBlock.type;
                statBlockEditor.querySelectorAll(".statBlock-editor-adversary").forEach(function(element) {
                    element.classList.remove("hidden");
                });
                statBlockEditor.querySelectorAll(".statBlock-editor-environment").forEach(function(element) {
                    element.classList.add("hidden");
                });
            } else if (statBlock.category == "Environment") {
                statBlockEditor.querySelector("#environment-type").value = statBlock.type;
                statBlockEditor.querySelectorAll(".statBlock-editor-adversary").forEach(function(element) {
                    element.classList.add("hidden");
                });
                statBlockEditor.querySelectorAll(".statBlock-editor-environment").forEach(function(element) {
                    element.classList.remove("hidden");
                });
            }

            statBlockEditor.querySelector("#adversary-count-per-hp").value = statBlock.countPerHp || 1;
            refreshCounterPerHpDisplay();

            // Stats
            statBlockEditor.querySelector("#statBlock-difficulty").value = statBlock.difficulty;
            statBlockEditor.querySelector("#adversary-major-threshold").value = statBlock.majorThreshold;
            statBlockEditor.querySelector("#adversary-severe-threshold").value = statBlock.severeThreshold;
            statBlockEditor.querySelector("#adversary-hp").value = statBlock.hp;
            statBlockEditor.querySelector("#adversary-stress").value = statBlock.stress;
            statBlockEditor.querySelector("#adversary-experience").value = statBlock.experience || "";
            statBlockEditor.querySelector("#environment-potential-adversaries").value = statBlock.potentialAdversaries || "";

            // Attack
            statBlockEditor.querySelector("#adversary-attack-modifier").value = statBlock.attackModifier || "";
            statBlockEditor.querySelector("#adversary-attack-description").value = statBlock.attackDescription || "";
            statBlockEditor.querySelector("#adversary-attack-range").value = statBlock.attackRange || ""; // TODO: Case mangling as needed
            statBlockEditor.querySelector("#adversary-attack-damage").value = statBlock.attackDamage || "";

            // Features
            const featuresContainer = statBlockEditor.querySelector("#statBlock-features");
            featuresContainer.innerHTML = ""; // Clear any existing children
            if (statBlock.features && statBlock.features.length > 0) {
                for (let i = 0; i < statBlock.features.length; i++) {
                    const feature = statBlock.features[i];
                    const featureElement = createFeatureEditorElement(feature, i);
                    featuresContainer.appendChild(featureElement);
                }
            }

            editorOverlay.classList.remove("hidden");
            statBlockEditor.classList.remove("hidden");
            statBlockEditor.statBlock = statBlock;
            statBlockEditor.querySelector("#statBlock-name").select();
            window.scrollTo(0, 0);
        }

        document.querySelector("#add-feature").addEventListener("click", function() {
            const featureContainer = statBlockEditor.querySelector("#statBlock-features");
            const featureElement = createFeatureEditorElement(null, featureContainer.children.length);
            featureContainer.appendChild(featureElement);
            // TODO: Allow deletion (but could also do this by deleting all text for a feature)
        });

        document.querySelector("#cancel-statBlock-edit").addEventListener("click", function() {
            hideStatBlockEditor();
        });

        document.querySelector("#statBlock-form").addEventListener("submit", function(event) {
            event.preventDefault(); // Prevent page refresh

            const statBlock = statBlockEditor.statBlock;
            if (statBlock) {
                // TODO: Don't set optional fields if empty?

                // Basics
                statBlock.name = statBlockEditor.querySelector("#statBlock-name").value.trim();
                statBlock.tier = parseInt(statBlockEditor.querySelector("#statBlock-tier").value);
                statBlock.description = statBlockEditor.querySelector("#statBlock-description").value.trim();
                statBlock.difficulty = parseInt(statBlockEditor.querySelector("#statBlock-difficulty").value);

                if (statBlock.category == "Adversary") {
                    statBlock.countPerHp = parseInt(statBlockEditor.querySelector("#adversary-count-per-hp").value);
                    statBlock.type = statBlockEditor.querySelector("#adversary-type").value;
                    statBlock.motivesAndTactics = statBlockEditor.querySelector("#adversary-motives").value.trim();

                    // Stats
                    statBlock.majorThreshold = parseInt(statBlockEditor.querySelector("#adversary-major-threshold").value);
                    statBlock.severeThreshold = parseInt(statBlockEditor.querySelector("#adversary-severe-threshold").value);
                    statBlock.hp = parseInt(statBlockEditor.querySelector("#adversary-hp").value);
                    if (statBlock.instances) {
                        statBlock.instances.forEach(function(instance) {
                            instance.hpMarked = Math.min(instance.hpMarked, statBlock.hp);
                        });
                    }
                    statBlock.stress = parseInt(statBlockEditor.querySelector("#adversary-stress").value);
                    if (statBlock.instances) {
                        statBlock.instances.forEach(function(instance) {
                            instance.stressMarked = Math.min(instance.stressMarked, statBlock.stress);
                        });
                    }
                    statBlock.experience = statBlockEditor.querySelector("#adversary-experience").value.trim();

                    // Attack
                    statBlock.attackModifier = statBlockEditor.querySelector("#adversary-attack-modifier").value.trim();
                    statBlock.attackDescription = statBlockEditor.querySelector("#adversary-attack-description").value.trim();
                    statBlock.attackRange = statBlockEditor.querySelector("#adversary-attack-range").value;
                    statBlock.attackDamage = statBlockEditor.querySelector("#adversary-attack-damage").value.trim();
                } else if (statBlock.category == "Environment") {
                    statBlock.type = statBlockEditor.querySelector("#environment-type").value;
                    statBlock.impulses = statBlockEditor.querySelector("#environment-impulses").value;
                    statBlock.potentialAdversaries = statBlockEditor.querySelector("#environment-potential-adversaries").value;
                }

                // Features
                statBlock.features = [];
                const featureElements = statBlockEditor.querySelectorAll("#statBlock-features .feature");
                featureElements.forEach(function(featureElement) {
                    const feature = {
                        name: featureElement.querySelector(".statBlock-feature-name").value.trim(),
                        text: featureElement.querySelector(".statBlock-feature-text").value.trim()
                    };
                    if (feature.name || feature.text) { // TODO: Require both?
                        statBlock.features.push(feature);
                    }
                });
            }

            saveState();
            refreshDisplay();
            hideStatBlockEditor();
        });

        function showConditionsEditor(instance) {
            conditionsEditor.instance = instance;
            conditionsEditor.classList.remove("hidden");
            editorOverlay.classList.remove("hidden");

            conditionsEditor.querySelector(".instance-name").innerText = instance.name;
            updateConditionsDisplay(conditionsEditor.querySelector(".conditions"), instance, true);

            conditionsEditor.querySelector("#condition-name").select();
            window.scrollTo(0, 0);
        }

        function hideConditionsEditor() {
            const instance = conditionsEditor.instance;
            conditionsEditor.instance = undefined;
            conditionsEditor.classList.add("hidden");
            editorOverlay.classList.add("hidden");

            refreshDisplay(); // TODO: A more efficient way to update just the conditions div, maybe a callback?

            if (instance) {
                const instanceElements = Array.from(document.querySelectorAll(".instance"));
                for (let i = 0; i < instanceElements.length; i++) {
                    if (instanceElements[i].instance == instance) {
                        instanceElements[i].scrollIntoView({ behavior: "instant", block: "center" });
                    }
                }
            }
        }

        conditionsEditor.addEventListener("keyup", function(event) {
            if (event.keyCode === 27) { // Escape key
                hideConditionsEditor();
            }
        });

        document.querySelector("#done-adding-conditions").addEventListener("click", function(event) {
            hideConditionsEditor();
        });

        document.querySelector("#add-condition").addEventListener("click", function(event) {
            const instance = conditionsEditor.instance;
            if (!instance) {
                return;
            }

            const addConditionInput = conditionsEditor.querySelector("#condition-name");
            const conditionsDiv = conditionsEditor.querySelector(".conditions");

            const condition = addConditionInput.value.trim();
            if (condition && (!instance.conditions || !instance.conditions.includes(condition))) {
                if (!instance.conditions) {
                    instance.conditions = [];
                }
                instance.conditions.push(condition);
                addConditionInput.value = "";
                saveState();
                updateConditionsDisplay(conditionsDiv, instance, true);
            }
        });

        document.querySelector("#condition-name").addEventListener("keyup", function(event) {
            if (event.keyCode === 13) { // Enter key
                event.preventDefault();
                document.querySelector("#add-condition").click();
            }
        });

        document.querySelector("#add-modification").addEventListener("click", function(evenet) {
            const instance = conditionsEditor.instance;
            if (!instance) {
                return;
            }

            const addModificationNameInput = conditionsEditor.querySelector("#modification-name");
            const addModificationPropertyInput = conditionsEditor.querySelector("#modification-property");
            const addModificationValueInput = conditionsEditor.querySelector("#modification-value");
            const conditionsDiv = conditionsEditor.querySelector(".conditions");

            const modificationName = addModificationNameInput.value.trim();
            const propertyName = addModificationPropertyInput.value.trim();
            const modificationValue = addModificationValueInput.value.trim();
            if (modificationName && propertyName && modificationValue) {
                if (!instance.modifications) {
                    instance.modifications = [];
                }
                instance.modifications.push({
                    modificationName: modificationName,
                    propertyName: propertyName,
                    modification: modificationValue
                });
                addModificationNameInput.value = "";
                addModificationPropertyInput.value = "";
                addModificationValueInput.value = "";
                saveState();
                updateConditionsDisplay(conditionsDiv, instance, true);
            }
        });

        function hideEncounterEditor() {
            encounterEditor.classList.add("hidden");
            editorOverlay.classList.add("hidden");
        }

        encounterEditor.addEventListener("keyup", function(event) {
            if (event.keyCode === 27) { // Escape key
                hideEncounterEditor();
            }
        });

        function updateEditorBattlePointsRecommendation() {
            const playerCount = parseInt(document.querySelector("#encounter-player-count").value);
            const recommendedBattlePoints = (3 * playerCount) + 2;
            document.querySelector("#encounter-recommended-battle-points").innerText = `(Base recommendation: ${recommendedBattlePoints})`;
        }

        function showEncounterEditor(encounter) {
            if (!encounter) {
                encounter = {
                    name: "New Encounter",
                    playerTier: 1,
                    playerCount: 4,
                    targetBattlePoints: 14, // TODO: Automatically adjust when playerCount changes?
                };
                encounterEditor.encounter = null;
            } else {
                encounterEditor.encounter = encounter;
            }

            encounterEditor.querySelector("#encounter-name").value = encounter.name;
            encounterEditor.querySelector("#encounter-tier").value = encounter.playerTier ?? 1;
            encounterEditor.querySelector("#encounter-player-count").value = encounter.playerCount ?? 4;
            encounterEditor.querySelector("#encounter-target-battle-points").value = encounter.targetBattlePoints ?? 14;

            updateEditorBattlePointsRecommendation();

            editorOverlay.classList.remove("hidden");
            encounterEditor.classList.remove("hidden");
            encounterEditor.querySelector("#encounter-name").select();
            window.scrollTo(0, 0);
        }

        document.querySelector("#encounter-form").addEventListener("submit", function(event) {
            event.preventDefault(); // Prevent page refresh

            let encounter = encounterEditor.encounter;
            if (!encounter) {
                if (!state.encounters) {
                    state.encounters = [];
                }
                encounter = {}
                state.encounters.push(encounter);
                selectedEncounterIndex = state.encounters.length - 1;
            }

            encounter.name = encounterEditor.querySelector("#encounter-name").value.trim();
            encounter.playerTier = parseInt(encounterEditor.querySelector("#encounter-tier").value);
            encounter.playerCount = parseInt(encounterEditor.querySelector("#encounter-player-count").value);
            encounter.targetBattlePoints = parseInt(encounterEditor.querySelector("#encounter-target-battle-points").value);

            saveState();
            refreshDisplay();
            hideEncounterEditor();

            updateBrowsingTier();
        });

        document.querySelector("#cancel-encounter-edit").addEventListener("click", function() {
            hideEncounterEditor();
        });

        document.querySelector("#add-encounter").addEventListener("click", function() {
            showEncounterEditor();
        });

        document.querySelector("#edit-encounter").addEventListener("click", function() {
            const encounter = state.encounters[selectedEncounterIndex];
            showEncounterEditor(encounter);
            hideEncounterMenu();
        });

        document.querySelector("#delete-encounter").addEventListener("click", function() {
            if (state.encounters && state.encounters.length > 0) {
                state.encounters.splice(selectedEncounterIndex, 1);
                selectedEncounterIndex = Math.min(selectedEncounterIndex, state.encounters.length - 1);
                saveState();
                if (state.encounters.length === 0) {
                    showEncounterEditor();
                }
                refreshDisplay();
            }
            hideEncounterMenu();
        });

        document.querySelector("#encounter-player-count").addEventListener("change", function() {
            updateEditorBattlePointsRecommendation();
        });

        // TODO: This is annoying if you are scrolled down, and every statBlock above changes expansion,
        //       messing with your scroll position. Fix scroll position or just don't do this.
        function handleFeaturesToggle(event) {
            const opened = event.target.open;
            if (expandAllFeatures != opened) {
                expandAllFeatures = opened;
                for (const element of document.getElementsByClassName("featuresExpander")) {
                    if (element.open != expandAllFeatures) {
                        element.open = expandAllFeatures;
                    }
                }
            }
        }

        function statBlockMatchesSearch(statBlock, searchText) {
            if (!searchText) {
                return true;
            }

            const statBlockName = statBlock.name.toLowerCase();
            // TODO: Include potentialAdversaries? But only if also shown in Description cell?
            const statBlockDescription = statBlock.description.toLowerCase();
            const statBlockType = statBlock.type.toLowerCase();
            const statBlockCategory = statBlock.category.toLowerCase();

            // All terms must match somewhere
            const terms = searchText.toLowerCase().split(/\s+/);
            for (const term of terms) {
                if (!term) {
                    continue; // Skip empty terms
                }
                if (!(statBlockName.includes(term) ||
                    statBlockDescription.includes(term) ||
                    statBlockType.includes(term) ||
                    statBlockCategory.includes(term))) {
                    return false;
                }
            }

            return true;
        }

        function updateBrowsingTier() {
            if (state.encounters && selectedEncounterIndex < state.encounters.length) {
                // Update the tier dropdown based on the current encounter
                document.querySelector("#browsing-tier").value = state.encounters[selectedEncounterIndex].playerTier || "";
            }
        }

        function updateBrowsingTableFiltering() {
            const selectedSource = document.querySelector("#browsing-source").value;
            const selectedTier = parseInt(document.querySelector("#browsing-tier").value);
            const selectedCategory = document.querySelector("#browsing-category").value;
            const selectedType = document.querySelector("#browsing-type").value;
            const searchText = document.querySelector("#browsing-search").value;

            const rows = browsingTableBody.querySelectorAll("tr");
            rows.forEach(function(row) {
                if ((!selectedSource || row.statBlock.source == selectedSource) &&
                    (!selectedTier || row.statBlock.tier == selectedTier) &&
                    (!selectedCategory || row.statBlock.category == selectedCategory) &&
                    (!selectedType || row.statBlock.type == selectedType) &&
                    (!searchText || statBlockMatchesSearch(row.statBlock, searchText))) {
                    row.style.display = "";
                } else {
                    row.style.display = "none";
                }
            });
        }

        document.querySelector("#browsing-search").addEventListener("input", function(event) {
            updateBrowsingTableFiltering();
        });
        document.querySelector("#browsing-source").addEventListener("change", function(event) {
            updateBrowsingTableFiltering();
        });
        document.querySelector("#browsing-tier").addEventListener("change", function(event) {
            updateBrowsingTableFiltering();
        });
        document.querySelector("#browsing-type").addEventListener("change", function(event) {
            updateBrowsingTableFiltering();
        });
        document.querySelector("#browsing-category").addEventListener("change", function(event) {
            updateBrowsingTableFiltering();
        });
        document.querySelector("#browsing-reset-filters").addEventListener("click", function(event) {
            document.querySelector("#browsing-search").value = "";
            document.querySelector("#browsing-source").value = "";
            document.querySelector("#browsing-tier").value = "";
            document.querySelector("#browsing-category").value = "";
            document.querySelector("#browsing-type").value = "";
            updateBrowsingTableFiltering();
        });

        function createFearTracker(encounter) {
            const maxFear = 12;
            // TODO: Nice simple rich tooltip guide: https://jsfiddle.net/8nnwytbL/
            // TODO: Roller for getting fear on rests?
            // TODO: Replace this with a stylized number input?
            const fearDiv = document.createElement("div");
            const fearValue = document.createElement("span");
            const useFearButton = createElement("button", null, "-");
            useFearButton.title = "Use 1 Fear";
            const gainFearButton = createElement("button", null, "+");
            gainFearButton.title = "Gain 1 Fear (max 12)";

            if (encounter.currentFear === undefined) {
                encounter.currentFear = 0;
            }

            function updateFearDisplay() {
                fearValue.innerHTML = "";
                fearValue.title = `${encounter.currentFear} Fear | Start: {number of PCs} | Short rest: 1d4 | Long rest: 1d4 + {number of PCs}`;

                for (let i = 0; i < maxFear; i++) {
                    const fearIcon = createElement("span", "fear-icon", "üíÄ");
                    if (i >= encounter.currentFear) {
                        fearIcon.classList.add("inactive");
                    }
                    fearValue.appendChild(fearIcon);
                }

                useFearButton.disabled = encounter.currentFear <= 0;
                gainFearButton.disabled = encounter.currentFear >= maxFear;
            }
            updateFearDisplay();

            useFearButton.onclick = function() {
                if (encounter.currentFear > 0) {
                    encounter.currentFear--;
                    updateFearDisplay();
                    saveState();
                }
            };

            gainFearButton.onclick = function() {
                if (encounter.currentFear < maxFear) {
                    encounter.currentFear++;
                    updateFearDisplay();
                    saveState();
                }
            };

            fearDiv.appendChild(useFearButton);
            fearDiv.appendChild(fearValue);
            fearDiv.appendChild(gainFearButton);

            return fearDiv;
        }

        function refreshBattlePoints() {
            const encounter = state.encounters[selectedEncounterIndex];
            const battlePointsDiv = document.querySelector("#battle-points");
            const currentBattlePoints = calculateBattlePoints(encounter);

            // Round to nearest 0.1 for display
            const remainingBattlePoints = Math.round((encounter.targetBattlePoints - currentBattlePoints) * 10) / 10;

            if (remainingBattlePoints < 0) {
                battlePointsDiv.querySelector("[name='current-battle-points']").innerText = `‚ö†Ô∏è ${Math.abs(remainingBattlePoints)}`;
                battlePointsDiv.querySelector("[name='remaining-suffix']").innerText = "over";
            } else {
                battlePointsDiv.querySelector("[name='current-battle-points']").innerText = Math.abs(remainingBattlePoints);
                battlePointsDiv.querySelector("[name='remaining-suffix']").innerText = "left";
            }
        }

        function addStatBlockToSearch(statBlock) {
            // Datalist for basic search
            const option = document.createElement("option");
            option.statBlock = statBlock;
            option.value = statBlock.name;
            statBlockDatalist.appendChild(option);

            // Table for browsing
            const tr = document.createElement("tr");
            tr.statBlock = statBlock;
            browsingTableBody.appendChild(tr);

            const addButtonTD = createElement("td", "nowrap");
            const addButton = createElement("button", null, "‚ûï Add");
            addButton.addEventListener("click", function(event) {
                const statBlockCopy = JSON.parse(JSON.stringify(tr.statBlock));
                if (statBlockCopy.category == "Adversary" && (!statBlockCopy.instances || statBlockCopy.instances.length == 0)) {
                    statBlockCopy.instances = [
                        {
                            name: statBlockCopy.name + " #1",
                            hpMarked: 0,
                            stressMarked: 0
                        }
                    ];
                }
                const encounter = state.encounters[selectedEncounterIndex];
                // TODO: What if there is no encounter?
                if (!encounter.statBlocks) {
                    encounter.statBlocks = [];
                }
                encounter.statBlocks.push(statBlockCopy);
                addStatBlock(
                    document.querySelector("#encounter .statBlocks"),
                    encounter,
                    statBlockCopy,
                    refreshBattlePoints);
                saveState();
            });
            addButtonTD.appendChild(addButton);
            tr.appendChild(addButtonTD);

            const nameTD = createElement("td", null, statBlock.name);
            tr.appendChild(nameTD);

            // TODO: Could add pts, but we'd have to recalc when player count changes
            // const encounter = state.encounters[selectedEncounterIndex];
            // const battlePoints = getStatBlockBattlePoints(adversary.type, encounter?.playerCount ?? 1);
            // typeTD.innerText = `${adversary.type} (${battlePoints} pts)`;
            const typeTD = createElement("td", "nowrap", statBlock.type);
            tr.appendChild(typeTD);

            const descriptionTD = createElement("td", null, statBlock.description);
            tr.appendChild(descriptionTD);
        }

        function updateResource(container, adversary, adversarySlotsPropertyName, instance, instanceMarkedPropertyName) {
            const elements = [];
            const slots = adversary[adversarySlotsPropertyName];
            const marked = instance[instanceMarkedPropertyName];

            // TODO: Reduce opacity or something when HP is fully marked?
            //       - Would also need to do it on initial/refresh layout
            //       - Would also need to differentiate between HP and Stress
            // TODO: Add "Vulnerable (stress full)" condition when stress is fully marked?
            //       Would have to make sure it couldn't be deleted otherwise though.

            for (let i = 0; i < slots; i++) {
                const slot = document.createElement("input");
                slot.type = "checkbox";
                if (i < marked) {
                    slot.checked = true;
                }
                slot.onclick = function(event) {
                    if (event.target.checked) {
                        instance[instanceMarkedPropertyName]++;
                    } else {
                        instance[instanceMarkedPropertyName]--;
                    }
                    saveState();
                    updateResource(container, adversary, adversarySlotsPropertyName, instance, instanceMarkedPropertyName);
                };
                elements.push(slot);
            }

            container.replaceChildren(...elements);
        }

        function setupStatBlockActionButton(statBlockElement, statBlock) {
            const actionsMenu = createElement("menu", "actions-menu");

            const copyAction = createElementWithInnerHTML("li", null, `<button class="menu-action">Duplicate</button>`);
            copyAction.title = "Copy this stat block, including all changed state";
            copyAction.onclick = function() {
                statBlockElement.dispatchEvent(statBlockCopiedEvent);
                actionsMenu.remove();
            };
            actionsMenu.appendChild(copyAction);

            const copyFromSourceAction = createElementWithInnerHTML("li", null, `<button class="menu-action">Copy From Source</button>`);
            copyFromSourceAction.title = "Copy this stat block from the source, ignoring all changes";
            copyFromSourceAction.onclick = function() {
                statBlockElement.dispatchEvent(statBlockCopiedFromSourceEvent);
                actionsMenu.remove();
            };
            actionsMenu.appendChild(copyFromSourceAction);

            const saveCustomAction = createElementWithInnerHTML("li", null, `<button class="menu-action">Save to Custom Stat Blocks</button>`);
            // TODO: Disable when no changes have been made?
            saveCustomAction.title = "Save this stat block to your custom stat blocks for later use";
            saveCustomAction.onclick = function() {
                statBlockElement.dispatchEvent(statBlockSavedToCustomEvent);
                actionsMenu.remove();
            };
            actionsMenu.appendChild(saveCustomAction);

            const deleteCustomAction = document.createElement("li");
            deleteCustomAction.innerHTML = `<button class="menu-action" ${statBlock.source == 'Custom' ? '' : 'disabled'}>Delete from Custom Stat Blocks</button>`;
            deleteCustomAction.title = "Delete from your custom stat blocks";
            deleteCustomAction.onclick = function() {
                statBlockElement.dispatchEvent(statBlockDeletedFromCustomEvent);
                actionsMenu.remove();
            };
            actionsMenu.appendChild(deleteCustomAction);

            const topActions = document.createElement("div");
            topActions.className = "top-actions";
            statBlockElement.appendChild(topActions);

            if (statBlock.category == "Adversary") {
                const addInstanceButton = createElement("button", null, "‚ûï");
                addInstanceButton.title = "Add another instance of this adversary";
                addInstanceButton.onclick = function() {
                    const newInstance = {
                        // TODO: Review naming, this doesn't work well if you add several, delete several, add again.
                        //       May need to parse the names to find the largest, like we do for statBlock display names.
                        name: statBlock.name + " #" + (statBlock.instances.length + 1),
                        hpMarked: 0,
                        stressMarked: 0
                    };
                    if (!statBlock.instances) {
                        statBlock.instances = [];
                    }
                    statBlock.instances.push(newInstance);
                    saveState();
                    refreshDisplay();
                };
                topActions.appendChild(addInstanceButton);
            }

            const editButton = createElement("button", null, "‚úèÔ∏è");
            editButton.title = "Edit this stat block";
            editButton.onclick = function() {
                showStatBlockEditor(statBlock);
            };
            topActions.appendChild(editButton);

            const deleteButton = createElement("button", null, "üóëÔ∏è");
            deleteButton.title = "Remove this stat block from the encounter";
            deleteButton.onclick = function() {
                statBlockElement.dispatchEvent(statBlockRemovedEvent);
            };
            topActions.appendChild(deleteButton);

            const actionsButton = createElement("button", null, "üé≠");
            actionsButton.title = "Stat block management actions";
            actionsButton.onclick = function() {
                if (actionsMenu.parentElement) {
                    actionsMenu.remove();
                } else {
                    statBlockElement.appendChild(actionsMenu);
                }
            };
            topActions.appendChild(actionsButton);
        }

        function updateConditionsDisplay(container, instance, inDialog) {
            container.innerHTML = "";

            const conditionsList = document.createElement("ul");
            conditionsList.className = "conditions-list";
            container.appendChild(conditionsList);
            let hasConditionsOrModifications = false;

            if (instance.conditions && instance.conditions.length > 0) {
                for (let i = 0; i < instance.conditions.length; i++) {
                    hasConditionsOrModifications = true;
                    const condition = instance.conditions[i];

                    const conditionItem = document.createElement("li");
                    conditionsList.appendChild(conditionItem);

                    conditionItem.appendChild(createElement("span", null, condition));

                    const removeButton = createElement("button", "inline-delete", "‚ùå");
                    removeButton.title = "Remove condition";
                    removeButton.onclick = function(event) {
                        instance.conditions = instance.conditions.filter(function(c) {
                            return c !== condition;
                        });
                        updateConditionsDisplay(container, instance, inDialog);
                        saveState();
                    };
                    conditionItem.appendChild(removeButton);
                }
            }

            if (instance.modifications && instance.modifications.length > 0) {
                for (let i = 0; i < instance.modifications.length; i++) {
                    hasConditionsOrModifications = true;
                    const modification = instance.modifications[i];

                    const modificationItem = document.createElement("li");
                    conditionsList.appendChild(modificationItem);

                    const modificationText = createElement(
                        "span",
                        null,
                        `${modification.modificationName} (${modification.propertyName} ${modification.modification})`);
                    modificationItem.appendChild(modificationText);

                    const removeButton = createElement("button", "inline-delete", "‚ùå");
                    removeButton.title = "Remove modification";
                    removeButton.onclick = function(event) {
                        instance.modifications = instance.modifications.filter(function(m) {
                            return m !== modification;
                        });
                        updateConditionsDisplay(container, instance, inDialog);
                        saveState();
                    };
                    modificationItem.appendChild(removeButton);
                }
            }

            if (inDialog && !hasConditionsOrModifications) {
                conditionsList.appendChild(createElement("li", "placeholder", "No conditions or modifications, add below"));
            }

            if (!inDialog) {
                const editConditions = createElement("button", "add-conditions-button", "Add Conditions");
                editConditions.title = "Add conditions or modifications to this adversary instance";
                editConditions.onclick = function(event) {
                    showConditionsEditor(instance);
                }
                conditionsList.appendChild(editConditions);
            }
        }

        function createStatBlockElement(encounter, statBlock) {
            // TODO: Allow reordering?

            let warning = "";
            if (statBlock.tier > encounter.playerTier) {
                warning += "‚ö†Ô∏è above player tier";
            } else if (statBlock.tier < encounter.playerTier) {
                warning += "‚ö†Ô∏è below player tier"
            }

            const statBlockDiv = document.createElement("div");
            statBlockDiv.className = "statBlock";
            statBlockDiv.statBlock = statBlock;
            statBlockDiv.innerHTML = `<h3 title="Source: ${statBlock.originalName}, ${statBlock.source} ">${statBlock.name}</h3>`;

            let tierTypeSuffix = "";
            let tierTypeSuffixComponents = [];
            if (statBlock.countPerHp > 1 || statBlock.type === "Horde") {
                tierTypeSuffixComponents.push(`${statBlock.countPerHp}/HP`);
            }
            if (statBlock.category === "Adversary") {
                const battlePoints = getStatBlockBattlePoints(statBlock.type, encounter.playerCount) * (statBlock.instances?.length || 0);
                tierTypeSuffixComponents.push(`${battlePoints} pts`);
            }
            if (warning) {
                tierTypeSuffixComponents.push(warning);
            }
            if (tierTypeSuffixComponents.length > 0) {
                tierTypeSuffix = ` (${tierTypeSuffixComponents.join(", ")})`;
            }

            const tierAndType = createElement("p", "tier", `Tier ${statBlock.tier} ${statBlock.type}${tierTypeSuffix}`);
            statBlockDiv.appendChild(tierAndType);

            if (statBlock.description) {
                statBlockDiv.appendChild(createElement("p", "description", statBlock.description));
            }

            if (statBlock.motivesAndTactics) {
                const motives = document.createElement("p");
                motives.className =  "motives";
                motives.innerHTML = `<span class="motivesLabel">Motives & Tactics:</span> ${statBlock.motivesAndTactics}`;
                statBlockDiv.appendChild(motives);
            }
            if (statBlock.impulses) {
                const impulses = document.createElement("p");
                impulses.className =  "motives";
                impulses.innerHTML = `<span class="motivesLabel">Impulses:</span> ${statBlock.impulses}`;
                statBlockDiv.appendChild(impulses);
            }

            const stats = document.createElement("p");
            stats.className = "stats";

            const difficultyDiv = document.createElement("div");
            stats.appendChild(difficultyDiv);
            difficultyDiv.appendChild(createElement("span", "statLabel", "Difficulty:"));
            difficultyDiv.appendChild(document.createTextNode(` ${statBlock.difficulty} `));

            if (statBlock.majorThreshold || statBlock.severeThreshold) {
                let majorThreshold = statBlock.majorThreshold || "None";
                let severeThreshold = statBlock.severeThreshold || "None";
                thresholds = `${majorThreshold}/${severeThreshold}`;

                difficultyDiv.appendChild(createElement("span", "divider", "|"));
                difficultyDiv.appendChild(document.createTextNode(" "));
                difficultyDiv.appendChild(createElement("span", "statLabel", "Thresholds:"));
                difficultyDiv.appendChild(document.createTextNode(` ${thresholds}`));
            }

            if (statBlock.attackDescription) {
                stats.innerHTML += `<div><span class="statLabel">ATK:</span> ${statBlock.attackModifier} <span class="divider">|</span> <span class="statLabel">${statBlock.attackDescription}:</span> ${statBlock.attackRange} <span class="divider">|</span> ${statBlock.attackDamage}</div>`;
            }
            if (statBlock.experience) {
                stats.innerHTML += `<div class="experiences"><span class="statLabel">Experience:</span> ${statBlock.experience}</div>`;
            }
            if (statBlock.potentialAdversaries) {
                stats.innerHTML += `<div><span class="statLabel">Potential Adversaries:</span> ${statBlock.potentialAdversaries}</div>`;
            }
            statBlockDiv.appendChild(stats);

            if (statBlock.features && statBlock.features.length > 0) {
                const featuresContainer = createElementWithInnerHTML("details", "featuresExpander", `<summary>FEATURES</summary>`);
                featuresContainer.open = expandAllFeatures;
                const featuresDiv = createElement("div", "features");
                featuresContainer.appendChild(featuresDiv);
                featuresContainer.addEventListener("toggle", handleFeaturesToggle);

                for (let i = 0; i < statBlock.features.length; i++) {
                    const featureElement = createElement("p", "feature");
                    featuresDiv.appendChild(featureElement);

                    featureElement.appendChild(createElement("span", "featureLabel", `${statBlock.features[i].name}:`));
                    featureElement.appendChild(createElement("span", null, ` ${statBlock.features[i].text}`));
                }

                statBlockDiv.appendChild(featuresContainer);
            }

            for (let i = 0; i < statBlock.instances?.length || 0; i++) {
                const instance = statBlock.instances[i];

                const instanceDiv = createElement("div", "instance");
                instanceDiv.instance = instance;
                statBlockDiv.appendChild(instanceDiv);

                const instanceName = document.createElement("input")
                instanceName.type = "text";
                instanceName.size = 30;
                instanceName.value = instance.name;
                instanceName.addEventListener("input", function(event) {
                    instance.name = event.target.value;
                    saveState();
                });
                instanceDiv.appendChild(instanceName);

                const hpDiv = createElementWithInnerHTML("div", "slotInfo", "HP:");
                const hpSlotsDiv = createElement("div", "slots");
                updateResource(hpSlotsDiv, statBlock, "hp", instance, "hpMarked");
                hpDiv.appendChild(hpSlotsDiv);
                instanceDiv.appendChild(hpDiv);

                const stressDiv = createElement("div", "slotInfo", "Stress:");
                const stressSlotsDiv = createElement("div", "slots");
                updateResource(stressSlotsDiv, statBlock, "stress", instance, "stressMarked");
                stressDiv.appendChild(stressSlotsDiv);
                instanceDiv.appendChild(stressDiv);

                const conditionsDiv = createElement("div", "conditions");
                instanceDiv.appendChild(conditionsDiv);
                updateConditionsDisplay(conditionsDiv, instance, false);

                const instanceTopActions = createElement("div", "top-actions");
                instanceDiv.appendChild(instanceTopActions);

                const removeInstanceButton = createElement("button", "instance-action", "üóëÔ∏è");
                removeInstanceButton.title = "Remove this instance of the adversary";
                removeInstanceButton.onclick = function(event) {
                    event.target.closest(".instance").remove();
                    statBlock.instances = statBlock.instances.filter(function(i) {
                        return i !== instance;
                    });
                    saveState();
                    refreshDisplay();
                };
                instanceTopActions.appendChild(removeInstanceButton);
            }

            setupStatBlockActionButton(statBlockDiv, statBlock);

            return statBlockDiv;
        }

        function addStatBlock(container, encounter, statBlock) {
            const statBlockElement = createStatBlockElement(encounter, statBlock);

            statBlockElement.addEventListener("statBlockRemoved", function(event) {
                encounter.statBlocks = encounter.statBlocks.filter(function(a) {
                    return a !== statBlock;
                });
                container.removeChild(statBlockElement);
                refreshBattlePoints();
                saveState();
            });
            statBlockElement.addEventListener("statBlockCopied", function(event) {
                const newStatBlock = JSON.parse(JSON.stringify(statBlock));
                newStatBlock.name += " (copy)"; // TODO: Decide naming
                if (!encounter.statBlocks) {
                    encounter.statBlocks = [];
                }
                encounter.statBlocks.push(newStatBlock);
                addStatBlock(container, encounter, newStatBlock);
                saveState();
            });
            statBlockElement.addEventListener("statBlockCopiedFromSource", function(event) {
                // TODO: This is mostly a dupe of addStatBlockButton.onclick
                let newStatBlock = null;
                if (statBlock.source == "SRD") {
                    const sourceStatBlock = srdStatBlocks.find(function(a) {
                        return a.name === statBlock.originalName;
                    });
                    newStatBlock = JSON.parse(JSON.stringify(sourceStatBlock));
                } else if (statBlock.source == "Custom" && state.custom && state.custom.statBlocks) { // TODO: Case-insensive?
                    const sourceStatBlock = state.custom.statBlocks.find(function(a) {
                        return a.name === statBlock.originalName;
                    });
                    newStatBlock = JSON.parse(JSON.stringify(sourceStatBlock));
                } else {
                    console.warn("Only 'SRD' and 'Custom' sources are supported");
                    return;
                }

                if (newStatBlock.category == "Adversary" && !newStatBlock.instances || newStatBlock.instances.length == 0) {
                    newStatBlock.instances = [
                        {
                            name: newStatBlock.name + " #1",
                            hpMarked: 0,
                            stressMarked: 0
                        }
                    ];
                }

                if (!encounter.statBlocks) {
                    encounter.statBlocks = [];
                }
                encounter.statBlocks.push(newStatBlock);
                addStatBlock(container, encounter, newStatBlock);
                saveState();
            });
            statBlockElement.addEventListener("statBlockSavedToCustom", function(event) {
                statBlock.source = "Custom";
                statBlock.originalName = statBlock.name; // TODO: Enforce unique names (easy here, hard if we offer import)
                const newCustomStatBlock = JSON.parse(JSON.stringify(statBlock));
                delete newCustomStatBlock.instances;
                if (!state.custom) {
                    state.custom = {};
                }
                if (!state.custom.statBlocks) {
                    state.custom.statBlocks = [];
                }
                state.custom.statBlocks.push(newCustomStatBlock);
                saveState();
                refreshDisplay(); // To add to search
            });
            statBlockElement.addEventListener("statBlockDeletedFromCustom", function(event) {
                if (statBlock.source !== "Custom") {
                    console.warn("Trying to delete a non-custom statBlock from custom list");
                    return;
                }
                if (!state.custom) {
                    state.custom = {};
                }
                if (!state.custom.statBlocks) {
                    state.custom.statBlocks = [];
                }
                state.custom.statBlocks = state.custom.statBlocks.filter(function(a) {
                    return a.name !== statBlock.originalName;
                });
                statBlock.source = "Orphaned";
                saveState();
                refreshDisplay();
            });

            container.appendChild(statBlockElement);
            refreshBattlePoints();
        }

        function getStatBlockBattlePoints(adversaryType, playerCount) {
            switch(adversaryType.toLowerCase()) {
                case "minion":
                    return 1 / playerCount;
                case "social":
                case "support":
                    return 1;
                case "horde":
                case "ranged":
                case "skulk":
                case "standard":
                    return 2;
                case "leader":
                    return 3;
                case "bruiser":
                    return 4;
                case "solo":
                    return 5;
                default:
                    console.warn("Unknown adversary type:", adversaryType);
                    return 0;
            }
        }

        function calculateBattlePoints(encounter)
        {
            let currentBattlePoints = 0;
            for (let j = 0; j < encounter.statBlocks.length; j++) {
                const statBlock = encounter.statBlocks[j];
                const adversaryPoints = statBlock.category == "Adversary" ? getStatBlockBattlePoints(statBlock.type, encounter.playerCount) : 0;
                // TODO: Deal with tier differences
                currentBattlePoints += adversaryPoints * (statBlock.instances?.length || 0);
            }
            return currentBattlePoints;
        }

        function refreshDisplay() {
            encounterSelector.innerHTML = ""; // Clear any existing options
            const encounterDiv = document.getElementById("encounter");
            encounterDiv.className = "encounter";
            encounterDiv.innerHTML = ""; // Clear any existing content

            if (!state || !state.encounters || state.encounters.length == 0) {
                const noEncounters = createElement("p");
                encounterDiv.appendChild(noEncounters);
                const noEncountersSpan = createElement("span", null, "No encounters found. You can create a new encounter above, or ");
                noEncounters.appendChild(noEncountersSpan);
                const loadSamplesButon = createElement("button", "load-samples", "Load Sample Encounters");
                noEncounters.appendChild(loadSamplesButon)
                loadSamplesButon.addEventListener("click", () => {
                    state = JSON.parse(JSON.stringify(sampleEncounters));
                    selectedEncounterIndex = 0;
                    saveState();
                    refreshDisplay();
                });
                return;
            }

            const encounter = state.encounters[selectedEncounterIndex];

            for (let i = 0; i < state.encounters.length; i++) {
                const encounter = state.encounters[i];
                // TODO: Validate various fields
                const option = createElement("option", null, `${encounter.name} (Tier ${encounter.playerTier} | ${encounter.playerCount} Players)`);
                option.value = i;
                encounterSelector.appendChild(option);
            }

            const validatedEncounterIndex = Math.max(0, Math.min(selectedEncounterIndex, state.encounters.length - 1));
            if (encounterSelector.value !== validatedEncounterIndex) {
                encounterSelector.value = validatedEncounterIndex;
            }

            // Clear custom entries from search
            for (let i = statBlockDatalist.children.length - 1; i >= 0; i--) {
                const option = statBlockDatalist.children[i];
                if (option.statBlock.source !== "SRD") {
                    option.remove();
                }
            }
            for (let i = browsingTableBody.children.length - 1; i >= 0; i--) {
                const row = browsingTableBody.children[i];
                if (row.statBlock.source !== "SRD") {
                    row.remove();
                }
            }

            // Add custom entries
            // TODO: Sort alpha by name, mixing sources (environments should also be mixed/sorted)
            // TODO: This is not encounter-specific data, should it not be refreshed here?
            if (state.custom && state.custom.statBlocks && state.custom.statBlocks.length > 0) {
                state.custom.statBlocks.forEach(function(statBlock) {
                    addStatBlockToSearch(statBlock);
                });
            }

            // TODO: Validate various fields
            if (!encounter.statBlocks) {
                encounter.statBlocks = [];
            }

            const encounterBar = document.createElement("div");
            encounterBar.className = "encounter-bar";
            encounterDiv.appendChild(encounterBar);

            const addStatBlockDiv = document.createElement("div");
            const srdSearch = document.createElement("input");
            srdSearch.type = "search";
            srdSearch.placeholder = "Search Stat Blocks";
            srdSearch.setAttribute("list", "searchable-statBlocks");
            addStatBlockDiv.appendChild(srdSearch);
            encounterBar.appendChild(addStatBlockDiv);

            // TODO: Should be able to initiate edit from here? Should this move to top bar?
            const battlePointsDiv = document.createElement("div");
            battlePointsDiv.id = "battle-points";
            battlePointsDiv.innerHTML = `<p>Target Battle Points: ${encounter.targetBattlePoints} (<span name="current-battle-points"></span> <span name="remaining-suffix"></span>) <span title="TODO: Click for summary from BUILDING BALANCED ENCOUNTERS">‚ÑπÔ∏è</span></p>`;
            encounterBar.appendChild(battlePointsDiv);
            refreshBattlePoints();

            const fearDiv = createFearTracker(encounter);
            encounterBar.appendChild(fearDiv);

            const statBlocksDiv = document.createElement("div");
            statBlocksDiv.className = "statBlocks";
            for (let j = 0; j < encounter.statBlocks.length; j++) {
                addStatBlock(statBlocksDiv, encounter, encounter.statBlocks[j]);
            }
            encounterDiv.appendChild(statBlocksDiv);

            const addStatBlockButton = createElement("button", null, "Add Stat Block");
            addStatBlockButton.onclick = function() {
                let selectedOption = srdSearch.value.trim();
                if (!selectedOption) {
                    // TODO: Or some "custom" type?
                    selectedOption = "Jagged Knife Bandit";
                }
                let statBlock = srdStatBlocks.find(function(a) {
                    return a.name.localeCompare(selectedOption, undefined, { sensitivity: 'base' }) === 0;
                });
                if (!statBlock && state.custom && state.custom.statBlocks) {
                    statBlock = state.custom.statBlocks.find(function(a) {
                        return a.name.localeCompare(selectedOption, undefined, { sensitivity: 'base'}) === 0;
                    });
                }
                if (statBlock) {
                    statBlock = JSON.parse(JSON.stringify(statBlock));
                }
                // TODO: Else, custom with given name?

                if (statBlock) {
                    if (statBlock.category == "Adversary" && !statBlock.instances || statBlock.instances.length == 0) {
                        statBlock.instances = [
                            {
                                name: statBlock.name + " #1",
                                hpMarked: 0,
                                stressMarked: 0
                            }
                        ];
                    }

                    if (!encounter.statBlocks) {
                        encounter.statBlocks = [];
                    }
                    encounter.statBlocks.push(statBlock);
                    addStatBlock(statBlocksDiv, encounter, statBlock);
                    saveState();
                }
            };
            addStatBlockDiv.appendChild(addStatBlockButton);

            srdSearch.addEventListener("keyup", function(event) {
                if (event.keyCode === 13) { // Enter key
                    event.preventDefault();
                    addStatBlockButton.click();
                }
            });
        }

        let selectedEncounterIndex = parseInt(localStorage.getItem("selected-encounter-index"));
        if (!selectedEncounterIndex) {
            selectedEncounterIndex = 0;
        }

        let state = null;
        try {
            state = JSON.parse(localStorage.getItem("encounters-state"));
        } catch (error) {
            console.error("Error loading saved encounters:", error);
        }

        function loadFromJsonFile(fileInputEvent, callback) {
            const file = fileInputEvent.target.files[0];
            if (!file) {
                callback(null);
                return;
            }
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    callback(JSON.parse(e.target.result));
                } catch (error) {
                    console.error("Error loading encounters:", error);
                    callback(null);
                }
            };
            reader.onerror = function(e) {
                console.error("Error reading file:", e);
                callback(null);
            };
            reader.readAsText(file);
        }

        document.getElementById("load-encounters").addEventListener("change", function(event) {
            loadFromJsonFile(event, function(loadedState) {
                if (loadedState) {
                    state = loadedState;
                    selectedEncounterIndex = 0;
                    saveState();
                    refreshDisplay();
                } else {
                    alert("Failed to load encounters from file.");
                }
                hideEncounterMenu();
            });
        });

        document.getElementById("import-custom").addEventListener("change", function(event) {
            loadFromJsonFile(event, function(loadedState) {
                if (loadedState && loadedState.custom && loadedState.custom.statBlocks) {
                    if (!state) {
                        // NOTE: This is allowing state without any encounters
                        // TODO: If we keep the browser visible in the no-encounters scenario, make sure it gets updated here
                        state = {};
                    }
                    if (!state.custom) {
                        state.custom = {};
                    }
                    if (!state.custom.statBlocks) {
                        state.custom.statBlocks = [];
                    }
                    state.custom.statBlocks.push(...loadedState.custom.statBlocks);
                    saveState();
                    refreshDisplay();
                } else {
                    alert("Failed to load custom stat blocks from file.");
                }
                hideEncounterMenu();
            });
        });

        function saveToJsonFile(filename, data) {
            const json = JSON.stringify(data, null, "    ");
            const blob = new Blob([json], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        document.getElementById("save-encounters").addEventListener("click", function() {
            saveToJsonFile("encounters.json", state);
            hideEncounterMenu();
        });

        document.getElementById("export-custom").addEventListener("click", function() {
            if (state.custom && state.custom.statBlocks && state.custom.statBlocks.length > 0) {
                saveToJsonFile("custom-stat-blocks.json", { custom: { statBlocks: state.custom.statBlocks } });
            } else {
                alert("No custom stat blocks to export.");
            }
            hideEncounterMenu();
        });

        const encounterSelector = document.getElementById("current-encounter");
        encounterSelector.addEventListener("change", function() {
            selectedEncounterIndex = parseInt(encounterSelector.value);
            saveState();
            refreshDisplay();
            updateBrowsingTier()
        });

        function saveState() {
            localStorage.setItem("encounters-state", JSON.stringify(state));
            localStorage.setItem("selected-encounter-index", selectedEncounterIndex)
        }

        // TODO: This is probably a silly way to do this, we
        //       don't actually want all these DOM elements.
        //       But it's an easy way to get that autocomplete for now.
        const statBlockDatalist = document.createElement("datalist");
        statBlockDatalist.id = "searchable-statBlocks";
        const browsingTableBody = document.querySelector("#browsing tbody");
        for (let i = 0; i < srdStatBlocks.length; i++) {
            addStatBlockToSearch(srdStatBlocks[i]);
        }
        document.body.appendChild(statBlockDatalist);

        refreshDisplay();
        updateBrowsingTableFiltering(); // TODO: Move into refreshDisplay?
    </script>
</html>