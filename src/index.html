<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Fright Night</title>
        <script src="adversaries.js"></script>
        <style>
            :root {
                /* --body-bg-color: rgb(13, 17, 23);
                --text-color: rgb(159, 177, 209);
                --adversary-bg-color: rgb(22, 26, 32);
                --adversary-border-color: rgb(50, 54, 59);
                --adversary-text-color: var(--text-color);
                --header-text-color: #c3d0e5; */

                /* --body-bg-color: rgb(38,36,43);
                --text-color: white; (95,114,176)
                --adversary-bg-color: rgb(45,44,64);
                --stats-bg-color: rgb(50,52,86);
                --adversary-border-color: rgb(63,73,126);
                --adversary-text-color: var(--text-color);
                --header-text-color: white; */

                /** Palette courtesy of https://colorffy.com/dark-theme-generator?colors=825aa2-121212 */
                /** Base colors */
                --clr-dark-a0: #000000;
                --clr-light-a0: #ffffff;

                /** Theme primary colors */
                --clr-primary-a0: #825aa2;
                --clr-primary-a10: #906bac;
                --clr-primary-a20: #9e7db6;
                --clr-primary-a30: #ac8fc1;
                --clr-primary-a40: #b9a1cb;
                --clr-primary-a50: #c7b3d5;

                /** Theme surface colors */
                --clr-surface-a0: #121212;
                --clr-surface-a10: #282828;
                --clr-surface-a20: #3f3f3f;
                --clr-surface-a30: #575757;
                --clr-surface-a40: #717171;
                --clr-surface-a50: #8b8b8b;

                /** Theme tonal surface colors */
                --clr-surface-tonal-a0: #1c191f;
                --clr-surface-tonal-a10: #312e34;
                --clr-surface-tonal-a20: #47444a;
                --clr-surface-tonal-a30: #5f5c61;
                --clr-surface-tonal-a40: #777579;
                --clr-surface-tonal-a50: #918f93;

                --body-bg-color: var(--clr-surface-a0);
                --text-color: var(--clr-light-a0);
                --adversary-bg-color: var(--clr-surface-a10);
                --stats-bg-color: var(--clr-surface-a20);
                --adversary-border-color: var(--adversary-bg-color);
                --adversary-text-color: var(--text-color);
                --header-text-color: var(--clr-primary-a50);

                --button-bg-color: var(--clr-primary-a20);
                --button-bg-hover-color: var(--clr-primary-a10);
                --button-bg-active-color: var(--clr-primary-a0);
                --button-text-color: var(--clr-dark-a0);
            }
            body {
                background-color: var(--body-bg-color);
                color: var(--text-color);
            }
            #copyright, #repo-info {
                font-size: smaller;
                margin-top: 10px;
            }
            input#load-encounters {
                /* Hide the file input element and style its label as a button */
                display: none;
            }
            #load-encounters-container {
                /* Need vertical margin to make room for label padding */
                margin: 10px 0px;
            }
            #load-encounters-container label {
                /* TODO: When styling real buttons, don't forget to update this to match */
                background-color: var(--button-bg-color);
                color: var(--button-text-color);
                padding: 5px;
                border-radius: 8px;
                height: auto;
            }
            #load-encounters-container label:hover {
                background-color: var(--button-bg-hover-color);
            }
            #load-encounters-container label:active {
                background-color: var(--button-bg-active-color);
            }

            .adversary {
                position: relative; /* For action button */
                display: inline-block;
                vertical-align: top;
                /*
                    22em is empirical width needed to fit full ATK line for Volcanic Dragon: Ashen Tyrant.
                    Longest ATK line in SRD is "Fallen Warlord: Undefeated Champion",
                    which requires 27em (at 22em, both ATK and Experience lines overflow).
                    27em feels way too wide. Trying 23em, which is enough to stop Fallen Warlord's
                    Experience line from overflowing.
                */
                width: 23em;
                border: 1px ridge var(--adversary-border-color);
                border-radius: 5px;
                margin-right: 5px;
                margin-top: 5px;
                padding: 5px 10px;
                background-color: var(--adversary-bg-color);
                color: var(--adversary-text-color);
            }
            .adversary h3 {
                margin: 8px 0px;
                color: var(--header-text-color);
            }
            .adversary p {
                margin: 2px 0px;
            }
            .adversary .source {
                font-style: italic;
                font-size: smaller;
            }
            .adversary .tier {
                font-style: italic;
                font-weight: bold;
            }
            .adversary .description {
                font-size: smaller;
                font-style: italic;
            }
            .adversary .motives {
                font-size: smaller;
            }
            .adversary .stats {
                background-color: var(--stats-bg-color);
                border-radius: 3px;
            }
            .adversary .statLabel, .adversary .motivesLabel {
                font-weight: bold;
            }
            .adversary .divider {
                font-size: larger;
                margin: 0px 3px;
            }
            .features {
                margin-left: 0.75em;
            }
            .featuresExpander summary {
                font-weight: bold;
            }
            .features .feature {
                text-indent: -0.75em
            }
            .featureLabel {
                font-style: italic;
                font-weight: bold;
            }

            .slots {
                display: inline-block
            }

            .conditions {
                margin: 5px 0px;
            }
            ul.conditions-list {
                list-style: none;
                display: inline;
                padding: 0px;
            }
            ul.conditions-list li {
                display: inline;
                margin-right: 5px;
            }

            ul.modifications-list {
                margin: 5px 0px;
            }

            button {
                /* font-size: 1.5em;
                line-height: 1em; */
                padding: 5px;
                border-radius: 8px;
                color: var(--button-text-color);
                border: 0px;
                background-color: var(--button-bg-color);
            }
            button:hover {
                background-color: var(--button-bg-hover-color);
            }
            button:active {
                background-color: var(--button-bg-active-color);
            }

            button.inline-delete {
                background-color: transparent;
                color: var(--clr-primary-a50);
                border: 0px;
                border-radius: 3px;
                padding: 2px 4px;
                margin: 0px 1px;
                font-size: smaller;
            }

            button.inline-add {
                border: 0px;
                border-radius: 2px;
                padding: 3px 4px;
            }

            button.action {
                float: right;
            }
            button.action-top {
                position: absolute;
                right: 5px;
                top: 5px;

                padding: 2px 4px;
                border-radius: 4px;
                font-size: smaller;
            }

            .actions-menu {
                position: absolute;
                right: 5px;
                top: 30px;
                margin: 0px;
                padding: 0px;
                list-style-type: none;
                /* TODO: Make this look like a menu, round some corners, etc */
            }
            .actions-menu button {
                border-radius: 0px;
                width: 100%;
            }
        </style>
    </head>

    <body>
        <datalist id="srd-conditions">
            <option value="Hidden"></option>
            <option value="Restrained"></option>
            <option value="Vulnerable"></option>
            <option value="Asleep"></option>
            <option value="Stunned"></option>
            <option value="Silenced"></option>
            <option value="Corroded"></option>
            <option value="Ranger's Focus"></option>
            <option value="Cloaked"></option>
            <option value="Dizzied"></option>
            <option value="Enveloped"></option>
        </datalist>

        <datalist id="modifiable-properties">
            <option value="difficulty"></option>
            <option value="majorThreshold"></option>
            <option value="severeThreshold"></option>
        </datalist>

        <div id="load-encounters-container">
            <label for="load-encounters">Load Encounters (replaces existing encounters)</label>
            <input type="file" id="load-encounters" accept=".json" />
        </div>

        <div id="encounters"></div>

        <div id="repo-info">
            <p>Fright Night is free and open source and works entirely offline. Please <a href="https://github.com/sandyarmstrong/frightnight/issues">report any bugs or feature requests</a>.</p>
        </div>

        <div id="copyright">
            <p>This project includes materials from the Daggerheart System Reference Document 1.0,
                © Critical Role, LLC. under the terms of the Darrington Press Community Gaming (DPCGL) License.
                More information can be found at <a href="https://www.daggerheart.com">https://www.daggerheart.com</a>.
                Minor formatting modifications were provided as part of the excellent
                <a href="https://github.com/seansbox/daggerheart-srd">https://github.com/seansbox/daggerheart-srd</a>.</p>
        </div>
    </body>

    <script>
        // TODO: Consider moving hp/stress/conditions/modifications state to something
        //       like adversaries[n].instances[] so that we can behave like the Quickstart
        //       and have one statblock for muliple identical enemies. But need to decide
        //       how to display conditions and especially modifications in that case.
        //
        //       Do this sooner rather than later, even if only one instance is supported,
        //       to avoid breaking state compatibility.
        //
        //       Also, some questions:
        //       - Presumably, there would be a + button to add a new instance right in
        //         the statblock. But what if a user adds the same adversary type from
        //         the search? Should this use the same statblock or start a new "group"?
        //         I think I prefer the latter, let users decide if they prefer shared
        //         or separate statblocks, and they might have use for grouping anyway.
        //       - How to handle naming? Wouldn't want to name the whole statblock
        //         "Jagged Knife Bandit #1" anymore.
        //       - Are there modifications that can change number of HP/Stress slots?
        var sampleState = {
            "encounters": [
                {
                    "name": "Forest Ambush",
                    "targetBattlePoints": 10, // Allows telling user they might need more or less adversaries
                    "currentFear": 5, // Convenient. Also allows remembering fear state for different groups
                    "playerTier": 1, // Needed to help calculate battle points, if adversary tiers differ
                    "playerCount": 3, // Need to calculate minion battle points
                    "description": "A group of bandits ambushes the party in a dense forest.",
                    "adversaries": [
                        {
                            "name": "Bandit #1",
                            "originalName": "Jagged Knife Bandit",
                            "source": "SRD",
                            "tier": 1,
                            "type": "Standard",
                            "difficulty": 12,
                            "majorThreshold": 8,
                            "severeThreshold": 14,
                            "hp": {
                                "slots": 5,
                                "marked": 3
                            },
                            "stress": {
                                "slots": 3,
                                "marked": 0
                            },
                            "modifications": [
                                {
                                    "modificationName": "Distracted",
                                    "propertyName": "difficulty",
                                    "modification": "-2" // - or + to modify, or just a number to hard-set, mods are applied in order
                                }
                            ],
                            "conditions": [
                                "Restrained",
                                "Vulnerable"
                            ]
                        }
                    ]
                }
            ],
            "customAdversaries": [], // Yay homebrew, allow searching this, adding, modifying
            "environments": [] // Big TODO
        };

        // TODO: Change all code that puts user data directly into innerHTML

        const adversaryRemovedEvent = new Event("adversaryRemoved");
        const adversaryCopiedEvent = new Event("adversaryCopied");
        const adversaryCopiedFromSourceEvent = new Event("adversaryCopiedFromSource");

        var expandAllDetails = false;

        function handleDetailsToggle(event) {
            var opened = event.target.open
            if (expandAllDetails != opened) {
                expandAllDetails = opened;
                for (const element of document.getElementsByTagName("details")) {
                    if (element.open != expandAllDetails) {
                        element.open = expandAllDetails;
                    }
                }
            }
        }

        function createFearTracker(encounter, saveState) {
            // TODO: Nice simple rich tooltip guide: https://jsfiddle.net/8nnwytbL/
            // TODO: Roller for getting fear on rests?
            // TODO: Replace this with a stylized number input?
            var fearDiv = document.createElement("div");

            var fearValue = document.createElement("span");

            function updateFearDisplay() {
                fearValue.innerText = "💀".repeat(encounter.currentFear);
                fearValue.title = `${encounter.currentFear} Fear | Start: {number of PCs} | Short rest: 1d4 | Long rest: 1d4 + {number of PCs}`;
            }
            updateFearDisplay();

            var useFearButton = document.createElement("button");
            useFearButton.innerText = "-";
            useFearButton.title = "Use 1 Fear";
            useFearButton.onclick = function() {
                if (encounter.currentFear > 0) {
                    encounter.currentFear--;
                    updateFearDisplay();
                    saveState();
                }
            };

            var gainFearButton = document.createElement("button");
            gainFearButton.innerText = "+";
            gainFearButton.title = "Gain 1 Fear (max 12)";
            gainFearButton.onclick = function() {
                if (encounter.currentFear < 12) {
                    encounter.currentFear++;
                    updateFearDisplay();
                    saveState();
                }
            };

            fearDiv.appendChild(useFearButton);
            fearDiv.appendChild(gainFearButton);
            fearDiv.appendChild(fearValue);

            return fearDiv;
        }

        function updateResource(container, resource, saveState) {
            var elements = [];

            for (var i = 0; i < resource.slots; i++) {
                var slot = document.createElement("input");
                slot.type = "checkbox";
                if (i < resource.marked) {
                    slot.checked = true;
                }
                slot.onclick = function(event) {
                    if (event.target.checked) {
                        resource.marked++;
                    } else {
                        resource.marked--;
                    }
                    updateResource(container, resource, saveState);
                    saveState();
                };
                elements.push(slot);
            }

            container.replaceChildren(...elements);
        }

        function createAdversaryElement(encounter, adversary, saveState) {
            // TODO: Add ... menu with Edit, Duplicate, Duplicate From Source
            // - Edit:
            //     Full adversary editor form, same as for creating custom adversaries
            //     TODO: Add ability to create customer adversaries with this form
            // - Duplicate:
            //     Create a new adversary based on this one, including all edits
            //     but excluding conditions/modifications
            // - Duplicate From Source:
            //     Create a new adversary from the source adversary,
            //     ignoring all edits/conditions/modifications
            // TODO: Allow reordering?

            var warning = "";
            if (adversary.tier > encounter.playerTier) {
                warning += "⚠️ above player tier";
            }
            else if (adversary.tier < encounter.playerTier) {
                warning += "⚠️ below player tier"
            }

            var adversaryDiv = document.createElement("div");
            adversaryDiv.className = "adversary";
            adversaryDiv.innerHTML = `<h3>${adversary.name}</h3> <p class="source">(${adversary.originalName}, ${adversary.source})</p>`;

            var tierAndType = document.createElement("p");
            tierAndType.className = "tier";
            tierAndType.innerText = `Tier ${adversary.tier} ${adversary.type}`;
            if (warning) {
                tierAndType.innerHTML += ` <span class="warning">(${warning})</span>`;
            }
            adversaryDiv.appendChild(tierAndType);

            if (adversary.description) {
                var description = document.createElement("p");
                description.className =  "description";
                description.innerText = adversary.description;
                adversaryDiv.appendChild(description);
            }

            if (adversary.motivesAndTactics) {
                var motives = document.createElement("p");
                motives.className =  "motives";
                motives.innerHTML = `<span class="motivesLabel">Motives & Tactics:</span> ${adversary.motivesAndTactics}`;
                adversaryDiv.appendChild(motives);
            }

            var stats = document.createElement("p");
            stats.className = "stats";
            var thresholds = "None";
            if (Number.isInteger(adversary.majorThreshold) && Number.isInteger(adversary.severeThreshold)) {
                thresholds = `${adversary.majorThreshold}/${adversary.severeThreshold}`;
            }
            stats.innerHTML = `<span class="statLabel">Difficulty:</span> ${adversary.difficulty} <span class="divider">|</span> <span class="statLabel">Thresholds:</span> ${thresholds}`;
            if (adversary.attackDescription) {
                stats.innerHTML += `<br><span class="statLabel">ATK:</span> ${adversary.attackModifier} <span class="divider">|</span> <span class="statLabel">${adversary.attackDescription}:</span> ${adversary.attackRange} <span class="divider">|</span> ${adversary.attackDamage}`;
            }
            if (adversary.experience) {
                // TODO: <hr> is lame to style, but add some sort of divider above this (top border?)
                stats.innerHTML += `<br><span class="statLabel experiences">Experience:</span> ${adversary.experience}`;
            }
            adversaryDiv.appendChild(stats);

            if (adversary.features && adversary.features.length > 0) {
                var featuresContainer = document.createElement("details");
                featuresContainer.className = "featuresExpander";
                featuresContainer.innerHTML = `<summary>FEATURES</summary>`;
                var featuresDiv = document.createElement("div");
                featuresDiv.className = "features";
                featuresContainer.appendChild(featuresDiv);
                featuresContainer.addEventListener("toggle", handleDetailsToggle);

                for (var i = 0; i < adversary.features.length; i++) {
                    var featureElement = document.createElement("p");
                    featureElement.className = "feature"; // TODO: Make sure to style with that indent on following lines
                    featuresDiv.appendChild(featureElement);

                    var label = document.createElement("span");
                    label.className = "featureLabel";
                    label.innerText = `${adversary.features[i].name}:`;
                    featureElement.appendChild(label);

                    var description = document.createElement("span");
                    description.innerText = ` ${adversary.features[i].text}`;
                    featureElement.appendChild(description);
                }

                adversaryDiv.appendChild(featuresContainer);
            }

            var hpDiv = document.createElement("div");
            hpDiv.className = "slotInfo";
            hpDiv.innerHTML = "HP:";
            var hpSlotsDiv = document.createElement("div");
            hpSlotsDiv.className = "slots";
            updateResource(hpSlotsDiv, adversary.hp, saveState);
            hpDiv.appendChild(hpSlotsDiv);
            adversaryDiv.appendChild(hpDiv);

            var stressDiv = document.createElement("div");
            stressDiv.className = "slotInfo";
            stressDiv.innerHTML = "Stress:";
            var stressSlotsDiv = document.createElement("div");
            stressSlotsDiv.className = "slots";
            updateResource(stressSlotsDiv, adversary.stress, saveState);
            stressDiv.appendChild(stressSlotsDiv);
            adversaryDiv.appendChild(stressDiv);

            // TODO: Parse modifications and reflect them in the stats
            var conditionsDiv = document.createElement("div");
            conditionsDiv.className = "conditions";
            var conditionsDisplayDiv = document.createElement("div");
            conditionsDiv.appendChild(conditionsDisplayDiv)

            function updateConditionsDisplay() {
                conditionsDisplayDiv.innerHTML = "Conditions: ";
                if (adversary.conditions && adversary.conditions.length > 0) {
                    var conditionsList = document.createElement("ul");
                    conditionsList.className = "conditions-list";
                    for (var i = 0; i < adversary.conditions.length; i++) {
                        var condition = adversary.conditions[i];

                        var conditionItem = document.createElement("li");
                        conditionsList.appendChild(conditionItem);

                        var conditionText = document.createElement("span");
                        conditionText.innerText = condition;
                        conditionItem.appendChild(conditionText);

                        var removeButton = document.createElement("button");
                        removeButton.className = "inline-delete";
                        removeButton.innerText = "X";
                        removeButton.title = "Remove condition";
                        removeButton.condition = condition;
                        removeButton.onclick = function(event) {
                            adversary.conditions = adversary.conditions.filter(function(c) {
                                return c !== event.target.condition;
                            });
                            updateConditionsDisplay();
                            saveState();
                        };
                        conditionItem.appendChild(removeButton);
                    }
                    conditionsDisplayDiv.appendChild(conditionsList);
                } else {
                    conditionsDisplayDiv.innerText += " None";
                }
            }

            updateConditionsDisplay();

            var addConditionsDiv = document.createElement("div");
            var addConditionInput = document.createElement("input");
            addConditionInput.type = "text";
            addConditionInput.setAttribute("list", "srd-conditions");
            var addConditionButton = document.createElement("button");
            addConditionButton.className = "inline-add";
            addConditionButton.innerText = "+";
            addConditionButton.title = "Add condition";
            addConditionButton.onclick = function() {
                var condition = addConditionInput.value.trim();
                if (condition && (!adversary.conditions || !adversary.conditions.includes(condition))) {
                    if (!adversary.conditions) {
                        adversary.conditions = [];
                    }
                    adversary.conditions.push(condition);
                    addConditionInput.value = "";
                    updateConditionsDisplay();
                    saveState();
                }
            };
            addConditionInput.addEventListener("keyup", function(event) {
                if (event.keyCode === 13) { // Enter key
                    event.preventDefault();
                    addConditionButton.click();
                }
            });
            addConditionsDiv.appendChild(addConditionInput);
            addConditionsDiv.appendChild(addConditionButton);
            conditionsDiv.appendChild(addConditionsDiv);
            adversaryDiv.appendChild(conditionsDiv);

            var modificationsContainer = document.createElement("details");
            modificationsContainer.innerHTML = `<summary>Modifications</summary>`;
            var modificationsDiv = document.createElement("div");
            modificationsDiv.className = "modifications";
            modificationsContainer.appendChild(modificationsDiv);
            var modificationsDisplayDiv = document.createElement("div");
            modificationsDiv.appendChild(modificationsDisplayDiv);
            modificationsContainer.addEventListener("toggle", handleDetailsToggle);

            function updateModificationsDisplay() {
                modificationsDisplayDiv.innerHTML = "";
                if (adversary.modifications && adversary.modifications.length > 0) {
                    var modificationsList = document.createElement("ul");
                    modificationsList.className = "modifications-list";
                    for (var i = 0; i < adversary.modifications.length; i++) {
                        var modification = adversary.modifications[i];

                        var modificationItem = document.createElement("li");
                        modificationsList.appendChild(modificationItem);

                        var modificationText = document.createElement("span");
                        modificationText.innerText = `${modification.modificationName} (${modification.propertyName} ${modification.modification})`;
                        modificationItem.appendChild(modificationText);

                        var removeButton = document.createElement("button");
                        removeButton.className = "inline-delete";
                        removeButton.innerText = "X";
                        removeButton.title = "Remove modification";
                        removeButton.modification = modification;
                        removeButton.onclick = function(event) {
                            adversary.modifications = adversary.modifications.filter(function(m) {
                                return m !== event.target.modification;
                            });
                            updateModificationsDisplay();
                            saveState();
                        };
                        modificationItem.appendChild(removeButton);
                    }
                    modificationsDisplayDiv.appendChild(modificationsList);
                }
            }

            updateModificationsDisplay();

            // TODO: This UI is pretty big, taking up a lot of space if
            //       there are a lot of adversaries, even if there are no modifications.
            //       Could make the input into a modal instead. Could also consider
            //       displaying modifications directly in the stats, with details
            //       on hover (but then how to delete?).
            var addModificationsDiv = document.createElement("div");
            var addModificationNameInput = document.createElement("input");
            addModificationNameInput.type = "text";
            addModificationNameInput.placeholder = "Name";
            var addModificationPropertyInput = document.createElement("input");
            addModificationPropertyInput.type = "text";
            addModificationPropertyInput.placeholder = "Target Property";
            addModificationPropertyInput.setAttribute("list", "modifiable-properties");
            var addModificationValueInput = document.createElement("input");
            addModificationValueInput.type = "text";
            addModificationValueInput.placeholder = "Modifier (e.g. -2, +3, 10)";
            var addModificationButton = document.createElement("button");
            addModificationButton.className = "inline-add";
            addModificationButton.innerText = "+";
            addModificationButton.title = "Add modification";
            addModificationButton.onclick = function() {
                var modificationName = addModificationNameInput.value.trim();
                var propertyName = addModificationPropertyInput.value.trim();
                var modificationValue = addModificationValueInput.value.trim();
                if (modificationName && propertyName && modificationValue) {
                    if (!adversary.modifications) {
                        adversary.modifications = [];
                    }
                    adversary.modifications.push({
                        modificationName: modificationName,
                        propertyName: propertyName,
                        modification: modificationValue
                    });
                    addModificationNameInput.value = "";
                    addModificationPropertyInput.value = "";
                    addModificationValueInput.value = "";
                    updateModificationsDisplay();
                    saveState();
                }
            };
            addModificationsDiv.appendChild(addModificationNameInput);
            addModificationsDiv.appendChild(addModificationPropertyInput);
            addModificationsDiv.appendChild(addModificationValueInput);
            addModificationsDiv.appendChild(addModificationButton);
            modificationsDiv.appendChild(addModificationsDiv);
            adversaryDiv.appendChild(modificationsContainer);

            // var addInstanceButton = document.createElement("button");
            // addInstanceButton.className = "action";
            // addInstanceButton.innerText = "+ Add";
            // addInstanceButton.title = "Add another instance of this adversary";
            // adversaryDiv.appendChild(addInstanceButton);

            var actionsMenu = document.createElement("menu");
            actionsMenu.className = "actions-menu";

            var copyAction = document.createElement("li");
            copyAction.innerHTML = `<button class="menu-action">Copy</button>`;
            copyAction.title = "Copy this adversary, including all changed state";
            copyAction.onclick = function() {
                adversaryDiv.dispatchEvent(adversaryCopiedEvent);
                actionsMenu.remove();
            };
            actionsMenu.appendChild(copyAction);

            var copyFromSourceAction = document.createElement("li");
            copyFromSourceAction.innerHTML = `<button class="menu-action">Copy From Source</button>`;
            copyFromSourceAction.title = "Copy this adversary from the source, ignoring all changes";
            copyFromSourceAction.onclick = function() {
                adversaryDiv.dispatchEvent(adversaryCopiedFromSourceEvent);
                actionsMenu.remove();
            };
            actionsMenu.appendChild(copyFromSourceAction);

            var deleteAction = document.createElement("li");
            deleteAction.innerHTML = `<button class="menu-action">Remove</button>`;
            deleteAction.title = "Remove this adversary from the encounter";
            deleteAction.onclick = function() {
                adversaryDiv.dispatchEvent(adversaryRemovedEvent);
                actionsMenu.remove();
            };
            actionsMenu.appendChild(deleteAction);

            var actionsButton = document.createElement("button");
            actionsButton.className = "action-top";
            actionsButton.innerText = "…";
            actionsButton.title = "Adversary management actions";
            actionsButton.onclick = function() {
                if (actionsMenu.parentElement) {
                    actionsMenu.remove();
                } else {
                    adversaryDiv.appendChild(actionsMenu);
                }
            };
            adversaryDiv.appendChild(actionsButton);

            return adversaryDiv;
        }

        function addAdversary(container, encounter, adversary, refreshBattlePoints, saveState) {
            var adversaryElement = createAdversaryElement(encounter, adversary, saveState);

            adversaryElement.addEventListener("adversaryRemoved", function(event) {
                encounter.adversaries = encounter.adversaries.filter(function(a) {
                    return a !== adversary;
                });
                container.removeChild(adversaryElement);
                refreshBattlePoints();
                saveState();
            });
            adversaryElement.addEventListener("adversaryCopied", function(event) {
                var newAdversary = JSON.parse(JSON.stringify(adversary)); // Deep copy
                newAdversary.name += " (copy)"; // TODO: Decide naming
                if (!encounter.adversaries) {
                    encounter.adversaries = [];
                }
                encounter.adversaries.push(newAdversary);
                addAdversary(container, encounter, newAdversary, refreshBattlePoints, saveState);
                saveState();
            });
            adversaryElement.addEventListener("adversaryCopiedFromSource", function(event) {
                // TODO: Support non-SRD sources
                if (adversary.source !== "SRD") {
                    console.warn("Copying from non-SRD sources is not supported yet.");
                    return;
                }
                var sourceAdversary = srdAdversaries.find(function(a) {
                    return a.name === adversary.originalName;
                });
                var newAdversary = convertFromSRD(sourceAdversary);
                newAdversary.name += " (copy)"; // TODO: Decide naming
                if (!encounter.adversaries) {
                    encounter.adversaries = [];
                }
                encounter.adversaries.push(newAdversary);
                addAdversary(container, encounter, newAdversary, refreshBattlePoints, saveState);
                saveState();
            });

            container.appendChild(adversaryElement);
            refreshBattlePoints();
        }

        function convertFromSRD(srdAdversary) {
            var thresholds = srdAdversary.thresholds.split("/");
            return {
                name: srdAdversary.name,
                originalName: srdAdversary.name,
                source: "SRD",
                tier: parseInt(srdAdversary.tier),
                type: srdAdversary.type,
                description: srdAdversary.description,
                motivesAndTactics: srdAdversary.motives_and_tactics,
                difficulty: parseInt(srdAdversary.difficulty),
                hp: {
                    slots: parseInt(srdAdversary.hp),
                    marked: 0
                },
                stress: {
                    slots: parseInt(srdAdversary.stress),
                    marked: 0
                },
                majorThreshold: parseInt(thresholds[0]),
                severeThreshold: parseInt(thresholds[1]),
                attackModifier: srdAdversary.atk,
                attackDescription: srdAdversary.attack,
                attackRange: srdAdversary.range,
                attackDamage: srdAdversary.damage,
                experience: srdAdversary.experience,
                features: srdAdversary.feats // array of name/text
            };
        }

        function calculateBattlePoints(encounter)
        {
            var currentBattlePoints = 0;
            for (var j = 0; j < encounter.adversaries.length; j++) {
                var adversary = encounter.adversaries[j];
                // TODO: Deal with tier differences
                switch(adversary.type.toLowerCase()) {
                    case "minion":
                        currentBattlePoints += 1 / encounter.playerCount;
                        break;
                    case "social":
                    case "support":
                        currentBattlePoints += 1;
                        break;
                    case "horde":
                    case "ranged":
                    case "skulk":
                    case "standard":
                        currentBattlePoints += 2;
                        break;
                    case "leader":
                    case "elite":
                        currentBattlePoints += 3;
                        break;
                    case "bruiser":
                        currentBattlePoints += 4;
                        break;
                    case "solo":
                        currentBattlePoints += 5;
                        break;
                }
            }
            return currentBattlePoints;
        }

        function displayEncounters(state) {
            function saveState() {
                localStorage.setItem("encounters-state", JSON.stringify(state));
            }

            var encountersDiv = document.getElementById("encounters");
            encountersDiv.innerHTML = ""; // Clear any existing content

            var saveEncountersButton = document.createElement("button");
            saveEncountersButton.innerText = "Save Encounters";
            encountersDiv.appendChild(saveEncountersButton);

            saveEncountersButton.addEventListener("click", function() {
                var json = JSON.stringify(state, null, "    ");
                var blob = new Blob([json], { type: "application/json" });
                var url = URL.createObjectURL(blob);
                var a = document.createElement("a");
                a.href = url;
                a.download = "encounters.json";
                a.click();
                URL.revokeObjectURL(url);
            });

            // TODO: Actually, show one encounter at a time, and allow switching between them,
            //       as well as adding or deleting encounters.
            for (var i = 0; i < state.encounters.length; i++) {
                var encounter = state.encounters[i];
                var encounterDiv = document.createElement("div");
                encounterDiv.className = "encounter";
                encounterDiv.innerHTML = `<h2>${encounter.name} (Tier ${encounter.playerTier} | ${encounter.playerCount} Players)</h2><p>${encounter.description}</p>`;

                var fearDiv = createFearTracker(encounter, saveState);
                encounterDiv.appendChild(fearDiv);

                var battlePointsDiv = document.createElement("div");
                battlePointsDiv.innerHTML = `<p>Target Battle Points: ${encounter.targetBattlePoints} (<span name="current-battle-points"></span> <span name="remaining-suffix"></span>) <span title="TODO: Click for summary from BUILDING BALANCED ENCOUNTERS">ℹ️</span></p>`;
                encounterDiv.appendChild(battlePointsDiv);

                function refreshBattlePoints() {
                    var currentBattlePoints = calculateBattlePoints(encounter);

                    // Round to nearest 0.1 for display
                    var remainingBattlePoints = Math.round((encounter.targetBattlePoints - currentBattlePoints) * 10) / 10;

                    if (remainingBattlePoints < 0) {
                        battlePointsDiv.querySelector("[name='current-battle-points']").innerText = `⚠️ ${Math.abs(remainingBattlePoints)}`;
                        battlePointsDiv.querySelector("[name='remaining-suffix']").innerText = "over";
                    } else {
                        battlePointsDiv.querySelector("[name='current-battle-points']").innerText = Math.abs(remainingBattlePoints);
                        battlePointsDiv.querySelector("[name='remaining-suffix']").innerText = "left";
                    }
                }
                refreshBattlePoints();

                // TODO: Better would be a list of adversaries to choose from,
                //       with filtering based on tier/type + text search.
                //       Rows should include name, source, battle points.
                var addAdversaryDiv = document.createElement("div");
                var srdSearch = document.createElement("input");
                srdSearch.type = "search";
                srdSearch.placeholder = "Search SRD Adversaries";
                srdSearch.setAttribute("list", "srd-adversaries");
                addAdversaryDiv.appendChild(srdSearch);
                encounterDiv.appendChild(addAdversaryDiv);

                var adversariesDiv = document.createElement("div");
                for (var j = 0; j < encounter.adversaries.length; j++) {
                    addAdversary(adversariesDiv, encounter, encounter.adversaries[j], refreshBattlePoints, saveState);
                }
                encounterDiv.appendChild(adversariesDiv);

                var addAdversaryButton = document.createElement("button");
                addAdversaryButton.innerText = "Add Adversary";
                addAdversaryButton.onclick = function() {
                    var selectedOption = srdSearch.value.trim();
                    if (!selectedOption) {
                        // TODO: Or some "custom" type?
                        selectedOption = "Jagged Knife Bandit";
                    }
                    var srdAdversary = srdAdversaries.find(function(a) {
                        return a.name.localeCompare(selectedOption, undefined, { sensitivity: 'base' }) === 0;
                    });
                    if (srdAdversary) {
                        var adversary = convertFromSRD(srdAdversary);
                        var maxDuplicateNumber = 0;
                        for (var k = 0; k < encounter.adversaries.length; k++) {
                            var existingAdversaryNameParts = encounter.adversaries[k].name.split(" #");
                            if (existingAdversaryNameParts[0] === adversary.name) {
                                if (existingAdversaryNameParts.length > 1) {
                                    maxDuplicateNumber = Math.max(parseInt(existingAdversaryNameParts[1]), maxDuplicateNumber);
                                }
                            }
                        }
                        adversary.name += " #" + (maxDuplicateNumber + 1);

                        if (!encounter.adversaries) {
                            encounter.adversaries = [];
                        }
                        encounter.adversaries.push(adversary);
                        addAdversary(adversariesDiv, encounter, adversary, refreshBattlePoints, saveState);
                        saveState();
                    }
                };
                addAdversaryDiv.appendChild(addAdversaryButton);

                srdSearch.addEventListener("keyup", function(event) {
                    if (event.keyCode === 13) { // Enter key
                        event.preventDefault();
                        addAdversaryButton.click();
                    }
                });

                encountersDiv.appendChild(encounterDiv);
            }
        }

        // TODO: This is probably a silly way to do this, we
        //       don't actually want all these DOM elements.
        //       But it's an easy way to get that autocomplete for now.
        // TODO: Also, we want a broader search option, should be able
        //       to search by source, tier, and other arbitrary property text,
        //       and allow easier browsing.
        var srdDatalist = document.createElement("datalist");
        srdDatalist.id = "srd-adversaries";
        for (var i = 0; i < srdAdversaries.length; i++) {
            var option = document.createElement("option");
            option.value = srdAdversaries[i].name;
            srdDatalist.appendChild(option);
        }
        document.body.appendChild(srdDatalist);

        var persistedStateJson = localStorage.getItem("encounters-state");
        if (persistedStateJson) {
            try {
                var state = JSON.parse(persistedStateJson);
                displayEncounters(state);
            } catch (error) {
                console.error("Error loading saved encounters:", error);
                displayEncounters(sampleState);
            }
        } else {
            console.warn("No saved encounters found, displaying sample encounters.");
            displayEncounters(sampleState);
        }

        var fileInput = document.getElementById("load-encounters");
        fileInput.addEventListener("change", function(event) {
            var file = event.target.files[0];
            if (file) {
                var reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        var state = JSON.parse(e.target.result);
                        displayEncounters(state);
                    } catch (error) {
                        console.error("Error loading encounters:", error);
                    }
                };
                reader.onerror = function(e) {
                    console.error("Error reading file:", e);
                };
                reader.readAsText(file);
            }
        });
    </script>
</html>